<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>livekit.rtc.room API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>livekit.rtc.room</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="livekit.rtc.room.ConnectError"><code class="flex name class">
<span>class <span class="ident">ConnectError</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConnectError(Exception):
    def __init__(self, message: str):
        self.message = message</code></pre>
</details>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="livekit.rtc.room.DataPacket"><code class="flex name class">
<span>class <span class="ident">DataPacket</span></span>
<span>(</span><span>data: bytes,<br>kind: proto_room.DataPacketKind.ValueType,<br>participant: RemoteParticipant | None,<br>topic: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class DataPacket:
    data: bytes
    &#34;&#34;&#34;The payload of the data packet.&#34;&#34;&#34;
    kind: proto_room.DataPacketKind.ValueType
    &#34;&#34;&#34;Type of the data packet (e.g., RELIABLE, LOSSY).&#34;&#34;&#34;
    participant: RemoteParticipant | None
    &#34;&#34;&#34;Participant who sent the data. None when sent by a server SDK.&#34;&#34;&#34;
    topic: str | None = None
    &#34;&#34;&#34;Topic associated with the data packet.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>DataPacket(data: 'bytes', kind: 'proto_room.DataPacketKind.ValueType', participant: 'RemoteParticipant | None', topic: 'str | None' = None)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.room.DataPacket.data"><code class="name">var <span class="ident">data</span> : bytes</code></dt>
<dd>
<div class="desc"><p>The payload of the data packet.</p></div>
</dd>
<dt id="livekit.rtc.room.DataPacket.kind"><code class="name">var <span class="ident">kind</span> : int</code></dt>
<dd>
<div class="desc"><p>Type of the data packet (e.g., RELIABLE, LOSSY).</p></div>
</dd>
<dt id="livekit.rtc.room.DataPacket.participant"><code class="name">var <span class="ident">participant</span> : <a title="livekit.rtc.participant.RemoteParticipant" href="participant.html#livekit.rtc.participant.RemoteParticipant">RemoteParticipant</a> | None</code></dt>
<dd>
<div class="desc"><p>Participant who sent the data. None when sent by a server SDK.</p></div>
</dd>
<dt id="livekit.rtc.room.DataPacket.topic"><code class="name">var <span class="ident">topic</span> : str | None</code></dt>
<dd>
<div class="desc"><p>Topic associated with the data packet.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.room.Room"><code class="flex name class">
<span>class <span class="ident">Room</span></span>
<span>(</span><span>loop: Optional[asyncio.AbstractEventLoop] = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Room(EventEmitter[EventTypes]):
    def __init__(
        self,
        loop: Optional[asyncio.AbstractEventLoop] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initializes a new Room instance.

        Parameters:
            loop (Optional[asyncio.AbstractEventLoop]): The event loop to use. If not provided, the default event loop is used.
        &#34;&#34;&#34;
        super().__init__()

        self._ffi_handle: Optional[FfiHandle] = None
        self._loop = loop or asyncio.get_event_loop()
        self._room_queue = BroadcastQueue[proto_ffi.FfiEvent]()
        self._info = proto_room.RoomInfo()
        self._rpc_invocation_tasks: set[asyncio.Task] = set()
        self._data_stream_tasks: set[asyncio.Task] = set()

        self._remote_participants: Dict[str, RemoteParticipant] = {}
        self._connection_state = ConnectionState.CONN_DISCONNECTED
        self._first_sid_future = asyncio.Future[str]()
        self._local_participant: LocalParticipant | None = None

        self._text_stream_readers: Dict[str, TextStreamReader] = {}
        self._byte_stream_readers: Dict[str, ByteStreamReader] = {}
        self._text_stream_handlers: Dict[str, TextStreamHandler] = {}
        self._byte_stream_handlers: Dict[str, ByteStreamHandler] = {}

    def __del__(self) -&gt; None:
        if self._ffi_handle is not None:
            FfiClient.instance.queue.unsubscribe(self._ffi_queue)

    @property
    async def sid(self) -&gt; str:
        &#34;&#34;&#34;Asynchronously retrieves the session ID (SID) of the room.

        Returns:
            str: The session ID of the room.
        &#34;&#34;&#34;
        if self._info.sid:
            return self._info.sid

        return await self._first_sid_future

    @property
    def local_participant(self) -&gt; LocalParticipant:
        &#34;&#34;&#34;Gets the local participant in the room.

        Returns:
            LocalParticipant: The local participant in the room.
        &#34;&#34;&#34;
        if self._local_participant is None:
            raise Exception(&#34;cannot access local participant before connecting&#34;)

        return self._local_participant

    @property
    def connection_state(self) -&gt; ConnectionState.ValueType:
        &#34;&#34;&#34;Gets the connection state of the room.

        Returns:
            ConnectionState: The connection state of the room.
        &#34;&#34;&#34;
        return self._connection_state

    @property
    def remote_participants(self) -&gt; Mapping[str, RemoteParticipant]:
        &#34;&#34;&#34;Gets the remote participants in the room.

        Returns:
            dict[str, RemoteParticipant]: A dictionary of remote participants indexed by their
            identity.
        &#34;&#34;&#34;
        return self._remote_participants

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Gets the name of the room.

        Returns:
            str: The name of the room.
        &#34;&#34;&#34;
        return self._info.name

    @property
    def metadata(self) -&gt; str:
        &#34;&#34;&#34;Gets the metadata associated with the room.

        Returns:
            str: The metadata of the room.
        &#34;&#34;&#34;
        return self._info.metadata

    @property
    def e2ee_manager(self) -&gt; E2EEManager:
        &#34;&#34;&#34;Gets the end-to-end encryption (E2EE) manager for the room.

        Returns:
            E2EEManager: The E2EE manager instance.
        &#34;&#34;&#34;
        return self._e2ee_manager

    def isconnected(self) -&gt; bool:
        &#34;&#34;&#34;Checks if the room is currently connected.

        Returns:
            bool: True if connected, False otherwise.
        &#34;&#34;&#34;
        return (
            self._ffi_handle is not None
            and self._connection_state != ConnectionState.CONN_DISCONNECTED
        )

    def on(self, event: EventTypes, callback: Optional[Callable] = None) -&gt; Callable:
        &#34;&#34;&#34;Registers an event handler for a specific event type.

        Parameters:
            event (EventTypes): The name of the event to listen for.
            callback (Callable): The function to call when the event occurs.

        Returns:
            Callable: The registered callback function.

        Available events:
            - **&#34;participant_connected&#34;**: Called when a new participant joins the room.
                - Arguments: `participant` (RemoteParticipant)
            - **&#34;participant_disconnected&#34;**: Called when a participant leaves the room.
                - Arguments: `participant` (RemoteParticipant)
            - **&#34;local_track_published&#34;**: Called when a local track is published.
                - Arguments: `publication` (LocalTrackPublication), `track` (Track)
            - **&#34;local_track_unpublished&#34;**: Called when a local track is unpublished.
                - Arguments: `publication` (LocalTrackPublication)
            - **&#34;local_track_subscribed&#34;**: Called when a local track is subscribed.
                - Arguments: `track` (Track)
            - **&#34;track_published&#34;**: Called when a remote participant publishes a track.
                - Arguments: `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
            - **&#34;track_unpublished&#34;**: Called when a remote participant unpublishes a track.
                - Arguments: `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
            - **&#34;track_subscribed&#34;**: Called when a track is subscribed.
                - Arguments: `track` (Track), `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
            - **&#34;track_unsubscribed&#34;**: Called when a track is unsubscribed.
                - Arguments: `track` (Track), `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
            - **&#34;track_subscription_failed&#34;**: Called when a track subscription fails.
                - Arguments: `participant` (RemoteParticipant), `track_sid` (str), `error` (str)
            - **&#34;track_muted&#34;**: Called when a track is muted.
                - Arguments: `participant` (Participant), `publication` (TrackPublication)
            - **&#34;track_unmuted&#34;**: Called when a track is unmuted.
                - Arguments: `participant` (Participant), `publication` (TrackPublication)
            - **&#34;active_speakers_changed&#34;**: Called when the list of active speakers changes.
                - Arguments: `speakers` (list[Participant])
            - **&#34;room_metadata_changed&#34;**: Called when the room&#39;s metadata is updated.
                - Arguments: `old_metadata` (str), `new_metadata` (str)
            - **&#34;participant_metadata_changed&#34;**: Called when a participant&#39;s metadata is updated.
                - Arguments: `participant` (Participant), `old_metadata` (str), `new_metadata` (str)
            - **&#34;participant_name_changed&#34;**: Called when a participant&#39;s name is changed.
                - Arguments: `participant` (Participant), `old_name` (str), `new_name` (str)
            - **&#34;participant_attributes_changed&#34;**: Called when a participant&#39;s attributes change.
                - Arguments: `changed_attributes` (dict), `participant` (Participant)
            - **&#34;connection_quality_changed&#34;**: Called when a participant&#39;s connection quality changes.
                - Arguments: `participant` (Participant), `quality` (ConnectionQuality)
            - **&#34;transcription_received&#34;**: Called when a transcription is received.
                - Arguments: `segments` (list[TranscriptionSegment]), `participant` (Participant), `publication` (TrackPublication)
            - **&#34;data_received&#34;**: Called when data is received.
                - Arguments: `data_packet` (DataPacket)
            - **&#34;sip_dtmf_received&#34;**: Called when a SIP DTMF signal is received.
                - Arguments: `sip_dtmf` (SipDTMF)
            - **&#34;e2ee_state_changed&#34;**: Called when a participant&#39;s E2EE state changes.
                - Arguments: `participant` (Participant), `state` (EncryptionState)
            - **&#34;connection_state_changed&#34;**: Called when the room&#39;s connection state changes.
                - Arguments: `connection_state` (ConnectionState)
            - **&#34;connected&#34;**: Called when the room is successfully connected.
                - Arguments: None
            - **&#34;disconnected&#34;**: Called when the room is disconnected.
                - Arguments: `reason` (DisconnectReason)
            - **&#34;reconnecting&#34;**: Called when the room is attempting to reconnect.
                - Arguments: None
            - **&#34;reconnected&#34;**: Called when the room has successfully reconnected.
                - Arguments: None

        Example:
            ```python
            def on_participant_connected(participant):
                print(f&#34;Participant connected: {participant.identity}&#34;)

            room.on(&#34;participant_connected&#34;, on_participant_connected)
            ```
        &#34;&#34;&#34;
        return super().on(event, callback)

    async def connect(self, url: str, token: str, options: RoomOptions = RoomOptions()) -&gt; None:
        &#34;&#34;&#34;Connects to a LiveKit room using the specified URL and token.

        Parameters:
            url (str): The WebSocket URL of the LiveKit server to connect to.
            token (str): The access token for authentication and authorization.
            options (RoomOptions, optional): Additional options for the room connection.

        Raises:
            ConnectError: If the connection fails.

        Example:
            ```python
            room = Room()

            # Listen for events before connecting to the room
            @room.on(&#34;participant_connected&#34;)
            def on_participant_connected(participant):
                print(f&#34;Participant connected: {participant.identity}&#34;)

            await room.connect(&#34;ws://localhost:7880&#34;, &#34;your_token&#34;)
            ```
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.connect.url = url
        req.connect.token = token

        # options
        req.connect.options.auto_subscribe = options.auto_subscribe
        req.connect.options.dynacast = options.dynacast

        if options.e2ee:
            req.connect.options.e2ee.encryption_type = options.e2ee.encryption_type
            req.connect.options.e2ee.key_provider_options.shared_key = (
                options.e2ee.key_provider_options.shared_key  # type: ignore
            )
            req.connect.options.e2ee.key_provider_options.ratchet_salt = (
                options.e2ee.key_provider_options.ratchet_salt
            )
            req.connect.options.e2ee.key_provider_options.failure_tolerance = (
                options.e2ee.key_provider_options.failure_tolerance
            )
            req.connect.options.e2ee.key_provider_options.ratchet_window_size = (
                options.e2ee.key_provider_options.ratchet_window_size
            )

        if options.rtc_config:
            req.connect.options.rtc_config.ice_transport_type = (
                options.rtc_config.ice_transport_type
            )  # type: ignore
            req.connect.options.rtc_config.continual_gathering_policy = (
                options.rtc_config.continual_gathering_policy
            )  # type: ignore
            req.connect.options.rtc_config.ice_servers.extend(options.rtc_config.ice_servers)

        # subscribe before connecting so we don&#39;t miss any events
        self._ffi_queue = FfiClient.instance.queue.subscribe(self._loop)

        queue = FfiClient.instance.queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            cb: proto_ffi.FfiEvent = await queue.wait_for(
                lambda e: e.connect.async_id == resp.connect.async_id
            )
        finally:
            FfiClient.instance.queue.unsubscribe(queue)

        if cb.connect.error:
            FfiClient.instance.queue.unsubscribe(self._ffi_queue)
            raise ConnectError(cb.connect.error)

        self._ffi_handle = FfiHandle(cb.connect.result.room.handle.id)

        self._e2ee_manager = E2EEManager(self._ffi_handle.handle, options.e2ee)

        self._info = cb.connect.result.room.info
        self._connection_state = ConnectionState.CONN_CONNECTED

        self._local_participant = LocalParticipant(
            self._room_queue, cb.connect.result.local_participant
        )

        for pt in cb.connect.result.participants:
            rp = self._create_remote_participant(pt.participant)

            # add the initial remote participant tracks
            for owned_publication_info in pt.publications:
                publication = RemoteTrackPublication(owned_publication_info)
                rp._track_publications[publication.sid] = publication

        # start listening to room events
        self._task = self._loop.create_task(self._listen_task())

    def register_byte_stream_handler(self, topic: str, handler: ByteStreamHandler):
        existing_handler = self._byte_stream_handlers.get(topic)
        if existing_handler is None:
            self._byte_stream_handlers[topic] = handler
        else:
            raise ValueError(&#34;byte stream handler for topic &#39;%s&#39; already set&#34; % topic)

    def unregister_byte_stream_handler(self, topic: str):
        if self._byte_stream_handlers.get(topic):
            self._byte_stream_handlers.pop(topic)

    def register_text_stream_handler(self, topic: str, handler: TextStreamHandler):
        existing_handler = self._text_stream_handlers.get(topic)
        if existing_handler is None:
            self._text_stream_handlers[topic] = handler
        else:
            raise ValueError(&#34;text stream handler for topic &#39;%s&#39; already set&#34; % topic)

    def unregister_text_stream_handler(self, topic: str):
        if self._text_stream_handlers.get(topic):
            self._text_stream_handlers.pop(topic)

    async def disconnect(self) -&gt; None:
        &#34;&#34;&#34;Disconnects from the room.&#34;&#34;&#34;
        if not self.isconnected():
            return

        await self._drain_rpc_invocation_tasks()
        await self._drain_data_stream_tasks()

        req = proto_ffi.FfiRequest()
        req.disconnect.room_handle = self._ffi_handle.handle  # type: ignore
        queue = FfiClient.instance.queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            await queue.wait_for(lambda e: e.disconnect.async_id == resp.disconnect.async_id)
        finally:
            FfiClient.instance.queue.unsubscribe(queue)
        await self._task
        FfiClient.instance.queue.unsubscribe(self._ffi_queue)

    async def _listen_task(self) -&gt; None:
        # listen to incoming room events
        while True:
            event = await self._ffi_queue.get()
            if event.WhichOneof(&#34;message&#34;) == &#34;rpc_method_invocation&#34;:
                self._on_rpc_method_invocation(event.rpc_method_invocation)
            elif event.room_event.room_handle == self._ffi_handle.handle:  # type: ignore
                if event.room_event.HasField(&#34;eos&#34;):
                    break

                try:
                    self._on_room_event(event.room_event)
                except Exception:
                    logging.exception(
                        &#34;error running user callback for %s: %s&#34;,
                        event.room_event.WhichOneof(&#34;message&#34;),
                        event.room_event,
                    )

            # wait for the subscribers to process the event
            # before processing the next one
            self._room_queue.put_nowait(event)
            await self._room_queue.join()

        # Clean up any pending RPC invocation tasks
        await self._drain_rpc_invocation_tasks()
        await self._drain_data_stream_tasks()

    def _on_rpc_method_invocation(self, rpc_invocation: RpcMethodInvocationEvent):
        if self._local_participant is None:
            return

        if rpc_invocation.local_participant_handle == self._local_participant._ffi_handle.handle:
            task = self._loop.create_task(
                self._local_participant._handle_rpc_method_invocation(
                    rpc_invocation.invocation_id,
                    rpc_invocation.method,
                    rpc_invocation.request_id,
                    rpc_invocation.caller_identity,
                    rpc_invocation.payload,
                    rpc_invocation.response_timeout_ms / 1000.0,
                )
            )
            self._rpc_invocation_tasks.add(task)
            task.add_done_callback(self._rpc_invocation_tasks.discard)

    def _on_room_event(self, event: proto_room.RoomEvent):
        which = event.WhichOneof(&#34;message&#34;)
        if which == &#34;participant_connected&#34;:
            rparticipant = self._create_remote_participant(event.participant_connected.info)
            self.emit(&#34;participant_connected&#34;, rparticipant)
        elif which == &#34;participant_disconnected&#34;:
            identity = event.participant_disconnected.participant_identity
            rparticipant = self._remote_participants.pop(identity)
            rparticipant._info.disconnect_reason = event.participant_disconnected.disconnect_reason
            self.emit(&#34;participant_disconnected&#34;, rparticipant)
        elif which == &#34;local_track_published&#34;:
            sid = event.local_track_published.track_sid
            lpublication = self.local_participant.track_publications[sid]
            ltrack = lpublication.track
            self.emit(&#34;local_track_published&#34;, lpublication, ltrack)
        elif which == &#34;local_track_unpublished&#34;:
            sid = event.local_track_unpublished.publication_sid
            lpublication = self.local_participant.track_publications[sid]
            self.emit(&#34;local_track_unpublished&#34;, lpublication)
        elif which == &#34;local_track_subscribed&#34;:
            sid = event.local_track_subscribed.track_sid
            lpublication = self.local_participant.track_publications[sid]
            lpublication._first_subscription.set_result(None)
            self.emit(&#34;local_track_subscribed&#34;, lpublication.track)
        elif which == &#34;track_published&#34;:
            rparticipant = self._remote_participants[event.track_published.participant_identity]
            rpublication = RemoteTrackPublication(event.track_published.publication)
            rparticipant._track_publications[rpublication.sid] = rpublication
            self.emit(&#34;track_published&#34;, rpublication, rparticipant)
        elif which == &#34;track_unpublished&#34;:
            rparticipant = self._remote_participants[event.track_unpublished.participant_identity]
            rpublication = rparticipant._track_publications.pop(
                event.track_unpublished.publication_sid
            )
            self.emit(&#34;track_unpublished&#34;, rpublication, rparticipant)
        elif which == &#34;track_subscribed&#34;:
            owned_track_info = event.track_subscribed.track
            track_info = owned_track_info.info
            rparticipant = self._remote_participants[event.track_subscribed.participant_identity]
            rpublication = rparticipant.track_publications[track_info.sid]
            rpublication._subscribed = True
            if track_info.kind == TrackKind.KIND_VIDEO:
                remote_video_track = RemoteVideoTrack(owned_track_info)
                rpublication._track = remote_video_track
                self.emit(&#34;track_subscribed&#34;, remote_video_track, rpublication, rparticipant)
            elif track_info.kind == TrackKind.KIND_AUDIO:
                remote_audio_track = RemoteAudioTrack(owned_track_info)
                rpublication._track = remote_audio_track
                self.emit(&#34;track_subscribed&#34;, remote_audio_track, rpublication, rparticipant)
        elif which == &#34;track_unsubscribed&#34;:
            identity = event.track_unsubscribed.participant_identity
            rparticipant = self._remote_participants[identity]
            rpublication = rparticipant.track_publications[event.track_unsubscribed.track_sid]
            rtrack = rpublication.track
            rpublication._track = None
            rpublication._subscribed = False
            self.emit(&#34;track_unsubscribed&#34;, rtrack, rpublication, rparticipant)
        elif which == &#34;track_subscription_failed&#34;:
            identity = event.track_subscription_failed.participant_identity
            rparticipant = self._remote_participants[identity]
            error = event.track_subscription_failed.error
            self.emit(
                &#34;track_subscription_failed&#34;,
                rparticipant,
                event.track_subscription_failed.track_sid,
                error,
            )
        elif which == &#34;track_muted&#34;:
            identity = event.track_muted.participant_identity
            # TODO: pass participant identity
            participant = self._retrieve_participant(identity)
            assert isinstance(participant, Participant)
            publication = participant.track_publications[event.track_muted.track_sid]
            publication._info.muted = True
            if publication.track:
                publication.track._info.muted = True

            self.emit(&#34;track_muted&#34;, participant, publication)
        elif which == &#34;track_unmuted&#34;:
            identity = event.track_unmuted.participant_identity
            # TODO: pass participant identity
            participant = self._retrieve_participant(identity)
            assert isinstance(participant, Participant)
            publication = participant.track_publications[event.track_unmuted.track_sid]
            publication._info.muted = False
            if publication.track:
                publication.track._info.muted = False

            self.emit(&#34;track_unmuted&#34;, participant, publication)
        elif which == &#34;active_speakers_changed&#34;:
            speakers: list[Participant] = []
            # TODO: pass participant identity
            for identity in event.active_speakers_changed.participant_identities:
                participant = self._retrieve_participant(identity)
                assert isinstance(participant, Participant)
                speakers.append(participant)

            self.emit(&#34;active_speakers_changed&#34;, speakers)
        elif which == &#34;room_metadata_changed&#34;:
            old_metadata = self.metadata
            self._info.metadata = event.room_metadata_changed.metadata
            self.emit(&#34;room_metadata_changed&#34;, old_metadata, self.metadata)
        elif which == &#34;room_sid_changed&#34;:
            if not self._info.sid:
                self._first_sid_future.set_result(event.room_sid_changed.sid)
            self._info.sid = event.room_sid_changed.sid
            # This is an internal event, not exposed to users
        elif which == &#34;participant_metadata_changed&#34;:
            identity = event.participant_metadata_changed.participant_identity
            # TODO: pass participant identity
            participant = self._retrieve_participant(identity)
            assert isinstance(participant, Participant)
            old_metadata = participant.metadata
            participant._info.metadata = event.participant_metadata_changed.metadata
            self.emit(
                &#34;participant_metadata_changed&#34;,
                participant,
                old_metadata,
                participant.metadata,
            )
        elif which == &#34;participant_name_changed&#34;:
            identity = event.participant_name_changed.participant_identity
            participant = self._retrieve_participant(identity)
            assert isinstance(participant, Participant)
            old_name = participant.name
            participant._info.name = event.participant_name_changed.name
            self.emit(&#34;participant_name_changed&#34;, participant, old_name, participant.name)
        elif which == &#34;participant_attributes_changed&#34;:
            identity = event.participant_attributes_changed.participant_identity
            attributes = event.participant_attributes_changed.attributes
            changed_attributes = dict(
                (entry.key, entry.value)
                for entry in event.participant_attributes_changed.changed_attributes
            )
            participant = self._retrieve_participant(identity)
            assert isinstance(participant, Participant)
            participant._info.attributes.clear()
            participant._info.attributes.update((entry.key, entry.value) for entry in attributes)
            self.emit(
                &#34;participant_attributes_changed&#34;,
                changed_attributes,
                participant,
            )
        elif which == &#34;connection_quality_changed&#34;:
            identity = event.connection_quality_changed.participant_identity
            # TODO: pass participant identity
            participant = self._retrieve_participant(identity)
            self.emit(
                &#34;connection_quality_changed&#34;,
                participant,
                event.connection_quality_changed.quality,
            )
        elif which == &#34;transcription_received&#34;:
            transcription = event.transcription_received
            segments = [
                TranscriptionSegment(
                    id=s.id,
                    text=s.text,
                    final=s.final,
                    start_time=s.start_time,
                    end_time=s.end_time,
                    language=s.language,
                )
                for s in transcription.segments
            ]
            part = self._retrieve_participant(transcription.participant_identity)
            pub: TrackPublication | None = None
            if part:
                pub = part.track_publications.get(transcription.track_sid)
            self.emit(&#34;transcription_received&#34;, segments, part, pub)
        elif which == &#34;data_packet_received&#34;:
            packet = event.data_packet_received
            which_val = packet.WhichOneof(&#34;value&#34;)
            if which_val == &#34;user&#34;:
                owned_buffer_info = packet.user.data
                buffer_info = owned_buffer_info.data
                native_data = ctypes.cast(
                    buffer_info.data_ptr,
                    ctypes.POINTER(ctypes.c_byte * buffer_info.data_len),
                ).contents

                data = bytes(native_data)
                FfiHandle(owned_buffer_info.handle.id)
                rparticipant = cast(
                    RemoteParticipant,
                    self._retrieve_remote_participant(packet.participant_identity),
                )
                self.emit(
                    &#34;data_received&#34;,
                    DataPacket(
                        data=data,
                        kind=packet.kind,
                        participant=rparticipant,
                        topic=packet.user.topic,
                    ),
                )
            elif which_val == &#34;sip_dtmf&#34;:
                rparticipant = cast(
                    RemoteParticipant,
                    self._retrieve_remote_participant(packet.participant_identity),
                )
                self.emit(
                    &#34;sip_dtmf_received&#34;,
                    SipDTMF(
                        code=packet.sip_dtmf.code,
                        digit=packet.sip_dtmf.digit,
                        participant=rparticipant,
                    ),
                )
        elif which == &#34;e2ee_state_changed&#34;:
            identity = event.e2ee_state_changed.participant_identity
            e2ee_state = event.e2ee_state_changed.state
            # TODO: pass participant identity
            self.emit(&#34;e2ee_state_changed&#34;, self._retrieve_participant(identity), e2ee_state)
        elif which == &#34;connection_state_changed&#34;:
            connection_state = event.connection_state_changed.state
            self._connection_state = connection_state
            self.emit(&#34;connection_state_changed&#34;, connection_state)
        elif which == &#34;connected&#34;:
            self.emit(&#34;connected&#34;)
        elif which == &#34;disconnected&#34;:
            self.emit(&#34;disconnected&#34;, event.disconnected.reason)
        elif which == &#34;reconnecting&#34;:
            self.emit(&#34;reconnecting&#34;)
        elif which == &#34;reconnected&#34;:
            self.emit(&#34;reconnected&#34;)
        elif which == &#34;stream_header_received&#34;:
            self._handle_stream_header(
                event.stream_header_received.header,
                event.stream_header_received.participant_identity,
            )
        elif which == &#34;stream_chunk_received&#34;:
            task = asyncio.create_task(self._handle_stream_chunk(event.stream_chunk_received.chunk))
            self._data_stream_tasks.add(task)
            task.add_done_callback(self._data_stream_tasks.discard)

        elif which == &#34;stream_trailer_received&#34;:
            task = asyncio.create_task(
                self._handle_stream_trailer(event.stream_trailer_received.trailer)
            )
            self._data_stream_tasks.add(task)
            task.add_done_callback(self._data_stream_tasks.discard)

    def _handle_stream_header(
        self, header: proto_room.DataStream.Header, participant_identity: str
    ):
        stream_type = header.WhichOneof(&#34;content_header&#34;)
        if stream_type == &#34;text_header&#34;:
            text_stream_handler = self._text_stream_handlers.get(header.topic)
            if text_stream_handler is None:
                logging.info(
                    &#34;ignoring text stream with topic &#39;%s&#39;, no callback attached&#34;,
                    header.topic,
                )
                return

            text_reader = TextStreamReader(header)
            self._text_stream_readers[header.stream_id] = text_reader
            text_stream_handler(text_reader, participant_identity)
        elif stream_type == &#34;byte_header&#34;:
            byte_stream_handler = self._byte_stream_handlers.get(header.topic)
            if byte_stream_handler is None:
                logging.info(
                    &#34;ignoring byte stream with topic &#39;%s&#39;, no callback attached&#34;,
                    header.topic,
                )
                return

            byte_reader = ByteStreamReader(header)
            self._byte_stream_readers[header.stream_id] = byte_reader
            byte_stream_handler(byte_reader, participant_identity)
        else:
            logging.warning(&#34;received unknown header type, %s&#34;, stream_type)
        pass

    async def _handle_stream_chunk(self, chunk: proto_room.DataStream.Chunk):
        text_reader = self._text_stream_readers.get(chunk.stream_id)
        file_reader = self._byte_stream_readers.get(chunk.stream_id)

        if text_reader:
            await text_reader._on_chunk_update(chunk)
        elif file_reader:
            await file_reader._on_chunk_update(chunk)

    async def _handle_stream_trailer(self, trailer: proto_room.DataStream.Trailer):
        text_reader = self._text_stream_readers.get(trailer.stream_id)
        file_reader = self._byte_stream_readers.get(trailer.stream_id)

        if text_reader:
            await text_reader._on_stream_close(trailer)
            self._text_stream_readers.pop(trailer.stream_id)
        elif file_reader:
            await file_reader._on_stream_close(trailer)
            self._byte_stream_readers.pop(trailer.stream_id)

    async def _drain_rpc_invocation_tasks(self) -&gt; None:
        if self._rpc_invocation_tasks:
            for task in self._rpc_invocation_tasks:
                task.cancel()
            await asyncio.gather(*self._rpc_invocation_tasks, return_exceptions=True)

    async def _drain_data_stream_tasks(self) -&gt; None:
        if self._data_stream_tasks:
            for task in self._data_stream_tasks:
                task.cancel()
            await asyncio.gather(*self._data_stream_tasks, return_exceptions=True)

    def _retrieve_remote_participant(self, identity: str) -&gt; Optional[RemoteParticipant]:
        &#34;&#34;&#34;Retrieve a remote participant by identity&#34;&#34;&#34;
        return self._remote_participants.get(identity, None)

    def _retrieve_participant(self, identity: str) -&gt; Optional[Participant]:
        &#34;&#34;&#34;Retrieve a local or remote participant by identity&#34;&#34;&#34;
        if identity and identity == self.local_participant.identity:
            return self.local_participant

        return self._retrieve_remote_participant(identity)

    def _create_remote_participant(
        self, owned_info: proto_participant.OwnedParticipant
    ) -&gt; RemoteParticipant:
        if owned_info.info.identity in self._remote_participants:
            raise Exception(&#34;participant already exists&#34;)

        participant = RemoteParticipant(owned_info)
        self._remote_participants[participant.identity] = participant
        return participant

    def __repr__(self) -&gt; str:
        sid = &#34;unknown&#34;
        if self._first_sid_future.done():
            sid = self._first_sid_future.result()

        return f&#34;rtc.Room(sid={sid}, name={self.name}, metadata={self.metadata}, connection_state={ConnectionState.Name(self._connection_state)})&#34;</code></pre>
</details>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::</p>
<pre><code>class Mapping[KT, VT]:
    def __getitem__(self, key: KT) -&gt; VT:
        ...
    # Etc.
</code></pre>
<p>On older versions of Python, however, generic classes have to
explicitly inherit from Generic.</p>
<p>After a class has been declared to be generic, it can then be used as
follows::</p>
<pre><code>def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
    try:
        return mapping[key]
    except KeyError:
        return default
</code></pre>
<p>Initializes a new Room instance.</p>
<h2 id="parameters">Parameters</h2>
<p>loop (Optional[asyncio.AbstractEventLoop]): The event loop to use. If not provided, the default event loop is used.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.event_emitter.EventEmitter" href="event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a></li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.room.Room.connection_state"><code class="name">prop <span class="ident">connection_state</span> : ConnectionState.ValueType</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_state(self) -&gt; ConnectionState.ValueType:
    &#34;&#34;&#34;Gets the connection state of the room.

    Returns:
        ConnectionState: The connection state of the room.
    &#34;&#34;&#34;
    return self._connection_state</code></pre>
</details>
<div class="desc"><p>Gets the connection state of the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ConnectionState</code></dt>
<dd>The connection state of the room.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.room.Room.e2ee_manager"><code class="name">prop <span class="ident">e2ee_manager</span> : E2EEManager</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def e2ee_manager(self) -&gt; E2EEManager:
    &#34;&#34;&#34;Gets the end-to-end encryption (E2EE) manager for the room.

    Returns:
        E2EEManager: The E2EE manager instance.
    &#34;&#34;&#34;
    return self._e2ee_manager</code></pre>
</details>
<div class="desc"><p>Gets the end-to-end encryption (E2EE) manager for the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>E2EEManager</code></dt>
<dd>The E2EE manager instance.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.room.Room.local_participant"><code class="name">prop <span class="ident">local_participant</span> : LocalParticipant</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def local_participant(self) -&gt; LocalParticipant:
    &#34;&#34;&#34;Gets the local participant in the room.

    Returns:
        LocalParticipant: The local participant in the room.
    &#34;&#34;&#34;
    if self._local_participant is None:
        raise Exception(&#34;cannot access local participant before connecting&#34;)

    return self._local_participant</code></pre>
</details>
<div class="desc"><p>Gets the local participant in the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LocalParticipant</code></dt>
<dd>The local participant in the room.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.room.Room.metadata"><code class="name">prop <span class="ident">metadata</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self) -&gt; str:
    &#34;&#34;&#34;Gets the metadata associated with the room.

    Returns:
        str: The metadata of the room.
    &#34;&#34;&#34;
    return self._info.metadata</code></pre>
</details>
<div class="desc"><p>Gets the metadata associated with the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The metadata of the room.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.room.Room.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Gets the name of the room.

    Returns:
        str: The name of the room.
    &#34;&#34;&#34;
    return self._info.name</code></pre>
</details>
<div class="desc"><p>Gets the name of the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The name of the room.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.room.Room.remote_participants"><code class="name">prop <span class="ident">remote_participants</span> : Mapping[str, RemoteParticipant]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def remote_participants(self) -&gt; Mapping[str, RemoteParticipant]:
    &#34;&#34;&#34;Gets the remote participants in the room.

    Returns:
        dict[str, RemoteParticipant]: A dictionary of remote participants indexed by their
        identity.
    &#34;&#34;&#34;
    return self._remote_participants</code></pre>
</details>
<div class="desc"><p>Gets the remote participants in the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, RemoteParticipant]</code></dt>
<dd>A dictionary of remote participants indexed by their</dd>
</dl>
<p>identity.</p></div>
</dd>
<dt id="livekit.rtc.room.Room.sid"><code class="name">prop <span class="ident">sid</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
async def sid(self) -&gt; str:
    &#34;&#34;&#34;Asynchronously retrieves the session ID (SID) of the room.

    Returns:
        str: The session ID of the room.
    &#34;&#34;&#34;
    if self._info.sid:
        return self._info.sid

    return await self._first_sid_future</code></pre>
</details>
<div class="desc"><p>Asynchronously retrieves the session ID (SID) of the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The session ID of the room.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.room.Room.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self,<br>url: str,<br>token: str,<br>options: <a title="livekit.rtc.room.RoomOptions" href="#livekit.rtc.room.RoomOptions">RoomOptions</a> = RoomOptions(auto_subscribe=True, dynacast=False, e2ee=None, rtc_config=None)) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self, url: str, token: str, options: RoomOptions = RoomOptions()) -&gt; None:
    &#34;&#34;&#34;Connects to a LiveKit room using the specified URL and token.

    Parameters:
        url (str): The WebSocket URL of the LiveKit server to connect to.
        token (str): The access token for authentication and authorization.
        options (RoomOptions, optional): Additional options for the room connection.

    Raises:
        ConnectError: If the connection fails.

    Example:
        ```python
        room = Room()

        # Listen for events before connecting to the room
        @room.on(&#34;participant_connected&#34;)
        def on_participant_connected(participant):
            print(f&#34;Participant connected: {participant.identity}&#34;)

        await room.connect(&#34;ws://localhost:7880&#34;, &#34;your_token&#34;)
        ```
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.connect.url = url
    req.connect.token = token

    # options
    req.connect.options.auto_subscribe = options.auto_subscribe
    req.connect.options.dynacast = options.dynacast

    if options.e2ee:
        req.connect.options.e2ee.encryption_type = options.e2ee.encryption_type
        req.connect.options.e2ee.key_provider_options.shared_key = (
            options.e2ee.key_provider_options.shared_key  # type: ignore
        )
        req.connect.options.e2ee.key_provider_options.ratchet_salt = (
            options.e2ee.key_provider_options.ratchet_salt
        )
        req.connect.options.e2ee.key_provider_options.failure_tolerance = (
            options.e2ee.key_provider_options.failure_tolerance
        )
        req.connect.options.e2ee.key_provider_options.ratchet_window_size = (
            options.e2ee.key_provider_options.ratchet_window_size
        )

    if options.rtc_config:
        req.connect.options.rtc_config.ice_transport_type = (
            options.rtc_config.ice_transport_type
        )  # type: ignore
        req.connect.options.rtc_config.continual_gathering_policy = (
            options.rtc_config.continual_gathering_policy
        )  # type: ignore
        req.connect.options.rtc_config.ice_servers.extend(options.rtc_config.ice_servers)

    # subscribe before connecting so we don&#39;t miss any events
    self._ffi_queue = FfiClient.instance.queue.subscribe(self._loop)

    queue = FfiClient.instance.queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        cb: proto_ffi.FfiEvent = await queue.wait_for(
            lambda e: e.connect.async_id == resp.connect.async_id
        )
    finally:
        FfiClient.instance.queue.unsubscribe(queue)

    if cb.connect.error:
        FfiClient.instance.queue.unsubscribe(self._ffi_queue)
        raise ConnectError(cb.connect.error)

    self._ffi_handle = FfiHandle(cb.connect.result.room.handle.id)

    self._e2ee_manager = E2EEManager(self._ffi_handle.handle, options.e2ee)

    self._info = cb.connect.result.room.info
    self._connection_state = ConnectionState.CONN_CONNECTED

    self._local_participant = LocalParticipant(
        self._room_queue, cb.connect.result.local_participant
    )

    for pt in cb.connect.result.participants:
        rp = self._create_remote_participant(pt.participant)

        # add the initial remote participant tracks
        for owned_publication_info in pt.publications:
            publication = RemoteTrackPublication(owned_publication_info)
            rp._track_publications[publication.sid] = publication

    # start listening to room events
    self._task = self._loop.create_task(self._listen_task())</code></pre>
</details>
<div class="desc"><p>Connects to a LiveKit room using the specified URL and token.</p>
<h2 id="parameters">Parameters</h2>
<p>url (str): The WebSocket URL of the LiveKit server to connect to.
token (str): The access token for authentication and authorization.
options (RoomOptions, optional): Additional options for the room connection.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="livekit.rtc.room.ConnectError" href="#livekit.rtc.room.ConnectError">ConnectError</a></code></dt>
<dd>If the connection fails.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">room = Room()

# Listen for events before connecting to the room
@room.on(&quot;participant_connected&quot;)
def on_participant_connected(participant):
    print(f&quot;Participant connected: {participant.identity}&quot;)

await room.connect(&quot;ws://localhost:7880&quot;, &quot;your_token&quot;)
</code></pre></div>
</dd>
<dt id="livekit.rtc.room.Room.disconnect"><code class="name flex">
<span>async def <span class="ident">disconnect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disconnect(self) -&gt; None:
    &#34;&#34;&#34;Disconnects from the room.&#34;&#34;&#34;
    if not self.isconnected():
        return

    await self._drain_rpc_invocation_tasks()
    await self._drain_data_stream_tasks()

    req = proto_ffi.FfiRequest()
    req.disconnect.room_handle = self._ffi_handle.handle  # type: ignore
    queue = FfiClient.instance.queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        await queue.wait_for(lambda e: e.disconnect.async_id == resp.disconnect.async_id)
    finally:
        FfiClient.instance.queue.unsubscribe(queue)
    await self._task
    FfiClient.instance.queue.unsubscribe(self._ffi_queue)</code></pre>
</details>
<div class="desc"><p>Disconnects from the room.</p></div>
</dd>
<dt id="livekit.rtc.room.Room.isconnected"><code class="name flex">
<span>def <span class="ident">isconnected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isconnected(self) -&gt; bool:
    &#34;&#34;&#34;Checks if the room is currently connected.

    Returns:
        bool: True if connected, False otherwise.
    &#34;&#34;&#34;
    return (
        self._ffi_handle is not None
        and self._connection_state != ConnectionState.CONN_DISCONNECTED
    )</code></pre>
</details>
<div class="desc"><p>Checks if the room is currently connected.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if connected, False otherwise.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.room.Room.on"><code class="name flex">
<span>def <span class="ident">on</span></span>(<span>self, event: EventTypes, callback: Optional[Callable] = None) ‑> Callable</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on(self, event: EventTypes, callback: Optional[Callable] = None) -&gt; Callable:
    &#34;&#34;&#34;Registers an event handler for a specific event type.

    Parameters:
        event (EventTypes): The name of the event to listen for.
        callback (Callable): The function to call when the event occurs.

    Returns:
        Callable: The registered callback function.

    Available events:
        - **&#34;participant_connected&#34;**: Called when a new participant joins the room.
            - Arguments: `participant` (RemoteParticipant)
        - **&#34;participant_disconnected&#34;**: Called when a participant leaves the room.
            - Arguments: `participant` (RemoteParticipant)
        - **&#34;local_track_published&#34;**: Called when a local track is published.
            - Arguments: `publication` (LocalTrackPublication), `track` (Track)
        - **&#34;local_track_unpublished&#34;**: Called when a local track is unpublished.
            - Arguments: `publication` (LocalTrackPublication)
        - **&#34;local_track_subscribed&#34;**: Called when a local track is subscribed.
            - Arguments: `track` (Track)
        - **&#34;track_published&#34;**: Called when a remote participant publishes a track.
            - Arguments: `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
        - **&#34;track_unpublished&#34;**: Called when a remote participant unpublishes a track.
            - Arguments: `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
        - **&#34;track_subscribed&#34;**: Called when a track is subscribed.
            - Arguments: `track` (Track), `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
        - **&#34;track_unsubscribed&#34;**: Called when a track is unsubscribed.
            - Arguments: `track` (Track), `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
        - **&#34;track_subscription_failed&#34;**: Called when a track subscription fails.
            - Arguments: `participant` (RemoteParticipant), `track_sid` (str), `error` (str)
        - **&#34;track_muted&#34;**: Called when a track is muted.
            - Arguments: `participant` (Participant), `publication` (TrackPublication)
        - **&#34;track_unmuted&#34;**: Called when a track is unmuted.
            - Arguments: `participant` (Participant), `publication` (TrackPublication)
        - **&#34;active_speakers_changed&#34;**: Called when the list of active speakers changes.
            - Arguments: `speakers` (list[Participant])
        - **&#34;room_metadata_changed&#34;**: Called when the room&#39;s metadata is updated.
            - Arguments: `old_metadata` (str), `new_metadata` (str)
        - **&#34;participant_metadata_changed&#34;**: Called when a participant&#39;s metadata is updated.
            - Arguments: `participant` (Participant), `old_metadata` (str), `new_metadata` (str)
        - **&#34;participant_name_changed&#34;**: Called when a participant&#39;s name is changed.
            - Arguments: `participant` (Participant), `old_name` (str), `new_name` (str)
        - **&#34;participant_attributes_changed&#34;**: Called when a participant&#39;s attributes change.
            - Arguments: `changed_attributes` (dict), `participant` (Participant)
        - **&#34;connection_quality_changed&#34;**: Called when a participant&#39;s connection quality changes.
            - Arguments: `participant` (Participant), `quality` (ConnectionQuality)
        - **&#34;transcription_received&#34;**: Called when a transcription is received.
            - Arguments: `segments` (list[TranscriptionSegment]), `participant` (Participant), `publication` (TrackPublication)
        - **&#34;data_received&#34;**: Called when data is received.
            - Arguments: `data_packet` (DataPacket)
        - **&#34;sip_dtmf_received&#34;**: Called when a SIP DTMF signal is received.
            - Arguments: `sip_dtmf` (SipDTMF)
        - **&#34;e2ee_state_changed&#34;**: Called when a participant&#39;s E2EE state changes.
            - Arguments: `participant` (Participant), `state` (EncryptionState)
        - **&#34;connection_state_changed&#34;**: Called when the room&#39;s connection state changes.
            - Arguments: `connection_state` (ConnectionState)
        - **&#34;connected&#34;**: Called when the room is successfully connected.
            - Arguments: None
        - **&#34;disconnected&#34;**: Called when the room is disconnected.
            - Arguments: `reason` (DisconnectReason)
        - **&#34;reconnecting&#34;**: Called when the room is attempting to reconnect.
            - Arguments: None
        - **&#34;reconnected&#34;**: Called when the room has successfully reconnected.
            - Arguments: None

    Example:
        ```python
        def on_participant_connected(participant):
            print(f&#34;Participant connected: {participant.identity}&#34;)

        room.on(&#34;participant_connected&#34;, on_participant_connected)
        ```
    &#34;&#34;&#34;
    return super().on(event, callback)</code></pre>
</details>
<div class="desc"><p>Registers an event handler for a specific event type.</p>
<h2 id="parameters">Parameters</h2>
<p>event (EventTypes): The name of the event to listen for.
callback (Callable): The function to call when the event occurs.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable</code></dt>
<dd>The registered callback function.</dd>
</dl>
<p>Available events:
- <strong>"participant_connected"</strong>: Called when a new participant joins the room.
- Arguments: <code>participant</code> (RemoteParticipant)
- <strong>"participant_disconnected"</strong>: Called when a participant leaves the room.
- Arguments: <code>participant</code> (RemoteParticipant)
- <strong>"local_track_published"</strong>: Called when a local track is published.
- Arguments: <code>publication</code> (LocalTrackPublication), <code>track</code> (Track)
- <strong>"local_track_unpublished"</strong>: Called when a local track is unpublished.
- Arguments: <code>publication</code> (LocalTrackPublication)
- <strong>"local_track_subscribed"</strong>: Called when a local track is subscribed.
- Arguments: <code>track</code> (Track)
- <strong>"track_published"</strong>: Called when a remote participant publishes a track.
- Arguments: <code>publication</code> (RemoteTrackPublication), <code>participant</code> (RemoteParticipant)
- <strong>"track_unpublished"</strong>: Called when a remote participant unpublishes a track.
- Arguments: <code>publication</code> (RemoteTrackPublication), <code>participant</code> (RemoteParticipant)
- <strong>"track_subscribed"</strong>: Called when a track is subscribed.
- Arguments: <code>track</code> (Track), <code>publication</code> (RemoteTrackPublication), <code>participant</code> (RemoteParticipant)
- <strong>"track_unsubscribed"</strong>: Called when a track is unsubscribed.
- Arguments: <code>track</code> (Track), <code>publication</code> (RemoteTrackPublication), <code>participant</code> (RemoteParticipant)
- <strong>"track_subscription_failed"</strong>: Called when a track subscription fails.
- Arguments: <code>participant</code> (RemoteParticipant), <code>track_sid</code> (str), <code>error</code> (str)
- <strong>"track_muted"</strong>: Called when a track is muted.
- Arguments: <code>participant</code> (Participant), <code>publication</code> (TrackPublication)
- <strong>"track_unmuted"</strong>: Called when a track is unmuted.
- Arguments: <code>participant</code> (Participant), <code>publication</code> (TrackPublication)
- <strong>"active_speakers_changed"</strong>: Called when the list of active speakers changes.
- Arguments: <code>speakers</code> (list[Participant])
- <strong>"room_metadata_changed"</strong>: Called when the room's metadata is updated.
- Arguments: <code>old_metadata</code> (str), <code>new_metadata</code> (str)
- <strong>"participant_metadata_changed"</strong>: Called when a participant's metadata is updated.
- Arguments: <code>participant</code> (Participant), <code>old_metadata</code> (str), <code>new_metadata</code> (str)
- <strong>"participant_name_changed"</strong>: Called when a participant's name is changed.
- Arguments: <code>participant</code> (Participant), <code>old_name</code> (str), <code>new_name</code> (str)
- <strong>"participant_attributes_changed"</strong>: Called when a participant's attributes change.
- Arguments: <code>changed_attributes</code> (dict), <code>participant</code> (Participant)
- <strong>"connection_quality_changed"</strong>: Called when a participant's connection quality changes.
- Arguments: <code>participant</code> (Participant), <code>quality</code> (ConnectionQuality)
- <strong>"transcription_received"</strong>: Called when a transcription is received.
- Arguments: <code>segments</code> (list[TranscriptionSegment]), <code>participant</code> (Participant), <code>publication</code> (TrackPublication)
- <strong>"data_received"</strong>: Called when data is received.
- Arguments: <code>data_packet</code> (DataPacket)
- <strong>"sip_dtmf_received"</strong>: Called when a SIP DTMF signal is received.
- Arguments: <code>sip_dtmf</code> (SipDTMF)
- <strong>"e2ee_state_changed"</strong>: Called when a participant's E2EE state changes.
- Arguments: <code>participant</code> (Participant), <code>state</code> (EncryptionState)
- <strong>"connection_state_changed"</strong>: Called when the room's connection state changes.
- Arguments: <code>connection_state</code> (ConnectionState)
- <strong>"connected"</strong>: Called when the room is successfully connected.
- Arguments: None
- <strong>"disconnected"</strong>: Called when the room is disconnected.
- Arguments: <code>reason</code> (DisconnectReason)
- <strong>"reconnecting"</strong>: Called when the room is attempting to reconnect.
- Arguments: None
- <strong>"reconnected"</strong>: Called when the room has successfully reconnected.
- Arguments: None</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">def on_participant_connected(participant):
    print(f&quot;Participant connected: {participant.identity}&quot;)

room.on(&quot;participant_connected&quot;, on_participant_connected)
</code></pre></div>
</dd>
<dt id="livekit.rtc.room.Room.register_byte_stream_handler"><code class="name flex">
<span>def <span class="ident">register_byte_stream_handler</span></span>(<span>self, topic: str, handler: ByteStreamHandler)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_byte_stream_handler(self, topic: str, handler: ByteStreamHandler):
    existing_handler = self._byte_stream_handlers.get(topic)
    if existing_handler is None:
        self._byte_stream_handlers[topic] = handler
    else:
        raise ValueError(&#34;byte stream handler for topic &#39;%s&#39; already set&#34; % topic)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.room.Room.register_text_stream_handler"><code class="name flex">
<span>def <span class="ident">register_text_stream_handler</span></span>(<span>self, topic: str, handler: TextStreamHandler)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_text_stream_handler(self, topic: str, handler: TextStreamHandler):
    existing_handler = self._text_stream_handlers.get(topic)
    if existing_handler is None:
        self._text_stream_handlers[topic] = handler
    else:
        raise ValueError(&#34;text stream handler for topic &#39;%s&#39; already set&#34; % topic)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.room.Room.unregister_byte_stream_handler"><code class="name flex">
<span>def <span class="ident">unregister_byte_stream_handler</span></span>(<span>self, topic: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister_byte_stream_handler(self, topic: str):
    if self._byte_stream_handlers.get(topic):
        self._byte_stream_handlers.pop(topic)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.room.Room.unregister_text_stream_handler"><code class="name flex">
<span>def <span class="ident">unregister_text_stream_handler</span></span>(<span>self, topic: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister_text_stream_handler(self, topic: str):
    if self._text_stream_handlers.get(topic):
        self._text_stream_handlers.pop(topic)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livekit.rtc.event_emitter.EventEmitter" href="event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a></b></code>:
<ul class="hlist">
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.emit" href="event_emitter.html#livekit.rtc.event_emitter.EventEmitter.emit">emit</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.off" href="event_emitter.html#livekit.rtc.event_emitter.EventEmitter.off">off</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.once" href="event_emitter.html#livekit.rtc.event_emitter.EventEmitter.once">once</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livekit.rtc.room.RoomOptions"><code class="flex name class">
<span>class <span class="ident">RoomOptions</span></span>
<span>(</span><span>auto_subscribe: bool = True,<br>dynacast: bool = False,<br>e2ee: E2EEOptions | None = None,<br>rtc_config: <a title="livekit.rtc.room.RtcConfiguration" href="#livekit.rtc.room.RtcConfiguration">RtcConfiguration</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RoomOptions:
    auto_subscribe: bool = True
    &#34;&#34;&#34;Automatically subscribe to tracks when participants join.&#34;&#34;&#34;
    dynacast: bool = False
    e2ee: E2EEOptions | None = None
    &#34;&#34;&#34;Options for end-to-end encryption.&#34;&#34;&#34;
    rtc_config: RtcConfiguration | None = None
    &#34;&#34;&#34;WebRTC-related configuration.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>RoomOptions(auto_subscribe: 'bool' = True, dynacast: 'bool' = False, e2ee: 'E2EEOptions | None' = None, rtc_config: 'RtcConfiguration | None' = None)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.room.RoomOptions.auto_subscribe"><code class="name">var <span class="ident">auto_subscribe</span> : bool</code></dt>
<dd>
<div class="desc"><p>Automatically subscribe to tracks when participants join.</p></div>
</dd>
<dt id="livekit.rtc.room.RoomOptions.dynacast"><code class="name">var <span class="ident">dynacast</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.room.RoomOptions.e2ee"><code class="name">var <span class="ident">e2ee</span> : <a title="livekit.rtc.e2ee.E2EEOptions" href="e2ee.html#livekit.rtc.e2ee.E2EEOptions">E2EEOptions</a> | None</code></dt>
<dd>
<div class="desc"><p>Options for end-to-end encryption.</p></div>
</dd>
<dt id="livekit.rtc.room.RoomOptions.rtc_config"><code class="name">var <span class="ident">rtc_config</span> : <a title="livekit.rtc.room.RtcConfiguration" href="#livekit.rtc.room.RtcConfiguration">RtcConfiguration</a> | None</code></dt>
<dd>
<div class="desc"><p>WebRTC-related configuration.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.room.RpcMethodInvocationEvent"><code class="flex name class">
<span>class <span class="ident">RpcMethodInvocationEvent</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>google._upb._message.Message</li>
<li>google.protobuf.message.Message</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.rtc.room.RpcMethodInvocationEvent.DESCRIPTOR"><code class="name">var <span class="ident">DESCRIPTOR</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.room.RtcConfiguration"><code class="flex name class">
<span>class <span class="ident">RtcConfiguration</span></span>
<span>(</span><span>ice_transport_type: proto_room.IceTransportType.ValueType = 2,<br>continual_gathering_policy: proto_room.ContinualGatheringPolicy.ValueType = 1,<br>ice_servers: list[proto_room.IceServer] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RtcConfiguration:
    ice_transport_type: proto_room.IceTransportType.ValueType = (
        proto_room.IceTransportType.TRANSPORT_ALL
    )
    &#34;&#34;&#34;Specifies the type of ICE transport to be used (e.g., all, relay, etc.).&#34;&#34;&#34;
    continual_gathering_policy: proto_room.ContinualGatheringPolicy.ValueType = (
        proto_room.ContinualGatheringPolicy.GATHER_CONTINUALLY
    )
    &#34;&#34;&#34;Policy for continual gathering of ICE candidates.&#34;&#34;&#34;
    ice_servers: list[proto_room.IceServer] = field(default_factory=list)
    &#34;&#34;&#34;List of ICE servers for STUN/TURN. When empty, it uses the default ICE servers provided by
    the SFU.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>RtcConfiguration(ice_transport_type: 'proto_room.IceTransportType.ValueType' = 2, continual_gathering_policy: 'proto_room.ContinualGatheringPolicy.ValueType' = 1, ice_servers: 'list[proto_room.IceServer]' = <factory>)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.room.RtcConfiguration.continual_gathering_policy"><code class="name">var <span class="ident">continual_gathering_policy</span> : int</code></dt>
<dd>
<div class="desc"><p>Policy for continual gathering of ICE candidates.</p></div>
</dd>
<dt id="livekit.rtc.room.RtcConfiguration.ice_servers"><code class="name">var <span class="ident">ice_servers</span> : list[room_pb2.IceServer]</code></dt>
<dd>
<div class="desc"><p>List of ICE servers for STUN/TURN. When empty, it uses the default ICE servers provided by
the SFU.</p></div>
</dd>
<dt id="livekit.rtc.room.RtcConfiguration.ice_transport_type"><code class="name">var <span class="ident">ice_transport_type</span> : int</code></dt>
<dd>
<div class="desc"><p>Specifies the type of ICE transport to be used (e.g., all, relay, etc.).</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.room.SipDTMF"><code class="flex name class">
<span>class <span class="ident">SipDTMF</span></span>
<span>(</span><span>code: int, digit: str, participant: RemoteParticipant | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class SipDTMF:
    code: int
    &#34;&#34;&#34;DTMF code corresponding to the digit.&#34;&#34;&#34;
    digit: str
    &#34;&#34;&#34;DTMF digit sent.&#34;&#34;&#34;
    participant: RemoteParticipant | None = None
    &#34;&#34;&#34;Participant who sent the DTMF digit. None when sent by a server SDK.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>SipDTMF(code: 'int', digit: 'str', participant: 'RemoteParticipant | None' = None)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.room.SipDTMF.code"><code class="name">var <span class="ident">code</span> : int</code></dt>
<dd>
<div class="desc"><p>DTMF code corresponding to the digit.</p></div>
</dd>
<dt id="livekit.rtc.room.SipDTMF.digit"><code class="name">var <span class="ident">digit</span> : str</code></dt>
<dd>
<div class="desc"><p>DTMF digit sent.</p></div>
</dd>
<dt id="livekit.rtc.room.SipDTMF.participant"><code class="name">var <span class="ident">participant</span> : <a title="livekit.rtc.participant.RemoteParticipant" href="participant.html#livekit.rtc.participant.RemoteParticipant">RemoteParticipant</a> | None</code></dt>
<dd>
<div class="desc"><p>Participant who sent the DTMF digit. None when sent by a server SDK.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="livekit.rtc" href="index.html">livekit.rtc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="livekit.rtc.room.ConnectError" href="#livekit.rtc.room.ConnectError">ConnectError</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.rtc.room.DataPacket" href="#livekit.rtc.room.DataPacket">DataPacket</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.room.DataPacket.data" href="#livekit.rtc.room.DataPacket.data">data</a></code></li>
<li><code><a title="livekit.rtc.room.DataPacket.kind" href="#livekit.rtc.room.DataPacket.kind">kind</a></code></li>
<li><code><a title="livekit.rtc.room.DataPacket.participant" href="#livekit.rtc.room.DataPacket.participant">participant</a></code></li>
<li><code><a title="livekit.rtc.room.DataPacket.topic" href="#livekit.rtc.room.DataPacket.topic">topic</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.room.Room" href="#livekit.rtc.room.Room">Room</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.room.Room.connect" href="#livekit.rtc.room.Room.connect">connect</a></code></li>
<li><code><a title="livekit.rtc.room.Room.connection_state" href="#livekit.rtc.room.Room.connection_state">connection_state</a></code></li>
<li><code><a title="livekit.rtc.room.Room.disconnect" href="#livekit.rtc.room.Room.disconnect">disconnect</a></code></li>
<li><code><a title="livekit.rtc.room.Room.e2ee_manager" href="#livekit.rtc.room.Room.e2ee_manager">e2ee_manager</a></code></li>
<li><code><a title="livekit.rtc.room.Room.isconnected" href="#livekit.rtc.room.Room.isconnected">isconnected</a></code></li>
<li><code><a title="livekit.rtc.room.Room.local_participant" href="#livekit.rtc.room.Room.local_participant">local_participant</a></code></li>
<li><code><a title="livekit.rtc.room.Room.metadata" href="#livekit.rtc.room.Room.metadata">metadata</a></code></li>
<li><code><a title="livekit.rtc.room.Room.name" href="#livekit.rtc.room.Room.name">name</a></code></li>
<li><code><a title="livekit.rtc.room.Room.on" href="#livekit.rtc.room.Room.on">on</a></code></li>
<li><code><a title="livekit.rtc.room.Room.register_byte_stream_handler" href="#livekit.rtc.room.Room.register_byte_stream_handler">register_byte_stream_handler</a></code></li>
<li><code><a title="livekit.rtc.room.Room.register_text_stream_handler" href="#livekit.rtc.room.Room.register_text_stream_handler">register_text_stream_handler</a></code></li>
<li><code><a title="livekit.rtc.room.Room.remote_participants" href="#livekit.rtc.room.Room.remote_participants">remote_participants</a></code></li>
<li><code><a title="livekit.rtc.room.Room.sid" href="#livekit.rtc.room.Room.sid">sid</a></code></li>
<li><code><a title="livekit.rtc.room.Room.unregister_byte_stream_handler" href="#livekit.rtc.room.Room.unregister_byte_stream_handler">unregister_byte_stream_handler</a></code></li>
<li><code><a title="livekit.rtc.room.Room.unregister_text_stream_handler" href="#livekit.rtc.room.Room.unregister_text_stream_handler">unregister_text_stream_handler</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.room.RoomOptions" href="#livekit.rtc.room.RoomOptions">RoomOptions</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.room.RoomOptions.auto_subscribe" href="#livekit.rtc.room.RoomOptions.auto_subscribe">auto_subscribe</a></code></li>
<li><code><a title="livekit.rtc.room.RoomOptions.dynacast" href="#livekit.rtc.room.RoomOptions.dynacast">dynacast</a></code></li>
<li><code><a title="livekit.rtc.room.RoomOptions.e2ee" href="#livekit.rtc.room.RoomOptions.e2ee">e2ee</a></code></li>
<li><code><a title="livekit.rtc.room.RoomOptions.rtc_config" href="#livekit.rtc.room.RoomOptions.rtc_config">rtc_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.room.RpcMethodInvocationEvent" href="#livekit.rtc.room.RpcMethodInvocationEvent">RpcMethodInvocationEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.room.RpcMethodInvocationEvent.DESCRIPTOR" href="#livekit.rtc.room.RpcMethodInvocationEvent.DESCRIPTOR">DESCRIPTOR</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.room.RtcConfiguration" href="#livekit.rtc.room.RtcConfiguration">RtcConfiguration</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.room.RtcConfiguration.continual_gathering_policy" href="#livekit.rtc.room.RtcConfiguration.continual_gathering_policy">continual_gathering_policy</a></code></li>
<li><code><a title="livekit.rtc.room.RtcConfiguration.ice_servers" href="#livekit.rtc.room.RtcConfiguration.ice_servers">ice_servers</a></code></li>
<li><code><a title="livekit.rtc.room.RtcConfiguration.ice_transport_type" href="#livekit.rtc.room.RtcConfiguration.ice_transport_type">ice_transport_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.room.SipDTMF" href="#livekit.rtc.room.SipDTMF">SipDTMF</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.room.SipDTMF.code" href="#livekit.rtc.room.SipDTMF.code">code</a></code></li>
<li><code><a title="livekit.rtc.room.SipDTMF.digit" href="#livekit.rtc.room.SipDTMF.digit">digit</a></code></li>
<li><code><a title="livekit.rtc.room.SipDTMF.participant" href="#livekit.rtc.room.SipDTMF.participant">participant</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
