<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>livekit.rtc.audio_resampler API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>livekit.rtc.audio_resampler</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="livekit.rtc.audio_resampler.AudioResampler"><code class="flex name class">
<span>class <span class="ident">AudioResampler</span></span>
<span>(</span><span>input_rate: int,<br>output_rate: int,<br>*,<br>num_channels: int = 1,<br>quality: <a title="livekit.rtc.audio_resampler.AudioResamplerQuality" href="#livekit.rtc.audio_resampler.AudioResamplerQuality">AudioResamplerQuality</a> = AudioResamplerQuality.MEDIUM)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioResampler:
    &#34;&#34;&#34;
    A class for resampling audio data from one sample rate to another.

    `AudioResampler` provides functionality to resample audio data from an input sample rate to an output
    sample rate using the Sox resampling library. It supports multiple channels and configurable resampling quality.
    &#34;&#34;&#34;

    def __init__(
        self,
        input_rate: int,
        output_rate: int,
        *,
        num_channels: int = 1,
        quality: AudioResamplerQuality = AudioResamplerQuality.MEDIUM,
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize an `AudioResampler` instance for resampling audio data.

        Args:
            input_rate (int): The sample rate of the input audio data (in Hz).
            output_rate (int): The desired sample rate of the output audio data (in Hz).
            num_channels (int, optional): The number of audio channels (e.g., 1 for mono, 2 for stereo). Defaults to 1.
            quality (AudioResamplerQuality, optional): The quality setting for the resampler. Can be one of the
                `AudioResamplerQuality` enum values: `QUICK`, `LOW`, `MEDIUM`, `HIGH`, `VERY_HIGH`. Higher quality settings
                result in better audio quality but require more processing power. Defaults to `AudioResamplerQuality.MEDIUM`.

        Raises:
            Exception: If there is an error creating the resampler.
        &#34;&#34;&#34;
        self._input_rate = input_rate
        self._output_rate = output_rate
        self._num_channels = num_channels

        req = proto_ffi.FfiRequest()
        req.new_sox_resampler.input_rate = input_rate
        req.new_sox_resampler.output_rate = output_rate
        req.new_sox_resampler.num_channels = num_channels
        req.new_sox_resampler.quality_recipe = _to_proto_quality(quality)

        # not exposed for now
        req.new_sox_resampler.input_data_type = (
            proto_audio_frame.SoxResamplerDataType.SOXR_DATATYPE_INT16I
        )
        req.new_sox_resampler.output_data_type = (
            proto_audio_frame.SoxResamplerDataType.SOXR_DATATYPE_INT16I
        )
        req.new_sox_resampler.flags = 0  # default

        resp = FfiClient.instance.request(req)

        if resp.new_sox_resampler.error:
            raise Exception(resp.new_sox_resampler.error)

        self._ffi_handle = FfiHandle(resp.new_sox_resampler.resampler.handle.id)

    def push(self, data: bytearray | AudioFrame) -&gt; list[AudioFrame]:
        &#34;&#34;&#34;
        Push audio data into the resampler and retrieve any available resampled data.

        This method accepts audio data, resamples it according to the configured input and output rates,
        and returns any resampled data that is available after processing the input.

        Args:
            data (bytearray | AudioFrame): The audio data to resample. This can be a `bytearray` containing
                raw audio bytes in int16le format or an `AudioFrame` object.

        Returns:
            list[AudioFrame]: A list of `AudioFrame` objects containing the resampled audio data.
                The list may be empty if no output data is available yet.

        Raises:
            Exception: If there is an error during resampling.
        &#34;&#34;&#34;
        bdata = data if isinstance(data, bytearray) else data.data.cast(&#34;b&#34;)

        req = proto_ffi.FfiRequest()
        req.push_sox_resampler.resampler_handle = self._ffi_handle.handle
        req.push_sox_resampler.data_ptr = get_address(memoryview(bdata))
        req.push_sox_resampler.size = len(bdata)

        resp = FfiClient.instance.request(req)

        if resp.push_sox_resampler.error:
            raise Exception(resp.push_sox_resampler.error)

        if not resp.push_sox_resampler.output_ptr:
            return []

        cdata = (ctypes.c_int8 * resp.push_sox_resampler.size).from_address(
            resp.push_sox_resampler.output_ptr
        )
        output_data = bytearray(cdata)
        return [
            AudioFrame(
                output_data,
                self._output_rate,
                self._num_channels,
                len(output_data) // (self._num_channels * ctypes.sizeof(ctypes.c_int16)),
            )
        ]

    def flush(self) -&gt; list[AudioFrame]:
        &#34;&#34;&#34;
        Flush any remaining audio data through the resampler and retrieve the resampled data.

        This method should be called when no more input data will be provided to ensure that all internal
        buffers are processed and all resampled data is output.

        Returns:
            list[AudioFrame]: A list of `AudioFrame` objects containing the remaining resampled audio data after flushing.
                The list may be empty if no output data remains.

        Raises:
            Exception: If there is an error during flushing.
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.flush_sox_resampler.resampler_handle = self._ffi_handle.handle

        resp = FfiClient.instance.request(req)

        if not resp.flush_sox_resampler.output_ptr:
            return []

        cdata = (ctypes.c_int8 * resp.flush_sox_resampler.size).from_address(
            resp.flush_sox_resampler.output_ptr
        )
        output_data = bytearray(cdata)
        return [
            AudioFrame(
                output_data,
                self._output_rate,
                self._num_channels,
                len(output_data) // (self._num_channels * ctypes.sizeof(ctypes.c_int16)),
            )
        ]</code></pre>
</details>
<div class="desc"><p>A class for resampling audio data from one sample rate to another.</p>
<p><code><a title="livekit.rtc.audio_resampler.AudioResampler" href="#livekit.rtc.audio_resampler.AudioResampler">AudioResampler</a></code> provides functionality to resample audio data from an input sample rate to an output
sample rate using the Sox resampling library. It supports multiple channels and configurable resampling quality.</p>
<p>Initialize an <code><a title="livekit.rtc.audio_resampler.AudioResampler" href="#livekit.rtc.audio_resampler.AudioResampler">AudioResampler</a></code> instance for resampling audio data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>The sample rate of the input audio data (in Hz).</dd>
<dt><strong><code>output_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>The desired sample rate of the output audio data (in Hz).</dd>
<dt><strong><code>num_channels</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of audio channels (e.g., 1 for mono, 2 for stereo). Defaults to 1.</dd>
<dt><strong><code>quality</code></strong> :&ensp;<code><a title="livekit.rtc.audio_resampler.AudioResamplerQuality" href="#livekit.rtc.audio_resampler.AudioResamplerQuality">AudioResamplerQuality</a></code>, optional</dt>
<dd>The quality setting for the resampler. Can be one of the
<code><a title="livekit.rtc.audio_resampler.AudioResamplerQuality" href="#livekit.rtc.audio_resampler.AudioResamplerQuality">AudioResamplerQuality</a></code> enum values: <code>QUICK</code>, <code>LOW</code>, <code>MEDIUM</code>, <code>HIGH</code>, <code>VERY_HIGH</code>. Higher quality settings
result in better audio quality but require more processing power. Defaults to <code><a title="livekit.rtc.audio_resampler.AudioResamplerQuality.MEDIUM" href="#livekit.rtc.audio_resampler.AudioResamplerQuality.MEDIUM">AudioResamplerQuality.MEDIUM</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If there is an error creating the resampler.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.audio_resampler.AudioResampler.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self) ‑> list[<a title="livekit.rtc.audio_frame.AudioFrame" href="audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self) -&gt; list[AudioFrame]:
    &#34;&#34;&#34;
    Flush any remaining audio data through the resampler and retrieve the resampled data.

    This method should be called when no more input data will be provided to ensure that all internal
    buffers are processed and all resampled data is output.

    Returns:
        list[AudioFrame]: A list of `AudioFrame` objects containing the remaining resampled audio data after flushing.
            The list may be empty if no output data remains.

    Raises:
        Exception: If there is an error during flushing.
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.flush_sox_resampler.resampler_handle = self._ffi_handle.handle

    resp = FfiClient.instance.request(req)

    if not resp.flush_sox_resampler.output_ptr:
        return []

    cdata = (ctypes.c_int8 * resp.flush_sox_resampler.size).from_address(
        resp.flush_sox_resampler.output_ptr
    )
    output_data = bytearray(cdata)
    return [
        AudioFrame(
            output_data,
            self._output_rate,
            self._num_channels,
            len(output_data) // (self._num_channels * ctypes.sizeof(ctypes.c_int16)),
        )
    ]</code></pre>
</details>
<div class="desc"><p>Flush any remaining audio data through the resampler and retrieve the resampled data.</p>
<p>This method should be called when no more input data will be provided to ensure that all internal
buffers are processed and all resampled data is output.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[AudioFrame]</code></dt>
<dd>A list of <code>AudioFrame</code> objects containing the remaining resampled audio data after flushing.
The list may be empty if no output data remains.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If there is an error during flushing.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.audio_resampler.AudioResampler.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, data: bytearray | AudioFrame) ‑> list[<a title="livekit.rtc.audio_frame.AudioFrame" href="audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, data: bytearray | AudioFrame) -&gt; list[AudioFrame]:
    &#34;&#34;&#34;
    Push audio data into the resampler and retrieve any available resampled data.

    This method accepts audio data, resamples it according to the configured input and output rates,
    and returns any resampled data that is available after processing the input.

    Args:
        data (bytearray | AudioFrame): The audio data to resample. This can be a `bytearray` containing
            raw audio bytes in int16le format or an `AudioFrame` object.

    Returns:
        list[AudioFrame]: A list of `AudioFrame` objects containing the resampled audio data.
            The list may be empty if no output data is available yet.

    Raises:
        Exception: If there is an error during resampling.
    &#34;&#34;&#34;
    bdata = data if isinstance(data, bytearray) else data.data.cast(&#34;b&#34;)

    req = proto_ffi.FfiRequest()
    req.push_sox_resampler.resampler_handle = self._ffi_handle.handle
    req.push_sox_resampler.data_ptr = get_address(memoryview(bdata))
    req.push_sox_resampler.size = len(bdata)

    resp = FfiClient.instance.request(req)

    if resp.push_sox_resampler.error:
        raise Exception(resp.push_sox_resampler.error)

    if not resp.push_sox_resampler.output_ptr:
        return []

    cdata = (ctypes.c_int8 * resp.push_sox_resampler.size).from_address(
        resp.push_sox_resampler.output_ptr
    )
    output_data = bytearray(cdata)
    return [
        AudioFrame(
            output_data,
            self._output_rate,
            self._num_channels,
            len(output_data) // (self._num_channels * ctypes.sizeof(ctypes.c_int16)),
        )
    ]</code></pre>
</details>
<div class="desc"><p>Push audio data into the resampler and retrieve any available resampled data.</p>
<p>This method accepts audio data, resamples it according to the configured input and output rates,
and returns any resampled data that is available after processing the input.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytearray | AudioFrame</code></dt>
<dd>The audio data to resample. This can be a <code>bytearray</code> containing
raw audio bytes in int16le format or an <code>AudioFrame</code> object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[AudioFrame]</code></dt>
<dd>A list of <code>AudioFrame</code> objects containing the resampled audio data.
The list may be empty if no output data is available yet.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If there is an error during resampling.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.audio_resampler.AudioResamplerQuality"><code class="flex name class">
<span>class <span class="ident">AudioResamplerQuality</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@unique
class AudioResamplerQuality(str, Enum):
    QUICK = &#34;quick&#34;
    LOW = &#34;low&#34;
    MEDIUM = &#34;medium&#34;
    HIGH = &#34;high&#34;
    VERY_HIGH = &#34;very_high&#34;</code></pre>
</details>
<div class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to 'utf-8'.
errors defaults to 'strict'.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.rtc.audio_resampler.AudioResamplerQuality.HIGH"><code class="name">var <span class="ident">HIGH</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.audio_resampler.AudioResamplerQuality.LOW"><code class="name">var <span class="ident">LOW</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.audio_resampler.AudioResamplerQuality.MEDIUM"><code class="name">var <span class="ident">MEDIUM</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.audio_resampler.AudioResamplerQuality.QUICK"><code class="name">var <span class="ident">QUICK</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.audio_resampler.AudioResamplerQuality.VERY_HIGH"><code class="name">var <span class="ident">VERY_HIGH</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="livekit.rtc" href="index.html">livekit.rtc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="livekit.rtc.audio_resampler.AudioResampler" href="#livekit.rtc.audio_resampler.AudioResampler">AudioResampler</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.audio_resampler.AudioResampler.flush" href="#livekit.rtc.audio_resampler.AudioResampler.flush">flush</a></code></li>
<li><code><a title="livekit.rtc.audio_resampler.AudioResampler.push" href="#livekit.rtc.audio_resampler.AudioResampler.push">push</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.audio_resampler.AudioResamplerQuality" href="#livekit.rtc.audio_resampler.AudioResamplerQuality">AudioResamplerQuality</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.audio_resampler.AudioResamplerQuality.HIGH" href="#livekit.rtc.audio_resampler.AudioResamplerQuality.HIGH">HIGH</a></code></li>
<li><code><a title="livekit.rtc.audio_resampler.AudioResamplerQuality.LOW" href="#livekit.rtc.audio_resampler.AudioResamplerQuality.LOW">LOW</a></code></li>
<li><code><a title="livekit.rtc.audio_resampler.AudioResamplerQuality.MEDIUM" href="#livekit.rtc.audio_resampler.AudioResamplerQuality.MEDIUM">MEDIUM</a></code></li>
<li><code><a title="livekit.rtc.audio_resampler.AudioResamplerQuality.QUICK" href="#livekit.rtc.audio_resampler.AudioResamplerQuality.QUICK">QUICK</a></code></li>
<li><code><a title="livekit.rtc.audio_resampler.AudioResamplerQuality.VERY_HIGH" href="#livekit.rtc.audio_resampler.AudioResamplerQuality.VERY_HIGH">VERY_HIGH</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
