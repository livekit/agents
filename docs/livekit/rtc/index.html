<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>livekit.rtc API documentation</title>
<meta name="description" content="LiveKit RTC SDK">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>livekit.rtc</code></h1>
</header>
<section id="section-intro">
<p>LiveKit RTC SDK</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="livekit.rtc.apm" href="apm.html">livekit.rtc.apm</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.audio_filter" href="audio_filter.html">livekit.rtc.audio_filter</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.audio_frame" href="audio_frame.html">livekit.rtc.audio_frame</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.audio_mixer" href="audio_mixer.html">livekit.rtc.audio_mixer</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.audio_resampler" href="audio_resampler.html">livekit.rtc.audio_resampler</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.audio_source" href="audio_source.html">livekit.rtc.audio_source</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.audio_stream" href="audio_stream.html">livekit.rtc.audio_stream</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.data_stream" href="data_stream.html">livekit.rtc.data_stream</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.e2ee" href="e2ee.html">livekit.rtc.e2ee</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.event_emitter" href="event_emitter.html">livekit.rtc.event_emitter</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.jupyter" href="jupyter.html">livekit.rtc.jupyter</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.log" href="log.html">livekit.rtc.log</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.resources" href="resources/index.html">livekit.rtc.resources</a></code></dt>
<dd>
<div class="desc"><p>Used by importlib.resources and setuptools</p></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.room" href="room.html">livekit.rtc.room</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.rpc" href="rpc.html">livekit.rtc.rpc</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.synchronizer" href="synchronizer.html">livekit.rtc.synchronizer</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.track" href="track.html">livekit.rtc.track</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.track_publication" href="track_publication.html">livekit.rtc.track_publication</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.transcription" href="transcription.html">livekit.rtc.transcription</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.utils" href="utils.html">livekit.rtc.utils</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.version" href="version.html">livekit.rtc.version</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.video_frame" href="video_frame.html">livekit.rtc.video_frame</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.video_source" href="video_source.html">livekit.rtc.video_source</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.rtc.video_stream" href="video_stream.html">livekit.rtc.video_stream</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="livekit.rtc.combine_audio_frames"><code class="name flex">
<span>def <span class="ident">combine_audio_frames</span></span>(<span>buffer: <a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a> | list[<a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a>]) ‑> <a title="livekit.rtc.audio_frame.AudioFrame" href="audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_audio_frames(buffer: AudioFrame | list[AudioFrame]) -&gt; AudioFrame:
    &#34;&#34;&#34;
    Combines one or more `rtc.AudioFrame` objects into a single `rtc.AudioFrame`.

    This function concatenates the audio data from multiple frames, ensuring that
    all frames have the same sample rate and number of channels. It efficiently
    merges the data by preallocating the necessary memory and copying the frame
    data without unnecessary reallocations.

    Args:
        buffer: A single `rtc.AudioFrame` or a list of `rtc.AudioFrame`
            objects to be combined.

    Returns:
        rtc.AudioFrame: A new `rtc.AudioFrame` containing the combined audio data.

    Raises:
        ValueError: If the buffer is empty.
        ValueError: If frames have differing sample rates.
        ValueError: If frames have differing numbers of channels.

    Example:
        &gt;&gt;&gt; frame1 = rtc.AudioFrame(
        ...     data=b&#34;\x01\x02&#34;, sample_rate=48000, num_channels=2, samples_per_channel=1
        ... )
        &gt;&gt;&gt; frame2 = rtc.AudioFrame(
        ...     data=b&#34;\x03\x04&#34;, sample_rate=48000, num_channels=2, samples_per_channel=1
        ... )
        &gt;&gt;&gt; combined_frame = combine_audio_frames([frame1, frame2])
        &gt;&gt;&gt; combined_frame.data
        b&#39;\x01\x02\x03\x04&#39;
        &gt;&gt;&gt; combined_frame.sample_rate
        48000
        &gt;&gt;&gt; combined_frame.num_channels
        2
        &gt;&gt;&gt; combined_frame.samples_per_channel
        2
    &#34;&#34;&#34;
    if not isinstance(buffer, list):
        return buffer

    if not buffer:
        raise ValueError(&#34;buffer is empty&#34;)

    sample_rate = buffer[0].sample_rate
    num_channels = buffer[0].num_channels

    total_data_length = 0
    total_samples_per_channel = 0

    for frame in buffer:
        if frame.sample_rate != sample_rate:
            raise ValueError(
                f&#34;Sample rate mismatch: expected {sample_rate}, got {frame.sample_rate}&#34;
            )

        if frame.num_channels != num_channels:
            raise ValueError(
                f&#34;Channel count mismatch: expected {num_channels}, got {frame.num_channels}&#34;
            )

        total_data_length += len(frame.data)
        total_samples_per_channel += frame.samples_per_channel

    data = bytearray(total_data_length)
    offset = 0
    for frame in buffer:
        frame_data = frame.data.cast(&#34;b&#34;)
        data[offset : offset + len(frame_data)] = frame_data
        offset += len(frame_data)

    return AudioFrame(
        data=data,
        sample_rate=sample_rate,
        num_channels=num_channels,
        samples_per_channel=total_samples_per_channel,
    )</code></pre>
</details>
<div class="desc"><p>Combines one or more <code>rtc.AudioFrame</code> objects into a single <code>rtc.AudioFrame</code>.</p>
<p>This function concatenates the audio data from multiple frames, ensuring that
all frames have the same sample rate and number of channels. It efficiently
merges the data by preallocating the necessary memory and copying the frame
data without unnecessary reallocations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>buffer</code></strong></dt>
<dd>A single <code>rtc.AudioFrame</code> or a list of <code>rtc.AudioFrame</code>
objects to be combined.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>rtc.AudioFrame</code></dt>
<dd>A new <code>rtc.AudioFrame</code> containing the combined audio data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the buffer is empty.</dd>
<dt><code>ValueError</code></dt>
<dd>If frames have differing sample rates.</dd>
<dt><code>ValueError</code></dt>
<dd>If frames have differing numbers of channels.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; frame1 = rtc.AudioFrame(
...     data=b&quot;&quot;, sample_rate=48000, num_channels=2, samples_per_channel=1
... )
&gt;&gt;&gt; frame2 = rtc.AudioFrame(
...     data=b&quot;&quot;, sample_rate=48000, num_channels=2, samples_per_channel=1
... )
&gt;&gt;&gt; combined_frame = combine_audio_frames([frame1, frame2])
&gt;&gt;&gt; combined_frame.data
b''
&gt;&gt;&gt; combined_frame.sample_rate
48000
&gt;&gt;&gt; combined_frame.num_channels
2
&gt;&gt;&gt; combined_frame.samples_per_channel
2
</code></pre></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="livekit.rtc.AVSynchronizer"><code class="flex name class">
<span>class <span class="ident">AVSynchronizer</span></span>
<span>(</span><span>*,<br>audio_source: <a title="livekit.rtc.audio_source.AudioSource" href="audio_source.html#livekit.rtc.audio_source.AudioSource">AudioSource</a>,<br>video_source: <a title="livekit.rtc.video_source.VideoSource" href="video_source.html#livekit.rtc.video_source.VideoSource">VideoSource</a>,<br>video_fps: float,<br>video_queue_size_ms: float = 100)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AVSynchronizer:
    &#34;&#34;&#34;Synchronize audio and video capture.

    Usage:
        av_sync = AVSynchronizer(
            audio_source=audio_source,
            video_source=video_source,
            video_fps=video_fps,
        )

        async for video_frame, audio_frame in video_generator:
            await av_sync.push(video_frame)
            await av_sync.push(audio_frame)
    &#34;&#34;&#34;

    def __init__(
        self,
        *,
        audio_source: AudioSource,
        video_source: VideoSource,
        video_fps: float,
        video_queue_size_ms: float = 100,
        _max_delay_tolerance_ms: float = 300,
    ):
        self._audio_source = audio_source
        self._video_source = video_source
        self._video_fps = video_fps
        self._video_queue_size_ms = video_queue_size_ms
        self._max_delay_tolerance_ms = _max_delay_tolerance_ms

        self._stopped = False
        # the time of the last video/audio frame captured
        self._last_video_time: float = 0
        self._last_audio_time: float = 0

        self._video_queue_max_size = int(self._video_fps * self._video_queue_size_ms / 1000)
        if self._video_queue_size_ms &gt; 0:
            # ensure queue is bounded if queue size is specified
            self._video_queue_max_size = max(1, self._video_queue_max_size)

        self._video_queue = asyncio.Queue[tuple[VideoFrame, Optional[float]]](
            maxsize=self._video_queue_max_size
        )
        self._fps_controller = _FPSController(
            expected_fps=self._video_fps,
            max_delay_tolerance_ms=self._max_delay_tolerance_ms,
        )
        self._capture_video_task = asyncio.create_task(self._capture_video())

    async def push(
        self, frame: Union[VideoFrame, AudioFrame], timestamp: Optional[float] = None
    ) -&gt; None:
        &#34;&#34;&#34;Push a frame to the synchronizer

        Args:
            frame: The video or audio frame to push.
            timestamp: (optional) The timestamp of the frame, for logging purposes for now.
                For AudioFrame, it should be the end time of the frame.
        &#34;&#34;&#34;
        if isinstance(frame, AudioFrame):
            await self._audio_source.capture_frame(frame)
            if timestamp is not None:
                self._last_audio_time = timestamp
            return

        await self._video_queue.put((frame, timestamp))

    async def clear_queue(self) -&gt; None:
        self._audio_source.clear_queue()
        while not self._video_queue.empty():
            await self._video_queue.get()
            self._video_queue.task_done()

    async def wait_for_playout(self) -&gt; None:
        &#34;&#34;&#34;Wait until all video and audio frames are played out.&#34;&#34;&#34;
        await asyncio.gather(
            self._audio_source.wait_for_playout(),
            self._video_queue.join(),
        )

    def reset(self) -&gt; None:
        self._fps_controller.reset()

    async def _capture_video(self) -&gt; None:
        while not self._stopped:
            frame, timestamp = await self._video_queue.get()
            async with self._fps_controller:
                self._video_source.capture_frame(frame)
                if timestamp is not None:
                    self._last_video_time = timestamp
            self._video_queue.task_done()

    async def aclose(self) -&gt; None:
        self._stopped = True
        if self._capture_video_task:
            self._capture_video_task.cancel()

    @property
    def actual_fps(self) -&gt; float:
        return self._fps_controller.actual_fps

    @property
    def last_video_time(self) -&gt; float:
        &#34;&#34;&#34;The time of the last video frame captured&#34;&#34;&#34;
        return self._last_video_time

    @property
    def last_audio_time(self) -&gt; float:
        &#34;&#34;&#34;The time of the last audio frame played out&#34;&#34;&#34;
        return self._last_audio_time - self._audio_source.queued_duration</code></pre>
</details>
<div class="desc"><p>Synchronize audio and video capture.</p>
<h2 id="usage">Usage</h2>
<p>av_sync = AVSynchronizer(
audio_source=audio_source,
video_source=video_source,
video_fps=video_fps,
)</p>
<p>async for video_frame, audio_frame in video_generator:
await av_sync.push(video_frame)
await av_sync.push(audio_frame)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.AVSynchronizer.actual_fps"><code class="name">prop <span class="ident">actual_fps</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def actual_fps(self) -&gt; float:
    return self._fps_controller.actual_fps</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.AVSynchronizer.last_audio_time"><code class="name">prop <span class="ident">last_audio_time</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def last_audio_time(self) -&gt; float:
    &#34;&#34;&#34;The time of the last audio frame played out&#34;&#34;&#34;
    return self._last_audio_time - self._audio_source.queued_duration</code></pre>
</details>
<div class="desc"><p>The time of the last audio frame played out</p></div>
</dd>
<dt id="livekit.rtc.AVSynchronizer.last_video_time"><code class="name">prop <span class="ident">last_video_time</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def last_video_time(self) -&gt; float:
    &#34;&#34;&#34;The time of the last video frame captured&#34;&#34;&#34;
    return self._last_video_time</code></pre>
</details>
<div class="desc"><p>The time of the last video frame captured</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.AVSynchronizer.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self) -&gt; None:
    self._stopped = True
    if self._capture_video_task:
        self._capture_video_task.cancel()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.AVSynchronizer.clear_queue"><code class="name flex">
<span>async def <span class="ident">clear_queue</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_queue(self) -&gt; None:
    self._audio_source.clear_queue()
    while not self._video_queue.empty():
        await self._video_queue.get()
        self._video_queue.task_done()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.AVSynchronizer.push"><code class="name flex">
<span>async def <span class="ident">push</span></span>(<span>self,<br>frame: <a title="livekit.rtc.video_frame.VideoFrame" href="video_frame.html#livekit.rtc.video_frame.VideoFrame">VideoFrame</a> | <a title="livekit.rtc.audio_frame.AudioFrame" href="audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>,<br>timestamp: float | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def push(
    self, frame: Union[VideoFrame, AudioFrame], timestamp: Optional[float] = None
) -&gt; None:
    &#34;&#34;&#34;Push a frame to the synchronizer

    Args:
        frame: The video or audio frame to push.
        timestamp: (optional) The timestamp of the frame, for logging purposes for now.
            For AudioFrame, it should be the end time of the frame.
    &#34;&#34;&#34;
    if isinstance(frame, AudioFrame):
        await self._audio_source.capture_frame(frame)
        if timestamp is not None:
            self._last_audio_time = timestamp
        return

    await self._video_queue.put((frame, timestamp))</code></pre>
</details>
<div class="desc"><p>Push a frame to the synchronizer</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frame</code></strong></dt>
<dd>The video or audio frame to push.</dd>
<dt><strong><code>timestamp</code></strong></dt>
<dd>(optional) The timestamp of the frame, for logging purposes for now.
For AudioFrame, it should be the end time of the frame.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.AVSynchronizer.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self) -&gt; None:
    self._fps_controller.reset()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.AVSynchronizer.wait_for_playout"><code class="name flex">
<span>async def <span class="ident">wait_for_playout</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_playout(self) -&gt; None:
    &#34;&#34;&#34;Wait until all video and audio frames are played out.&#34;&#34;&#34;
    await asyncio.gather(
        self._audio_source.wait_for_playout(),
        self._video_queue.join(),
    )</code></pre>
</details>
<div class="desc"><p>Wait until all video and audio frames are played out.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.AudioFilter"><code class="flex name class">
<span>class <span class="ident">AudioFilter</span></span>
<span>(</span><span>module_id: str, path: str, dependencies: List[str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioFilter:
    def __init__(self, module_id: str, path: str, dependencies: Optional[List[str]] = None) -&gt; None:
        self._path = path

        req = proto_ffi.FfiRequest()
        req.load_audio_filter_plugin.module_id = module_id
        req.load_audio_filter_plugin.plugin_path = path
        req.load_audio_filter_plugin.dependencies[:] = (
            dependencies if dependencies is not None else []
        )

        resp = FfiClient.instance.request(req)

        if resp.load_audio_filter_plugin.error:
            raise Exception(
                f&#34;failed to initialize audio filter #{resp.load_audio_filter_plugin.error}&#34;
            )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.AudioFrame"><code class="flex name class">
<span>class <span class="ident">AudioFrame</span></span>
<span>(</span><span>data: bytes | bytearray | memoryview,<br>sample_rate: int,<br>num_channels: int,<br>samples_per_channel: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioFrame:
    &#34;&#34;&#34;
    A class that represents a frame of audio data with specific properties such as sample rate,
    number of channels, and samples per channel.

    The format of the audio data is 16-bit signed integers (int16) interleaved by channel.
    &#34;&#34;&#34;

    def __init__(
        self,
        data: Union[bytes, bytearray, memoryview],
        sample_rate: int,
        num_channels: int,
        samples_per_channel: int,
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize an AudioFrame instance.

        Args:
            data (Union[bytes, bytearray, memoryview]): The raw audio data, which must be at least
                `num_channels * samples_per_channel * sizeof(int16)` bytes long.
            sample_rate (int): The sample rate of the audio in Hz.
            num_channels (int): The number of audio channels (e.g., 1 for mono, 2 for stereo).
            samples_per_channel (int): The number of samples per channel.

        Raises:
            ValueError: If the length of `data` is smaller than the required size.
        &#34;&#34;&#34;
        data = memoryview(data).cast(&#34;B&#34;)

        if len(data) &lt; num_channels * samples_per_channel * ctypes.sizeof(ctypes.c_int16):
            raise ValueError(
                &#34;data length must be &gt;= num_channels * samples_per_channel * sizeof(int16)&#34;
            )

        if len(data) % ctypes.sizeof(ctypes.c_int16) != 0:
            # can happen if data is bigger than needed
            raise ValueError(&#34;data length must be a multiple of sizeof(int16)&#34;)

        n = len(data) // ctypes.sizeof(ctypes.c_int16)
        self._data = (ctypes.c_int16 * n).from_buffer_copy(data)

        self._sample_rate = sample_rate
        self._num_channels = num_channels
        self._samples_per_channel = samples_per_channel

    @staticmethod
    def create(sample_rate: int, num_channels: int, samples_per_channel: int) -&gt; &#34;AudioFrame&#34;:
        &#34;&#34;&#34;
        Create a new empty AudioFrame instance with specified sample rate, number of channels,
        and samples per channel.

        Args:
            sample_rate (int): The sample rate of the audio in Hz.
            num_channels (int): The number of audio channels (e.g., 1 for mono, 2 for stereo).
            samples_per_channel (int): The number of samples per channel.

        Returns:
            AudioFrame: A new AudioFrame instance with uninitialized (zeroed) data.
        &#34;&#34;&#34;
        size = num_channels * samples_per_channel * ctypes.sizeof(ctypes.c_int16)
        data = bytearray(size)
        return AudioFrame(data, sample_rate, num_channels, samples_per_channel)

    @staticmethod
    def _from_owned_info(owned_info: proto_audio.OwnedAudioFrameBuffer) -&gt; &#34;AudioFrame&#34;:
        info = owned_info.info
        size = info.num_channels * info.samples_per_channel
        cdata = (ctypes.c_int16 * size).from_address(info.data_ptr)
        data = bytearray(cdata)
        FfiHandle(owned_info.handle.id)
        return AudioFrame(data, info.sample_rate, info.num_channels, info.samples_per_channel)

    def _proto_info(self) -&gt; proto_audio.AudioFrameBufferInfo:
        audio_info = proto_audio.AudioFrameBufferInfo()
        audio_info.data_ptr = get_address(memoryview(self._data))
        audio_info.sample_rate = self.sample_rate
        audio_info.num_channels = self.num_channels
        audio_info.samples_per_channel = self.samples_per_channel
        return audio_info

    @property
    def data(self) -&gt; memoryview:
        &#34;&#34;&#34;
        Returns a memory view of the audio data as 16-bit signed integers.

        Returns:
            memoryview: A memory view of the audio data.
        &#34;&#34;&#34;
        return memoryview(self._data).cast(&#34;B&#34;).cast(&#34;h&#34;)

    @property
    def sample_rate(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the sample rate of the audio frame.

        Returns:
            int: The sample rate in Hz.
        &#34;&#34;&#34;
        return self._sample_rate

    @property
    def num_channels(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of channels in the audio frame.

        Returns:
            int: The number of audio channels (e.g., 1 for mono, 2 for stereo).
        &#34;&#34;&#34;
        return self._num_channels

    @property
    def samples_per_channel(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of samples per channel.

        Returns:
            int: The number of samples per channel.
        &#34;&#34;&#34;
        return self._samples_per_channel

    @property
    def duration(self) -&gt; float:
        &#34;&#34;&#34;
        Returns the duration of the audio frame in seconds.

        Returns:
            float: The duration in seconds.
        &#34;&#34;&#34;
        return self.samples_per_channel / self.sample_rate

    def to_wav_bytes(self) -&gt; bytes:
        &#34;&#34;&#34;
        Convert the audio frame data to a WAV-formatted byte stream.

        Returns:
            bytes: The audio data encoded in WAV format.
        &#34;&#34;&#34;
        import wave
        import io

        with io.BytesIO() as wav_file:
            with wave.open(wav_file, &#34;wb&#34;) as wav:
                wav.setnchannels(self.num_channels)
                wav.setsampwidth(2)
                wav.setframerate(self.sample_rate)
                wav.writeframes(self._data)

            return wav_file.getvalue()

    def __repr__(self) -&gt; str:
        return (
            f&#34;rtc.AudioFrame(sample_rate={self.sample_rate}, &#34;
            f&#34;num_channels={self.num_channels}, &#34;
            f&#34;samples_per_channel={self.samples_per_channel}, &#34;
            f&#34;duration={self.duration:.3f})&#34;
        )

    @classmethod
    def __get_pydantic_core_schema__(cls, *_: Any):
        from pydantic_core import core_schema
        import base64

        def validate_audio_frame(value: Any) -&gt; &#34;AudioFrame&#34;:
            if isinstance(value, AudioFrame):
                return value

            if isinstance(value, tuple):
                value = value[0]

            if isinstance(value, dict):
                return AudioFrame(
                    data=base64.b64decode(value[&#34;data&#34;]),
                    sample_rate=value[&#34;sample_rate&#34;],
                    num_channels=value[&#34;num_channels&#34;],
                    samples_per_channel=value[&#34;samples_per_channel&#34;],
                )

            raise TypeError(&#34;Invalid type for AudioFrame&#34;)

        return core_schema.json_or_python_schema(
            json_schema=core_schema.chain_schema(
                [
                    core_schema.model_fields_schema(
                        {
                            &#34;data&#34;: core_schema.model_field(core_schema.str_schema()),
                            &#34;sample_rate&#34;: core_schema.model_field(core_schema.int_schema()),
                            &#34;num_channels&#34;: core_schema.model_field(core_schema.int_schema()),
                            &#34;samples_per_channel&#34;: core_schema.model_field(
                                core_schema.int_schema()
                            ),
                        },
                    ),
                    core_schema.no_info_plain_validator_function(validate_audio_frame),
                ]
            ),
            python_schema=core_schema.no_info_plain_validator_function(validate_audio_frame),
            serialization=core_schema.plain_serializer_function_ser_schema(
                lambda instance: {
                    &#34;data&#34;: base64.b64encode(instance.data).decode(&#34;utf-8&#34;),
                    &#34;sample_rate&#34;: instance.sample_rate,
                    &#34;num_channels&#34;: instance.num_channels,
                    &#34;samples_per_channel&#34;: instance.samples_per_channel,
                }
            ),
        )</code></pre>
</details>
<div class="desc"><p>A class that represents a frame of audio data with specific properties such as sample rate,
number of channels, and samples per channel.</p>
<p>The format of the audio data is 16-bit signed integers (int16) interleaved by channel.</p>
<p>Initialize an AudioFrame instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Union[bytes, bytearray, memoryview]</code></dt>
<dd>The raw audio data, which must be at least
<code>num_channels * samples_per_channel * sizeof(int16)</code> bytes long.</dd>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>The sample rate of the audio in Hz.</dd>
<dt><strong><code>num_channels</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of audio channels (e.g., 1 for mono, 2 for stereo).</dd>
<dt><strong><code>samples_per_channel</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of samples per channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the length of <code>data</code> is smaller than the required size.</dd>
</dl></div>
<h3>Static methods</h3>
<dl>
<dt id="livekit.rtc.AudioFrame.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>sample_rate: int, num_channels: int, samples_per_channel: int) ‑> <a title="livekit.rtc.audio_frame.AudioFrame" href="audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create(sample_rate: int, num_channels: int, samples_per_channel: int) -&gt; &#34;AudioFrame&#34;:
    &#34;&#34;&#34;
    Create a new empty AudioFrame instance with specified sample rate, number of channels,
    and samples per channel.

    Args:
        sample_rate (int): The sample rate of the audio in Hz.
        num_channels (int): The number of audio channels (e.g., 1 for mono, 2 for stereo).
        samples_per_channel (int): The number of samples per channel.

    Returns:
        AudioFrame: A new AudioFrame instance with uninitialized (zeroed) data.
    &#34;&#34;&#34;
    size = num_channels * samples_per_channel * ctypes.sizeof(ctypes.c_int16)
    data = bytearray(size)
    return AudioFrame(data, sample_rate, num_channels, samples_per_channel)</code></pre>
</details>
<div class="desc"><p>Create a new empty AudioFrame instance with specified sample rate, number of channels,
and samples per channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>The sample rate of the audio in Hz.</dd>
<dt><strong><code>num_channels</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of audio channels (e.g., 1 for mono, 2 for stereo).</dd>
<dt><strong><code>samples_per_channel</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of samples per channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a></code></dt>
<dd>A new AudioFrame instance with uninitialized (zeroed) data.</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.AudioFrame.data"><code class="name">prop <span class="ident">data</span> : memoryview</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; memoryview:
    &#34;&#34;&#34;
    Returns a memory view of the audio data as 16-bit signed integers.

    Returns:
        memoryview: A memory view of the audio data.
    &#34;&#34;&#34;
    return memoryview(self._data).cast(&#34;B&#34;).cast(&#34;h&#34;)</code></pre>
</details>
<div class="desc"><p>Returns a memory view of the audio data as 16-bit signed integers.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>memoryview</code></dt>
<dd>A memory view of the audio data.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.AudioFrame.duration"><code class="name">prop <span class="ident">duration</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def duration(self) -&gt; float:
    &#34;&#34;&#34;
    Returns the duration of the audio frame in seconds.

    Returns:
        float: The duration in seconds.
    &#34;&#34;&#34;
    return self.samples_per_channel / self.sample_rate</code></pre>
</details>
<div class="desc"><p>Returns the duration of the audio frame in seconds.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The duration in seconds.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.AudioFrame.num_channels"><code class="name">prop <span class="ident">num_channels</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_channels(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of channels in the audio frame.

    Returns:
        int: The number of audio channels (e.g., 1 for mono, 2 for stereo).
    &#34;&#34;&#34;
    return self._num_channels</code></pre>
</details>
<div class="desc"><p>Returns the number of channels in the audio frame.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of audio channels (e.g., 1 for mono, 2 for stereo).</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.AudioFrame.sample_rate"><code class="name">prop <span class="ident">sample_rate</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sample_rate(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the sample rate of the audio frame.

    Returns:
        int: The sample rate in Hz.
    &#34;&#34;&#34;
    return self._sample_rate</code></pre>
</details>
<div class="desc"><p>Returns the sample rate of the audio frame.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The sample rate in Hz.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.AudioFrame.samples_per_channel"><code class="name">prop <span class="ident">samples_per_channel</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def samples_per_channel(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of samples per channel.

    Returns:
        int: The number of samples per channel.
    &#34;&#34;&#34;
    return self._samples_per_channel</code></pre>
</details>
<div class="desc"><p>Returns the number of samples per channel.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of samples per channel.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.AudioFrame.to_wav_bytes"><code class="name flex">
<span>def <span class="ident">to_wav_bytes</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_wav_bytes(self) -&gt; bytes:
    &#34;&#34;&#34;
    Convert the audio frame data to a WAV-formatted byte stream.

    Returns:
        bytes: The audio data encoded in WAV format.
    &#34;&#34;&#34;
    import wave
    import io

    with io.BytesIO() as wav_file:
        with wave.open(wav_file, &#34;wb&#34;) as wav:
            wav.setnchannels(self.num_channels)
            wav.setsampwidth(2)
            wav.setframerate(self.sample_rate)
            wav.writeframes(self._data)

        return wav_file.getvalue()</code></pre>
</details>
<div class="desc"><p>Convert the audio frame data to a WAV-formatted byte stream.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The audio data encoded in WAV format.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.AudioFrameEvent"><code class="flex name class">
<span>class <span class="ident">AudioFrameEvent</span></span>
<span>(</span><span>frame: <a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class AudioFrameEvent:
    &#34;&#34;&#34;An event representing a received audio frame.

    Attributes:
        frame (AudioFrame): The received audio frame.
    &#34;&#34;&#34;

    frame: AudioFrame</code></pre>
</details>
<div class="desc"><p>An event representing a received audio frame.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>frame</code></strong> :&ensp;<code><a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a></code></dt>
<dd>The received audio frame.</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.AudioFrameEvent.frame"><code class="name">var <span class="ident">frame</span> : <a title="livekit.rtc.audio_frame.AudioFrame" href="audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.AudioMixer"><code class="flex name class">
<span>class <span class="ident">AudioMixer</span></span>
<span>(</span><span>sample_rate: int,<br>num_channels: int,<br>*,<br>blocksize: int = 0,<br>stream_timeout_ms: int = 100,<br>capacity: int = 100)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioMixer:
    def __init__(
        self,
        sample_rate: int,
        num_channels: int,
        *,
        blocksize: int = 0,
        stream_timeout_ms: int = 100,
        capacity: int = 100,
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the AudioMixer.

        The mixer accepts multiple async audio streams and mixes them into a single output stream.
        Each output frame is generated with a fixed chunk size determined by the blocksize (in samples).
        If blocksize is not provided (or 0), it defaults to 100ms.

        Each input stream is processed in parallel, accumulating audio data until at least one chunk
        of samples is available. If an input stream does not provide data within the specified timeout,
        a warning is logged. The mixer can be closed immediately
        (dropping unconsumed frames) or allowed to flush remaining data using end_input().

        Args:
            sample_rate (int): The audio sample rate in Hz.
            num_channels (int): The number of audio channels.
            blocksize (int, optional): The size of the audio block (in samples) for mixing. If not provided,
                defaults to sample_rate // 10.
            stream_timeout_ms (int, optional): The maximum wait time in milliseconds for each stream to provide
                audio data before timing out. Defaults to 100 ms.
            capacity (int, optional): The maximum number of mixed frames to store in the output queue.
                Defaults to 100.
        &#34;&#34;&#34;
        self._streams: set[_Stream] = set()
        self._buffers: dict[_Stream, np.ndarray] = {}
        self._sample_rate: int = sample_rate
        self._num_channels: int = num_channels
        self._chunk_size: int = blocksize if blocksize &gt; 0 else int(sample_rate // 10)
        self._stream_timeout_ms: int = stream_timeout_ms
        self._queue: asyncio.Queue[Optional[AudioFrame]] = asyncio.Queue(maxsize=capacity)
        # _ending signals that no new streams will be added,
        # but we continue processing until all streams are exhausted.
        self._ending: bool = False
        self._mixer_task: asyncio.Task = asyncio.create_task(self._mixer())

    def add_stream(self, stream: AsyncIterator[AudioFrame]) -&gt; None:
        &#34;&#34;&#34;
        Add an audio stream to the mixer.

        The stream is added to the internal set of streams and an empty buffer is initialized for it,
        if not already present.

        Args:
            stream (AsyncIterator[AudioFrame]): An async iterator that produces AudioFrame objects.
        &#34;&#34;&#34;
        if self._ending:
            raise RuntimeError(&#34;Cannot add stream after mixer has been closed&#34;)

        self._streams.add(stream)
        if stream not in self._buffers:
            self._buffers[stream] = np.empty((0, self._num_channels), dtype=np.int16)

    def remove_stream(self, stream: AsyncIterator[AudioFrame]) -&gt; None:
        &#34;&#34;&#34;
        Remove an audio stream from the mixer.

        This method removes the specified stream and its associated buffer from the mixer.

        Args:
            stream (AsyncIterator[AudioFrame]): The audio stream to remove.
        &#34;&#34;&#34;
        self._streams.discard(stream)
        self._buffers.pop(stream, None)

    def __aiter__(self) -&gt; &#34;AudioMixer&#34;:
        return self

    async def __anext__(self) -&gt; AudioFrame:
        item = await self._queue.get()
        if item is None:
            raise StopAsyncIteration
        return item

    async def aclose(self) -&gt; None:
        &#34;&#34;&#34;
        Immediately stop mixing and close the mixer.

        This cancels the mixing task, and any unconsumed output in the queue may be dropped.
        &#34;&#34;&#34;
        self._ending = True
        self._mixer_task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            await self._mixer_task

    def end_input(self) -&gt; None:
        &#34;&#34;&#34;
        Signal that no more streams will be added.

        This method marks the mixer as closed so that it flushes any remaining buffered output before ending.
        Note that existing streams will still be processed until exhausted.
        &#34;&#34;&#34;
        self._ending = True

    async def _mixer(self) -&gt; None:
        while True:
            # If we&#39;re in ending mode and there are no more streams, exit.
            if self._ending and not self._streams:
                break

            if not self._streams:
                await asyncio.sleep(0.01)
                continue

            tasks = [
                self._get_contribution(
                    stream,
                    self._buffers.get(stream, np.empty((0, self._num_channels), dtype=np.int16)),
                )
                for stream in list(self._streams)
            ]
            results = await asyncio.gather(*tasks, return_exceptions=True)
            contributions = []
            any_data = False
            removals = []
            for contrib in results:
                if not isinstance(contrib, _Contribution):
                    continue

                contributions.append(contrib.data.astype(np.float32))
                self._buffers[contrib.stream] = contrib.buffer
                if contrib.had_data:
                    any_data = True
                if contrib.exhausted and contrib.buffer.shape[0] == 0:
                    removals.append(contrib.stream)

            for stream in removals:
                self.remove_stream(stream)

            if not any_data:
                await asyncio.sleep(0.001)
                continue

            mixed = np.sum(np.stack(contributions, axis=0), axis=0)
            mixed = np.clip(mixed, -32768, 32767).astype(np.int16)
            frame = AudioFrame(
                mixed.tobytes(), self._sample_rate, self._num_channels, self._chunk_size
            )
            await self._queue.put(frame)

        await self._queue.put(None)

    async def _get_contribution(
        self, stream: AsyncIterator[AudioFrame], buf: np.ndarray
    ) -&gt; _Contribution:
        had_data = buf.shape[0] &gt; 0
        exhausted = False
        while buf.shape[0] &lt; self._chunk_size and not exhausted:
            try:
                frame = await asyncio.wait_for(
                    stream.__anext__(), timeout=self._stream_timeout_ms / 1000
                )
            except asyncio.TimeoutError:
                logger.warning(f&#34;AudioMixer: stream {stream} timeout, ignoring&#34;)
                break
            except StopAsyncIteration:
                exhausted = True
                break
            new_data = np.frombuffer(frame.data.tobytes(), dtype=np.int16).reshape(
                -1, self._num_channels
            )
            buf = np.concatenate((buf, new_data), axis=0) if buf.size else new_data
            had_data = True
        if buf.shape[0] &gt;= self._chunk_size:
            contrib, buf = buf[: self._chunk_size], buf[self._chunk_size :]
        else:
            pad = np.zeros((self._chunk_size - buf.shape[0], self._num_channels), dtype=np.int16)
            contrib, buf = (
                np.concatenate((buf, pad), axis=0),
                np.empty((0, self._num_channels), dtype=np.int16),
            )
        return _Contribution(stream, contrib, buf, had_data, exhausted)</code></pre>
</details>
<div class="desc"><p>Initialize the AudioMixer.</p>
<p>The mixer accepts multiple async audio streams and mixes them into a single output stream.
Each output frame is generated with a fixed chunk size determined by the blocksize (in samples).
If blocksize is not provided (or 0), it defaults to 100ms.</p>
<p>Each input stream is processed in parallel, accumulating audio data until at least one chunk
of samples is available. If an input stream does not provide data within the specified timeout,
a warning is logged. The mixer can be closed immediately
(dropping unconsumed frames) or allowed to flush remaining data using end_input().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>The audio sample rate in Hz.</dd>
<dt><strong><code>num_channels</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of audio channels.</dd>
<dt><strong><code>blocksize</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The size of the audio block (in samples) for mixing. If not provided,
defaults to sample_rate // 10.</dd>
<dt><strong><code>stream_timeout_ms</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum wait time in milliseconds for each stream to provide
audio data before timing out. Defaults to 100 ms.</dd>
<dt><strong><code>capacity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum number of mixed frames to store in the output queue.
Defaults to 100.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.AudioMixer.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self) -&gt; None:
    &#34;&#34;&#34;
    Immediately stop mixing and close the mixer.

    This cancels the mixing task, and any unconsumed output in the queue may be dropped.
    &#34;&#34;&#34;
    self._ending = True
    self._mixer_task.cancel()
    with contextlib.suppress(asyncio.CancelledError):
        await self._mixer_task</code></pre>
</details>
<div class="desc"><p>Immediately stop mixing and close the mixer.</p>
<p>This cancels the mixing task, and any unconsumed output in the queue may be dropped.</p></div>
</dd>
<dt id="livekit.rtc.AudioMixer.add_stream"><code class="name flex">
<span>def <span class="ident">add_stream</span></span>(<span>self,<br>stream: AsyncIterator[<a title="livekit.rtc.audio_frame.AudioFrame" href="audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stream(self, stream: AsyncIterator[AudioFrame]) -&gt; None:
    &#34;&#34;&#34;
    Add an audio stream to the mixer.

    The stream is added to the internal set of streams and an empty buffer is initialized for it,
    if not already present.

    Args:
        stream (AsyncIterator[AudioFrame]): An async iterator that produces AudioFrame objects.
    &#34;&#34;&#34;
    if self._ending:
        raise RuntimeError(&#34;Cannot add stream after mixer has been closed&#34;)

    self._streams.add(stream)
    if stream not in self._buffers:
        self._buffers[stream] = np.empty((0, self._num_channels), dtype=np.int16)</code></pre>
</details>
<div class="desc"><p>Add an audio stream to the mixer.</p>
<p>The stream is added to the internal set of streams and an empty buffer is initialized for it,
if not already present.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stream</code></strong> :&ensp;<code>AsyncIterator[<a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a>]</code></dt>
<dd>An async iterator that produces AudioFrame objects.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.AudioMixer.end_input"><code class="name flex">
<span>def <span class="ident">end_input</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_input(self) -&gt; None:
    &#34;&#34;&#34;
    Signal that no more streams will be added.

    This method marks the mixer as closed so that it flushes any remaining buffered output before ending.
    Note that existing streams will still be processed until exhausted.
    &#34;&#34;&#34;
    self._ending = True</code></pre>
</details>
<div class="desc"><p>Signal that no more streams will be added.</p>
<p>This method marks the mixer as closed so that it flushes any remaining buffered output before ending.
Note that existing streams will still be processed until exhausted.</p></div>
</dd>
<dt id="livekit.rtc.AudioMixer.remove_stream"><code class="name flex">
<span>def <span class="ident">remove_stream</span></span>(<span>self,<br>stream: AsyncIterator[<a title="livekit.rtc.audio_frame.AudioFrame" href="audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_stream(self, stream: AsyncIterator[AudioFrame]) -&gt; None:
    &#34;&#34;&#34;
    Remove an audio stream from the mixer.

    This method removes the specified stream and its associated buffer from the mixer.

    Args:
        stream (AsyncIterator[AudioFrame]): The audio stream to remove.
    &#34;&#34;&#34;
    self._streams.discard(stream)
    self._buffers.pop(stream, None)</code></pre>
</details>
<div class="desc"><p>Remove an audio stream from the mixer.</p>
<p>This method removes the specified stream and its associated buffer from the mixer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stream</code></strong> :&ensp;<code>AsyncIterator[<a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a>]</code></dt>
<dd>The audio stream to remove.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.AudioProcessingModule"><code class="flex name class">
<span>class <span class="ident">AudioProcessingModule</span></span>
<span>(</span><span>*,<br>echo_cancellation: bool = False,<br>noise_suppression: bool = False,<br>high_pass_filter: bool = False,<br>auto_gain_control: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioProcessingModule:
    &#34;&#34;&#34;
    Provides WebRTC audio processing capabilities including echo cancellation, noise suppression,
    high-pass filtering, and gain control.
    &#34;&#34;&#34;

    def __init__(
        self,
        *,
        echo_cancellation: bool = False,
        noise_suppression: bool = False,
        high_pass_filter: bool = False,
        auto_gain_control: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize an AudioProcessingModule instance with the specified audio processing features.

        Args:
            echo_cancellation (bool, optional): Whether to enable echo cancellation.
            noise_suppression (bool, optional): Whether to enable noise suppression.
            high_pass_filter (bool, optional): Whether to enable a high-pass filter.
            auto_gain_control (bool, optional): Whether to enable auto gain control.
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.new_apm.echo_canceller_enabled = echo_cancellation
        req.new_apm.noise_suppression_enabled = noise_suppression
        req.new_apm.high_pass_filter_enabled = high_pass_filter
        req.new_apm.gain_controller_enabled = auto_gain_control

        resp = FfiClient.instance.request(req)
        self._ffi_handle = FfiHandle(resp.new_apm.apm.handle.id)

    def process_stream(self, data: AudioFrame) -&gt; None:
        &#34;&#34;&#34;
        Process the provided audio frame using the configured audio processing features.

        The input audio frame is modified in-place (if applicable) by the underlying audio
        processing module (e.g., echo cancellation, noise suppression, etc.).

        Important:
            Audio frames must be exactly 10 ms in duration.
        &#34;&#34;&#34;
        bdata = data.data.cast(&#34;b&#34;)

        req = proto_ffi.FfiRequest()
        req.apm_process_stream.apm_handle = self._ffi_handle.handle
        req.apm_process_stream.data_ptr = get_address(memoryview(bdata))
        req.apm_process_stream.size = len(bdata)
        req.apm_process_stream.sample_rate = data.sample_rate
        req.apm_process_stream.num_channels = data.num_channels

        resp = FfiClient.instance.request(req)

        if resp.apm_process_stream.error:
            raise RuntimeError(resp.apm_process_stream.error)

    def process_reverse_stream(self, data: AudioFrame) -&gt; None:
        &#34;&#34;&#34;
        Process the reverse audio frame (typically used for echo cancellation in a full-duplex setup).

        In an echo cancellation scenario, this method is used to process the &#34;far-end&#34; audio
        prior to mixing or feeding it into the echo canceller. Like `process_stream`, the
        input audio frame is modified in-place by the underlying processing module.

        Important:
            Audio frames must be exactly 10 ms in duration.
        &#34;&#34;&#34;
        bdata = data.data.cast(&#34;b&#34;)

        req = proto_ffi.FfiRequest()
        req.apm_process_reverse_stream.apm_handle = self._ffi_handle.handle
        req.apm_process_reverse_stream.data_ptr = get_address(memoryview(bdata))
        req.apm_process_reverse_stream.size = len(bdata)
        req.apm_process_reverse_stream.sample_rate = data.sample_rate
        req.apm_process_reverse_stream.num_channels = data.num_channels

        resp = FfiClient.instance.request(req)

        if resp.apm_process_stream.error:
            raise RuntimeError(resp.apm_process_stream.error)

    def set_stream_delay_ms(self, delay_ms: int) -&gt; None:
        &#34;&#34;&#34;
        This must be called if and only if echo processing is enabled.

        Sets the `delay` in ms between `process_reverse_stream()` receiving a far-end
        frame and `process_stream()` receiving a near-end frame containing the
        corresponding echo. On the client-side this can be expressed as
            delay = (t_render - t_analyze) + (t_process - t_capture)
        where,
            - t_analyze is the time a frame is passed to `process_reverse_stream()` and
            t_render is the time the first sample of the same frame is rendered by
            the audio hardware.
            - t_capture is the time the first sample of a frame is captured by the
            audio hardware and t_process is the time the same frame is passed to
            `process_stream()`.
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.apm_set_stream_delay.apm_handle = self._ffi_handle.handle
        req.apm_set_stream_delay.delay_ms = delay_ms

        resp = FfiClient.instance.request(req)

        if resp.apm_set_stream_delay.error:
            raise RuntimeError(resp.apm_set_stream_delay.error)</code></pre>
</details>
<div class="desc"><p>Provides WebRTC audio processing capabilities including echo cancellation, noise suppression,
high-pass filtering, and gain control.</p>
<p>Initialize an AudioProcessingModule instance with the specified audio processing features.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>echo_cancellation</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to enable echo cancellation.</dd>
<dt><strong><code>noise_suppression</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to enable noise suppression.</dd>
<dt><strong><code>high_pass_filter</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to enable a high-pass filter.</dd>
<dt><strong><code>auto_gain_control</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to enable auto gain control.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.AudioProcessingModule.process_reverse_stream"><code class="name flex">
<span>def <span class="ident">process_reverse_stream</span></span>(<span>self,<br>data: <a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_reverse_stream(self, data: AudioFrame) -&gt; None:
    &#34;&#34;&#34;
    Process the reverse audio frame (typically used for echo cancellation in a full-duplex setup).

    In an echo cancellation scenario, this method is used to process the &#34;far-end&#34; audio
    prior to mixing or feeding it into the echo canceller. Like `process_stream`, the
    input audio frame is modified in-place by the underlying processing module.

    Important:
        Audio frames must be exactly 10 ms in duration.
    &#34;&#34;&#34;
    bdata = data.data.cast(&#34;b&#34;)

    req = proto_ffi.FfiRequest()
    req.apm_process_reverse_stream.apm_handle = self._ffi_handle.handle
    req.apm_process_reverse_stream.data_ptr = get_address(memoryview(bdata))
    req.apm_process_reverse_stream.size = len(bdata)
    req.apm_process_reverse_stream.sample_rate = data.sample_rate
    req.apm_process_reverse_stream.num_channels = data.num_channels

    resp = FfiClient.instance.request(req)

    if resp.apm_process_stream.error:
        raise RuntimeError(resp.apm_process_stream.error)</code></pre>
</details>
<div class="desc"><p>Process the reverse audio frame (typically used for echo cancellation in a full-duplex setup).</p>
<p>In an echo cancellation scenario, this method is used to process the "far-end" audio
prior to mixing or feeding it into the echo canceller. Like <code>process_stream</code>, the
input audio frame is modified in-place by the underlying processing module.</p>
<h2 id="important">Important</h2>
<p>Audio frames must be exactly 10 ms in duration.</p></div>
</dd>
<dt id="livekit.rtc.AudioProcessingModule.process_stream"><code class="name flex">
<span>def <span class="ident">process_stream</span></span>(<span>self,<br>data: <a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_stream(self, data: AudioFrame) -&gt; None:
    &#34;&#34;&#34;
    Process the provided audio frame using the configured audio processing features.

    The input audio frame is modified in-place (if applicable) by the underlying audio
    processing module (e.g., echo cancellation, noise suppression, etc.).

    Important:
        Audio frames must be exactly 10 ms in duration.
    &#34;&#34;&#34;
    bdata = data.data.cast(&#34;b&#34;)

    req = proto_ffi.FfiRequest()
    req.apm_process_stream.apm_handle = self._ffi_handle.handle
    req.apm_process_stream.data_ptr = get_address(memoryview(bdata))
    req.apm_process_stream.size = len(bdata)
    req.apm_process_stream.sample_rate = data.sample_rate
    req.apm_process_stream.num_channels = data.num_channels

    resp = FfiClient.instance.request(req)

    if resp.apm_process_stream.error:
        raise RuntimeError(resp.apm_process_stream.error)</code></pre>
</details>
<div class="desc"><p>Process the provided audio frame using the configured audio processing features.</p>
<p>The input audio frame is modified in-place (if applicable) by the underlying audio
processing module (e.g., echo cancellation, noise suppression, etc.).</p>
<h2 id="important">Important</h2>
<p>Audio frames must be exactly 10 ms in duration.</p></div>
</dd>
<dt id="livekit.rtc.AudioProcessingModule.set_stream_delay_ms"><code class="name flex">
<span>def <span class="ident">set_stream_delay_ms</span></span>(<span>self, delay_ms: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_stream_delay_ms(self, delay_ms: int) -&gt; None:
    &#34;&#34;&#34;
    This must be called if and only if echo processing is enabled.

    Sets the `delay` in ms between `process_reverse_stream()` receiving a far-end
    frame and `process_stream()` receiving a near-end frame containing the
    corresponding echo. On the client-side this can be expressed as
        delay = (t_render - t_analyze) + (t_process - t_capture)
    where,
        - t_analyze is the time a frame is passed to `process_reverse_stream()` and
        t_render is the time the first sample of the same frame is rendered by
        the audio hardware.
        - t_capture is the time the first sample of a frame is captured by the
        audio hardware and t_process is the time the same frame is passed to
        `process_stream()`.
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.apm_set_stream_delay.apm_handle = self._ffi_handle.handle
    req.apm_set_stream_delay.delay_ms = delay_ms

    resp = FfiClient.instance.request(req)

    if resp.apm_set_stream_delay.error:
        raise RuntimeError(resp.apm_set_stream_delay.error)</code></pre>
</details>
<div class="desc"><p>This must be called if and only if echo processing is enabled.</p>
<p>Sets the <code>delay</code> in ms between <code>process_reverse_stream()</code> receiving a far-end
frame and <code>process_stream()</code> receiving a near-end frame containing the
corresponding echo. On the client-side this can be expressed as
delay = (t_render - t_analyze) + (t_process - t_capture)
where,
- t_analyze is the time a frame is passed to <code>process_reverse_stream()</code> and
t_render is the time the first sample of the same frame is rendered by
the audio hardware.
- t_capture is the time the first sample of a frame is captured by the
audio hardware and t_process is the time the same frame is passed to
<code>process_stream()</code>.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.AudioResampler"><code class="flex name class">
<span>class <span class="ident">AudioResampler</span></span>
<span>(</span><span>input_rate: int,<br>output_rate: int,<br>*,<br>num_channels: int = 1,<br>quality: <a title="livekit.rtc.AudioResamplerQuality" href="#livekit.rtc.AudioResamplerQuality">AudioResamplerQuality</a> = AudioResamplerQuality.MEDIUM)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioResampler:
    &#34;&#34;&#34;
    A class for resampling audio data from one sample rate to another.

    `AudioResampler` provides functionality to resample audio data from an input sample rate to an output
    sample rate using the Sox resampling library. It supports multiple channels and configurable resampling quality.
    &#34;&#34;&#34;

    def __init__(
        self,
        input_rate: int,
        output_rate: int,
        *,
        num_channels: int = 1,
        quality: AudioResamplerQuality = AudioResamplerQuality.MEDIUM,
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize an `AudioResampler` instance for resampling audio data.

        Args:
            input_rate (int): The sample rate of the input audio data (in Hz).
            output_rate (int): The desired sample rate of the output audio data (in Hz).
            num_channels (int, optional): The number of audio channels (e.g., 1 for mono, 2 for stereo). Defaults to 1.
            quality (AudioResamplerQuality, optional): The quality setting for the resampler. Can be one of the
                `AudioResamplerQuality` enum values: `QUICK`, `LOW`, `MEDIUM`, `HIGH`, `VERY_HIGH`. Higher quality settings
                result in better audio quality but require more processing power. Defaults to `AudioResamplerQuality.MEDIUM`.

        Raises:
            Exception: If there is an error creating the resampler.
        &#34;&#34;&#34;
        self._input_rate = input_rate
        self._output_rate = output_rate
        self._num_channels = num_channels

        req = proto_ffi.FfiRequest()
        req.new_sox_resampler.input_rate = input_rate
        req.new_sox_resampler.output_rate = output_rate
        req.new_sox_resampler.num_channels = num_channels
        req.new_sox_resampler.quality_recipe = _to_proto_quality(quality)

        # not exposed for now
        req.new_sox_resampler.input_data_type = (
            proto_audio_frame.SoxResamplerDataType.SOXR_DATATYPE_INT16I
        )
        req.new_sox_resampler.output_data_type = (
            proto_audio_frame.SoxResamplerDataType.SOXR_DATATYPE_INT16I
        )
        req.new_sox_resampler.flags = 0  # default

        resp = FfiClient.instance.request(req)

        if resp.new_sox_resampler.error:
            raise Exception(resp.new_sox_resampler.error)

        self._ffi_handle = FfiHandle(resp.new_sox_resampler.resampler.handle.id)

    def push(self, data: bytearray | AudioFrame) -&gt; list[AudioFrame]:
        &#34;&#34;&#34;
        Push audio data into the resampler and retrieve any available resampled data.

        This method accepts audio data, resamples it according to the configured input and output rates,
        and returns any resampled data that is available after processing the input.

        Args:
            data (bytearray | AudioFrame): The audio data to resample. This can be a `bytearray` containing
                raw audio bytes in int16le format or an `AudioFrame` object.

        Returns:
            list[AudioFrame]: A list of `AudioFrame` objects containing the resampled audio data.
                The list may be empty if no output data is available yet.

        Raises:
            Exception: If there is an error during resampling.
        &#34;&#34;&#34;
        bdata = data if isinstance(data, bytearray) else data.data.cast(&#34;b&#34;)

        req = proto_ffi.FfiRequest()
        req.push_sox_resampler.resampler_handle = self._ffi_handle.handle
        req.push_sox_resampler.data_ptr = get_address(memoryview(bdata))
        req.push_sox_resampler.size = len(bdata)

        resp = FfiClient.instance.request(req)

        if resp.push_sox_resampler.error:
            raise Exception(resp.push_sox_resampler.error)

        if not resp.push_sox_resampler.output_ptr:
            return []

        cdata = (ctypes.c_int8 * resp.push_sox_resampler.size).from_address(
            resp.push_sox_resampler.output_ptr
        )
        output_data = bytearray(cdata)
        return [
            AudioFrame(
                output_data,
                self._output_rate,
                self._num_channels,
                len(output_data) // (self._num_channels * ctypes.sizeof(ctypes.c_int16)),
            )
        ]

    def flush(self) -&gt; list[AudioFrame]:
        &#34;&#34;&#34;
        Flush any remaining audio data through the resampler and retrieve the resampled data.

        This method should be called when no more input data will be provided to ensure that all internal
        buffers are processed and all resampled data is output.

        Returns:
            list[AudioFrame]: A list of `AudioFrame` objects containing the remaining resampled audio data after flushing.
                The list may be empty if no output data remains.

        Raises:
            Exception: If there is an error during flushing.
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.flush_sox_resampler.resampler_handle = self._ffi_handle.handle

        resp = FfiClient.instance.request(req)

        if not resp.flush_sox_resampler.output_ptr:
            return []

        cdata = (ctypes.c_int8 * resp.flush_sox_resampler.size).from_address(
            resp.flush_sox_resampler.output_ptr
        )
        output_data = bytearray(cdata)
        return [
            AudioFrame(
                output_data,
                self._output_rate,
                self._num_channels,
                len(output_data) // (self._num_channels * ctypes.sizeof(ctypes.c_int16)),
            )
        ]</code></pre>
</details>
<div class="desc"><p>A class for resampling audio data from one sample rate to another.</p>
<p><code><a title="livekit.rtc.AudioResampler" href="#livekit.rtc.AudioResampler">AudioResampler</a></code> provides functionality to resample audio data from an input sample rate to an output
sample rate using the Sox resampling library. It supports multiple channels and configurable resampling quality.</p>
<p>Initialize an <code><a title="livekit.rtc.AudioResampler" href="#livekit.rtc.AudioResampler">AudioResampler</a></code> instance for resampling audio data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>The sample rate of the input audio data (in Hz).</dd>
<dt><strong><code>output_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>The desired sample rate of the output audio data (in Hz).</dd>
<dt><strong><code>num_channels</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of audio channels (e.g., 1 for mono, 2 for stereo). Defaults to 1.</dd>
<dt><strong><code>quality</code></strong> :&ensp;<code><a title="livekit.rtc.AudioResamplerQuality" href="#livekit.rtc.AudioResamplerQuality">AudioResamplerQuality</a></code>, optional</dt>
<dd>The quality setting for the resampler. Can be one of the
<code><a title="livekit.rtc.AudioResamplerQuality" href="#livekit.rtc.AudioResamplerQuality">AudioResamplerQuality</a></code> enum values: <code>QUICK</code>, <code>LOW</code>, <code>MEDIUM</code>, <code>HIGH</code>, <code>VERY_HIGH</code>. Higher quality settings
result in better audio quality but require more processing power. Defaults to <code><a title="livekit.rtc.AudioResamplerQuality.MEDIUM" href="#livekit.rtc.AudioResamplerQuality.MEDIUM">AudioResamplerQuality.MEDIUM</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If there is an error creating the resampler.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.AudioResampler.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self) ‑> list[<a title="livekit.rtc.audio_frame.AudioFrame" href="audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self) -&gt; list[AudioFrame]:
    &#34;&#34;&#34;
    Flush any remaining audio data through the resampler and retrieve the resampled data.

    This method should be called when no more input data will be provided to ensure that all internal
    buffers are processed and all resampled data is output.

    Returns:
        list[AudioFrame]: A list of `AudioFrame` objects containing the remaining resampled audio data after flushing.
            The list may be empty if no output data remains.

    Raises:
        Exception: If there is an error during flushing.
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.flush_sox_resampler.resampler_handle = self._ffi_handle.handle

    resp = FfiClient.instance.request(req)

    if not resp.flush_sox_resampler.output_ptr:
        return []

    cdata = (ctypes.c_int8 * resp.flush_sox_resampler.size).from_address(
        resp.flush_sox_resampler.output_ptr
    )
    output_data = bytearray(cdata)
    return [
        AudioFrame(
            output_data,
            self._output_rate,
            self._num_channels,
            len(output_data) // (self._num_channels * ctypes.sizeof(ctypes.c_int16)),
        )
    ]</code></pre>
</details>
<div class="desc"><p>Flush any remaining audio data through the resampler and retrieve the resampled data.</p>
<p>This method should be called when no more input data will be provided to ensure that all internal
buffers are processed and all resampled data is output.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a>]</code></dt>
<dd>A list of <code><a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a></code> objects containing the remaining resampled audio data after flushing.
The list may be empty if no output data remains.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If there is an error during flushing.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.AudioResampler.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self,<br>data: bytearray | <a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a>) ‑> list[<a title="livekit.rtc.audio_frame.AudioFrame" href="audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, data: bytearray | AudioFrame) -&gt; list[AudioFrame]:
    &#34;&#34;&#34;
    Push audio data into the resampler and retrieve any available resampled data.

    This method accepts audio data, resamples it according to the configured input and output rates,
    and returns any resampled data that is available after processing the input.

    Args:
        data (bytearray | AudioFrame): The audio data to resample. This can be a `bytearray` containing
            raw audio bytes in int16le format or an `AudioFrame` object.

    Returns:
        list[AudioFrame]: A list of `AudioFrame` objects containing the resampled audio data.
            The list may be empty if no output data is available yet.

    Raises:
        Exception: If there is an error during resampling.
    &#34;&#34;&#34;
    bdata = data if isinstance(data, bytearray) else data.data.cast(&#34;b&#34;)

    req = proto_ffi.FfiRequest()
    req.push_sox_resampler.resampler_handle = self._ffi_handle.handle
    req.push_sox_resampler.data_ptr = get_address(memoryview(bdata))
    req.push_sox_resampler.size = len(bdata)

    resp = FfiClient.instance.request(req)

    if resp.push_sox_resampler.error:
        raise Exception(resp.push_sox_resampler.error)

    if not resp.push_sox_resampler.output_ptr:
        return []

    cdata = (ctypes.c_int8 * resp.push_sox_resampler.size).from_address(
        resp.push_sox_resampler.output_ptr
    )
    output_data = bytearray(cdata)
    return [
        AudioFrame(
            output_data,
            self._output_rate,
            self._num_channels,
            len(output_data) // (self._num_channels * ctypes.sizeof(ctypes.c_int16)),
        )
    ]</code></pre>
</details>
<div class="desc"><p>Push audio data into the resampler and retrieve any available resampled data.</p>
<p>This method accepts audio data, resamples it according to the configured input and output rates,
and returns any resampled data that is available after processing the input.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytearray | AudioFrame</code></dt>
<dd>The audio data to resample. This can be a <code>bytearray</code> containing
raw audio bytes in int16le format or an <code><a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a></code> object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a>]</code></dt>
<dd>A list of <code><a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a></code> objects containing the resampled audio data.
The list may be empty if no output data is available yet.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If there is an error during resampling.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.AudioResamplerQuality"><code class="flex name class">
<span>class <span class="ident">AudioResamplerQuality</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@unique
class AudioResamplerQuality(str, Enum):
    QUICK = &#34;quick&#34;
    LOW = &#34;low&#34;
    MEDIUM = &#34;medium&#34;
    HIGH = &#34;high&#34;
    VERY_HIGH = &#34;very_high&#34;</code></pre>
</details>
<div class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to 'utf-8'.
errors defaults to 'strict'.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.rtc.AudioResamplerQuality.HIGH"><code class="name">var <span class="ident">HIGH</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.AudioResamplerQuality.LOW"><code class="name">var <span class="ident">LOW</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.AudioResamplerQuality.MEDIUM"><code class="name">var <span class="ident">MEDIUM</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.AudioResamplerQuality.QUICK"><code class="name">var <span class="ident">QUICK</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.AudioResamplerQuality.VERY_HIGH"><code class="name">var <span class="ident">VERY_HIGH</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.AudioSource"><code class="flex name class">
<span>class <span class="ident">AudioSource</span></span>
<span>(</span><span>sample_rate: int,<br>num_channels: int,<br>queue_size_ms: int = 1000,<br>loop: asyncio.AbstractEventLoop | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioSource:
    &#34;&#34;&#34;
    Represents a real-time audio source with an internal audio queue.

    The `AudioSource` class allows you to push audio frames into a real-time audio
    source, managing an internal queue of audio data up to a maximum duration defined
    by `queue_size_ms`. It supports asynchronous operations to capture audio frames
    and to wait for the playback of all queued audio data.
    &#34;&#34;&#34;

    def __init__(
        self,
        sample_rate: int,
        num_channels: int,
        queue_size_ms: int = 1000,
        loop: asyncio.AbstractEventLoop | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Initializes a new instance of the audio source.

        Args:
            sample_rate (int): The sample rate of the audio source in Hz.
            num_channels (int): The number of audio channels.
            queue_size_ms (int, optional): The buffer size of the audio queue in milliseconds.
                Defaults to 1000 ms.
            loop (asyncio.AbstractEventLoop, optional): The event loop to use. Defaults to
                `asyncio.get_event_loop()`.
        &#34;&#34;&#34;
        self._sample_rate = sample_rate
        self._num_channels = num_channels
        self._loop = loop or asyncio.get_event_loop()

        req = proto_ffi.FfiRequest()
        req.new_audio_source.type = proto_audio_frame.AudioSourceType.AUDIO_SOURCE_NATIVE
        req.new_audio_source.sample_rate = sample_rate
        req.new_audio_source.num_channels = num_channels
        req.new_audio_source.queue_size_ms = queue_size_ms

        resp = FfiClient.instance.request(req)
        self._info = resp.new_audio_source.source
        self._ffi_handle = FfiHandle(self._info.handle.id)

        self._last_capture = 0.0
        self._q_size = 0.0
        self._join_handle: asyncio.TimerHandle | None = None
        self._join_fut: asyncio.Future[None] | None = None

    @property
    def sample_rate(self) -&gt; int:
        &#34;&#34;&#34;The sample rate of the audio source in Hz.&#34;&#34;&#34;
        return self._sample_rate

    @property
    def num_channels(self) -&gt; int:
        &#34;&#34;&#34;The number of audio channels.&#34;&#34;&#34;
        return self._num_channels

    @property
    def queued_duration(self) -&gt; float:
        &#34;&#34;&#34;The current duration (in seconds) of audio data queued for playback.&#34;&#34;&#34;
        return max(self._q_size - time.monotonic() + self._last_capture, 0.0)

    def clear_queue(self) -&gt; None:
        &#34;&#34;&#34;
        Clears the internal audio queue, discarding all buffered audio data.

        This method immediately removes all audio data currently queued for playback,
        effectively resetting the audio source&#39;s buffer. Any audio frames that have been
        captured but not yet played will be discarded. This is useful in scenarios where
        you need to stop playback abruptly or prevent outdated audio data from being played.
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.clear_audio_buffer.source_handle = self._ffi_handle.handle
        _ = FfiClient.instance.request(req)
        self._release_waiter()

    async def capture_frame(self, frame: AudioFrame) -&gt; None:
        &#34;&#34;&#34;
        Captures an `AudioFrame` and queues it for playback.

        This method is used to push new audio data into the audio source. The audio data
        will be processed and queued. If the size of the audio frame exceeds the internal
        queue size, the method will wait until there is enough space in the queue to
        accommodate the frame. The method returns only when all of the data in the buffer
        has been pushed.

        Args:
            frame (AudioFrame): The audio frame to capture and queue.

        Raises:
            Exception: If there is an error during frame capture.
        &#34;&#34;&#34;

        if frame.samples_per_channel == 0 or self._ffi_handle.disposed:
            return

        now = time.monotonic()
        elapsed = 0.0 if self._last_capture == 0.0 else now - self._last_capture
        self._q_size += frame.samples_per_channel / self.sample_rate - elapsed
        self._last_capture = now

        if self._join_handle:
            self._join_handle.cancel()

        if self._join_fut is None:
            self._join_fut = self._loop.create_future()

        self._join_handle = self._loop.call_later(self._q_size, self._release_waiter)

        req = proto_ffi.FfiRequest()
        req.capture_audio_frame.source_handle = self._ffi_handle.handle
        req.capture_audio_frame.buffer.CopyFrom(frame._proto_info())

        queue = FfiClient.instance.queue.subscribe(loop=self._loop)
        try:
            resp = FfiClient.instance.request(req)
            cb: proto_ffi.FfiEvent = await queue.wait_for(
                lambda e: e.capture_audio_frame.async_id == resp.capture_audio_frame.async_id
            )
        finally:
            FfiClient.instance.queue.unsubscribe(queue)

        if cb.capture_audio_frame.error:
            raise Exception(cb.capture_audio_frame.error)

    async def wait_for_playout(self) -&gt; None:
        &#34;&#34;&#34;
        Waits for the audio source to finish playing out all audio data.

        This method ensures that all queued audio data has been played out before returning.
        It can be used to synchronize events after audio playback or to ensure that the
        audio queue is empty.
        &#34;&#34;&#34;

        if self._join_fut is None:
            return

        await asyncio.shield(self._join_fut)

    def _release_waiter(self) -&gt; None:
        if self._join_fut is None:
            return  # could be None when clear_queue is called

        if not self._join_fut.done():
            self._join_fut.set_result(None)

        self._last_capture = 0.0
        self._q_size = 0.0
        self._join_fut = None

    async def aclose(self) -&gt; None:
        &#34;&#34;&#34;Close the audio source

        This method cleans up resources associated with the audio source.
        &#34;&#34;&#34;
        self._ffi_handle.dispose()</code></pre>
</details>
<div class="desc"><p>Represents a real-time audio source with an internal audio queue.</p>
<p>The <code><a title="livekit.rtc.AudioSource" href="#livekit.rtc.AudioSource">AudioSource</a></code> class allows you to push audio frames into a real-time audio
source, managing an internal queue of audio data up to a maximum duration defined
by <code>queue_size_ms</code>. It supports asynchronous operations to capture audio frames
and to wait for the playback of all queued audio data.</p>
<p>Initializes a new instance of the audio source.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>The sample rate of the audio source in Hz.</dd>
<dt><strong><code>num_channels</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of audio channels.</dd>
<dt><strong><code>queue_size_ms</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The buffer size of the audio queue in milliseconds.
Defaults to 1000 ms.</dd>
<dt><strong><code>loop</code></strong> :&ensp;<code>asyncio.AbstractEventLoop</code>, optional</dt>
<dd>The event loop to use. Defaults to
<code>asyncio.get_event_loop()</code>.</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.AudioSource.num_channels"><code class="name">prop <span class="ident">num_channels</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_channels(self) -&gt; int:
    &#34;&#34;&#34;The number of audio channels.&#34;&#34;&#34;
    return self._num_channels</code></pre>
</details>
<div class="desc"><p>The number of audio channels.</p></div>
</dd>
<dt id="livekit.rtc.AudioSource.queued_duration"><code class="name">prop <span class="ident">queued_duration</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def queued_duration(self) -&gt; float:
    &#34;&#34;&#34;The current duration (in seconds) of audio data queued for playback.&#34;&#34;&#34;
    return max(self._q_size - time.monotonic() + self._last_capture, 0.0)</code></pre>
</details>
<div class="desc"><p>The current duration (in seconds) of audio data queued for playback.</p></div>
</dd>
<dt id="livekit.rtc.AudioSource.sample_rate"><code class="name">prop <span class="ident">sample_rate</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sample_rate(self) -&gt; int:
    &#34;&#34;&#34;The sample rate of the audio source in Hz.&#34;&#34;&#34;
    return self._sample_rate</code></pre>
</details>
<div class="desc"><p>The sample rate of the audio source in Hz.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.AudioSource.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self) -&gt; None:
    &#34;&#34;&#34;Close the audio source

    This method cleans up resources associated with the audio source.
    &#34;&#34;&#34;
    self._ffi_handle.dispose()</code></pre>
</details>
<div class="desc"><p>Close the audio source</p>
<p>This method cleans up resources associated with the audio source.</p></div>
</dd>
<dt id="livekit.rtc.AudioSource.capture_frame"><code class="name flex">
<span>async def <span class="ident">capture_frame</span></span>(<span>self,<br>frame: <a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def capture_frame(self, frame: AudioFrame) -&gt; None:
    &#34;&#34;&#34;
    Captures an `AudioFrame` and queues it for playback.

    This method is used to push new audio data into the audio source. The audio data
    will be processed and queued. If the size of the audio frame exceeds the internal
    queue size, the method will wait until there is enough space in the queue to
    accommodate the frame. The method returns only when all of the data in the buffer
    has been pushed.

    Args:
        frame (AudioFrame): The audio frame to capture and queue.

    Raises:
        Exception: If there is an error during frame capture.
    &#34;&#34;&#34;

    if frame.samples_per_channel == 0 or self._ffi_handle.disposed:
        return

    now = time.monotonic()
    elapsed = 0.0 if self._last_capture == 0.0 else now - self._last_capture
    self._q_size += frame.samples_per_channel / self.sample_rate - elapsed
    self._last_capture = now

    if self._join_handle:
        self._join_handle.cancel()

    if self._join_fut is None:
        self._join_fut = self._loop.create_future()

    self._join_handle = self._loop.call_later(self._q_size, self._release_waiter)

    req = proto_ffi.FfiRequest()
    req.capture_audio_frame.source_handle = self._ffi_handle.handle
    req.capture_audio_frame.buffer.CopyFrom(frame._proto_info())

    queue = FfiClient.instance.queue.subscribe(loop=self._loop)
    try:
        resp = FfiClient.instance.request(req)
        cb: proto_ffi.FfiEvent = await queue.wait_for(
            lambda e: e.capture_audio_frame.async_id == resp.capture_audio_frame.async_id
        )
    finally:
        FfiClient.instance.queue.unsubscribe(queue)

    if cb.capture_audio_frame.error:
        raise Exception(cb.capture_audio_frame.error)</code></pre>
</details>
<div class="desc"><p>Captures an <code><a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a></code> and queues it for playback.</p>
<p>This method is used to push new audio data into the audio source. The audio data
will be processed and queued. If the size of the audio frame exceeds the internal
queue size, the method will wait until there is enough space in the queue to
accommodate the frame. The method returns only when all of the data in the buffer
has been pushed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frame</code></strong> :&ensp;<code><a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a></code></dt>
<dd>The audio frame to capture and queue.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If there is an error during frame capture.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.AudioSource.clear_queue"><code class="name flex">
<span>def <span class="ident">clear_queue</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_queue(self) -&gt; None:
    &#34;&#34;&#34;
    Clears the internal audio queue, discarding all buffered audio data.

    This method immediately removes all audio data currently queued for playback,
    effectively resetting the audio source&#39;s buffer. Any audio frames that have been
    captured but not yet played will be discarded. This is useful in scenarios where
    you need to stop playback abruptly or prevent outdated audio data from being played.
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.clear_audio_buffer.source_handle = self._ffi_handle.handle
    _ = FfiClient.instance.request(req)
    self._release_waiter()</code></pre>
</details>
<div class="desc"><p>Clears the internal audio queue, discarding all buffered audio data.</p>
<p>This method immediately removes all audio data currently queued for playback,
effectively resetting the audio source's buffer. Any audio frames that have been
captured but not yet played will be discarded. This is useful in scenarios where
you need to stop playback abruptly or prevent outdated audio data from being played.</p></div>
</dd>
<dt id="livekit.rtc.AudioSource.wait_for_playout"><code class="name flex">
<span>async def <span class="ident">wait_for_playout</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_playout(self) -&gt; None:
    &#34;&#34;&#34;
    Waits for the audio source to finish playing out all audio data.

    This method ensures that all queued audio data has been played out before returning.
    It can be used to synchronize events after audio playback or to ensure that the
    audio queue is empty.
    &#34;&#34;&#34;

    if self._join_fut is None:
        return

    await asyncio.shield(self._join_fut)</code></pre>
</details>
<div class="desc"><p>Waits for the audio source to finish playing out all audio data.</p>
<p>This method ensures that all queued audio data has been played out before returning.
It can be used to synchronize events after audio playback or to ensure that the
audio queue is empty.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.AudioStream"><code class="flex name class">
<span>class <span class="ident">AudioStream</span></span>
<span>(</span><span>track: <a title="livekit.rtc.Track" href="#livekit.rtc.Track">Track</a>,<br>loop: Optional[asyncio.AbstractEventLoop] = None,<br>capacity: int = 0,<br>sample_rate: int = 48000,<br>num_channels: int = 1,<br>noise_cancellation: Optional[<a title="livekit.rtc.NoiseCancellationOptions" href="#livekit.rtc.NoiseCancellationOptions">NoiseCancellationOptions</a>] = None,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioStream:
    &#34;&#34;&#34;An asynchronous audio stream for receiving audio frames from a participant or track.

    The `AudioStream` class provides an asynchronous iterator over audio frames received from
    a specific track or participant. It allows you to receive audio frames in real-time with
    customizable sample rates and channel configurations.
    &#34;&#34;&#34;

    def __init__(
        self,
        track: Track,
        loop: Optional[asyncio.AbstractEventLoop] = None,
        capacity: int = 0,
        sample_rate: int = 48000,
        num_channels: int = 1,
        noise_cancellation: Optional[NoiseCancellationOptions] = None,
        **kwargs,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize an `AudioStream` instance.

        Args:
            track (Optional[Track]): The audio track from which to receive audio. If not provided,
                you must specify `participant` and `track_source` in `kwargs`.
            loop (Optional[asyncio.AbstractEventLoop], optional): The event loop to use.
                Defaults to the current event loop.
            capacity (int, optional): The capacity of the internal frame queue. Defaults to 0 (unbounded).
            sample_rate (int, optional): The sample rate for the audio stream in Hz.
                Defaults to 48000.
            num_channels (int, optional): The number of audio channels. Defaults to 1.
            noise_cancellation (Optional[NoiseCancellationOptions], optional):
                If noise cancellation is used, pass a `NoiseCancellationOptions` instance
                created by the noise cancellation module.

        Example:
            ```python
            audio_stream = AudioStream(
                track=audio_track,
                sample_rate=44100,
                num_channels=2,
            )

            audio_stream = AudioStream.from_track(
                track=audio_track,
                sample_rate=44100,
                num_channels=2,
            )
            ```
        &#34;&#34;&#34;
        self._track: Track | None = track
        self._sample_rate = sample_rate
        self._num_channels = num_channels
        self._loop = loop or asyncio.get_event_loop()
        self._ffi_queue = FfiClient.instance.queue.subscribe(self._loop)
        self._queue: RingQueue[AudioFrameEvent | None] = RingQueue(capacity)

        self._audio_filter_module = None
        self._audio_filter_options = None
        if noise_cancellation is not None:
            self._audio_filter_module = noise_cancellation.module_id
            self._audio_filter_options = noise_cancellation.options
        self._task = self._loop.create_task(self._run())
        self._task.add_done_callback(task_done_logger)

        stream: Any = None
        if &#34;participant&#34; in kwargs:
            stream = self._create_owned_stream_from_participant(
                participant=kwargs[&#34;participant&#34;], track_source=kwargs[&#34;track_source&#34;]
            )
        else:
            stream = self._create_owned_stream()
        self._ffi_handle = FfiHandle(stream.handle.id)
        self._info = stream.info

    @classmethod
    def from_participant(
        cls,
        *,
        participant: Participant,
        track_source: TrackSource.ValueType,
        loop: Optional[asyncio.AbstractEventLoop] = None,
        capacity: int = 0,
        sample_rate: int = 48000,
        num_channels: int = 1,
        noise_cancellation: Optional[NoiseCancellationOptions] = None,
    ) -&gt; AudioStream:
        &#34;&#34;&#34;Create an `AudioStream` from a participant&#39;s audio track.

        Args:
            participant (Participant): The participant from whom to receive audio.
            track_source (TrackSource.ValueType): The source of the audio track (e.g., microphone, screen share).
            loop (Optional[asyncio.AbstractEventLoop], optional): The event loop to use. Defaults to the current event loop.
            capacity (int, optional): The capacity of the internal frame queue. Defaults to 0 (unbounded).
            sample_rate (int, optional): The sample rate for the audio stream in Hz. Defaults to 48000.
            num_channels (int, optional): The number of audio channels. Defaults to 1.
            noise_cancellation (Optional[NoiseCancellationOptions], optional):
                If noise cancellation is used, pass a `NoiseCancellationOptions` instance
                created by the noise cancellation module.

        Returns:
            AudioStream: An instance of `AudioStream` that can be used to receive audio frames.

        Example:
            ```python
            audio_stream = AudioStream.from_participant(
                participant=participant,
                track_source=TrackSource.MICROPHONE,
                sample_rate=24000,
                num_channels=1,
            )
            ```
        &#34;&#34;&#34;
        return AudioStream(
            participant=participant,
            track_source=track_source,
            loop=loop,
            capacity=capacity,
            track=None,  # type: ignore
            sample_rate=sample_rate,
            num_channels=num_channels,
            noise_cancellation=noise_cancellation,
        )

    @classmethod
    def from_track(
        cls,
        *,
        track: Track,
        loop: Optional[asyncio.AbstractEventLoop] = None,
        capacity: int = 0,
        sample_rate: int = 48000,
        num_channels: int = 1,
        noise_cancellation: Optional[NoiseCancellationOptions] = None,
    ) -&gt; AudioStream:
        &#34;&#34;&#34;Create an `AudioStream` from an existing audio track.

        Args:
            track (Track): The audio track from which to receive audio.
            loop (Optional[asyncio.AbstractEventLoop], optional): The event loop to use. Defaults to the current event loop.
            capacity (int, optional): The capacity of the internal frame queue. Defaults to 0 (unbounded).
            sample_rate (int, optional): The sample rate for the audio stream in Hz. Defaults to 48000.
            num_channels (int, optional): The number of audio channels. Defaults to 1.
            noise_cancellation (Optional[NoiseCancellationOptions], optional):
                If noise cancellation is used, pass a `NoiseCancellationOptions` instance
                created by the noise cancellation module.

        Returns:
            AudioStream: An instance of `AudioStream` that can be used to receive audio frames.

        Example:
            ```python
            audio_stream = AudioStream.from_track(
                track=audio_track,
                sample_rate=44100,
                num_channels=2,
            )
            ```
        &#34;&#34;&#34;
        return AudioStream(
            track=track,
            loop=loop,
            capacity=capacity,
            sample_rate=sample_rate,
            num_channels=num_channels,
            noise_cancellation=noise_cancellation,
        )

    def __del__(self) -&gt; None:
        FfiClient.instance.queue.unsubscribe(self._ffi_queue)

    def _create_owned_stream(self) -&gt; Any:
        assert self._track is not None
        req = proto_ffi.FfiRequest()
        new_audio_stream = req.new_audio_stream
        new_audio_stream.track_handle = self._track._ffi_handle.handle
        new_audio_stream.sample_rate = self._sample_rate
        new_audio_stream.num_channels = self._num_channels
        new_audio_stream.type = proto_audio_frame.AudioStreamType.AUDIO_STREAM_NATIVE
        if self._audio_filter_module is not None:
            new_audio_stream.audio_filter_module_id = self._audio_filter_module
        if self._audio_filter_options is not None:
            new_audio_stream.audio_filter_options = json.dumps(self._audio_filter_options)
        resp = FfiClient.instance.request(req)
        return resp.new_audio_stream.stream

    def _create_owned_stream_from_participant(
        self, participant: Participant, track_source: TrackSource.ValueType
    ) -&gt; Any:
        req = proto_ffi.FfiRequest()
        audio_stream_from_participant = req.audio_stream_from_participant
        audio_stream_from_participant.participant_handle = participant._ffi_handle.handle
        audio_stream_from_participant.sample_rate = self._sample_rate
        audio_stream_from_participant.num_channels = self._num_channels
        audio_stream_from_participant.type = proto_audio_frame.AudioStreamType.AUDIO_STREAM_NATIVE
        audio_stream_from_participant.track_source = track_source
        if self._audio_filter_module is not None:
            audio_stream_from_participant.audio_filter_module_id = self._audio_filter_module
        if self._audio_filter_options is not None:
            audio_stream_from_participant.audio_filter_options = json.dumps(
                self._audio_filter_options
            )
        resp = FfiClient.instance.request(req)
        return resp.audio_stream_from_participant.stream

    async def _run(self):
        while True:
            event = await self._ffi_queue.wait_for(self._is_event)
            audio_event: proto_audio_frame.AudioStreamEvent = event.audio_stream_event

            if audio_event.HasField(&#34;frame_received&#34;):
                owned_buffer_info = audio_event.frame_received.frame
                frame = AudioFrame._from_owned_info(owned_buffer_info)
                event = AudioFrameEvent(frame)
                self._queue.put(event)
            elif audio_event.HasField(&#34;eos&#34;):
                self._queue.put(None)
                break

        FfiClient.instance.queue.unsubscribe(self._ffi_queue)

    async def aclose(self) -&gt; None:
        &#34;&#34;&#34;Asynchronously close the audio stream.

        This method cleans up resources associated with the audio stream and waits for
        any pending operations to complete.
        &#34;&#34;&#34;
        self._ffi_handle.dispose()
        await self._task

    def _is_event(self, e: proto_ffi.FfiEvent) -&gt; bool:
        return e.audio_stream_event.stream_handle == self._ffi_handle.handle

    def __aiter__(self) -&gt; AsyncIterator[AudioFrameEvent]:
        return self

    async def __anext__(self) -&gt; AudioFrameEvent:
        if self._task.done():
            raise StopAsyncIteration

        item = await self._queue.get()
        if item is None:
            raise StopAsyncIteration

        return item</code></pre>
</details>
<div class="desc"><p>An asynchronous audio stream for receiving audio frames from a participant or track.</p>
<p>The <code><a title="livekit.rtc.AudioStream" href="#livekit.rtc.AudioStream">AudioStream</a></code> class provides an asynchronous iterator over audio frames received from
a specific track or participant. It allows you to receive audio frames in real-time with
customizable sample rates and channel configurations.</p>
<p>Initialize an <code><a title="livekit.rtc.AudioStream" href="#livekit.rtc.AudioStream">AudioStream</a></code> instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>track</code></strong> :&ensp;<code>Optional[<a title="livekit.rtc.Track" href="#livekit.rtc.Track">Track</a>]</code></dt>
<dd>The audio track from which to receive audio. If not provided,
you must specify <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> and <code>track_source</code> in <code>kwargs</code>.</dd>
<dt><strong><code>loop</code></strong> :&ensp;<code>Optional[asyncio.AbstractEventLoop]</code>, optional</dt>
<dd>The event loop to use.
Defaults to the current event loop.</dd>
<dt><strong><code>capacity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The capacity of the internal frame queue. Defaults to 0 (unbounded).</dd>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The sample rate for the audio stream in Hz.
Defaults to 48000.</dd>
<dt><strong><code>num_channels</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of audio channels. Defaults to 1.</dd>
</dl>
<p>noise_cancellation (Optional[NoiseCancellationOptions], optional):
If noise cancellation is used, pass a <code><a title="livekit.rtc.NoiseCancellationOptions" href="#livekit.rtc.NoiseCancellationOptions">NoiseCancellationOptions</a></code> instance
created by the noise cancellation module.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">audio_stream = AudioStream(
    track=audio_track,
    sample_rate=44100,
    num_channels=2,
)

audio_stream = AudioStream.from_track(
    track=audio_track,
    sample_rate=44100,
    num_channels=2,
)
</code></pre></div>
<h3>Static methods</h3>
<dl>
<dt id="livekit.rtc.AudioStream.from_participant"><code class="name flex">
<span>def <span class="ident">from_participant</span></span>(<span>*,<br>participant: <a title="livekit.rtc.Participant" href="#livekit.rtc.Participant">Participant</a>,<br>track_source: TrackSource.ValueType,<br>loop: Optional[asyncio.AbstractEventLoop] = None,<br>capacity: int = 0,<br>sample_rate: int = 48000,<br>num_channels: int = 1,<br>noise_cancellation: Optional[<a title="livekit.rtc.NoiseCancellationOptions" href="#livekit.rtc.NoiseCancellationOptions">NoiseCancellationOptions</a>] = None) ‑> <a title="livekit.rtc.audio_stream.AudioStream" href="audio_stream.html#livekit.rtc.audio_stream.AudioStream">AudioStream</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an <code><a title="livekit.rtc.AudioStream" href="#livekit.rtc.AudioStream">AudioStream</a></code> from a participant's audio track.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>participant</code></strong> :&ensp;<code><a title="livekit.rtc.Participant" href="#livekit.rtc.Participant">Participant</a></code></dt>
<dd>The participant from whom to receive audio.</dd>
<dt><strong><code>track_source</code></strong> :&ensp;<code>TrackSource.ValueType</code></dt>
<dd>The source of the audio track (e.g., microphone, screen share).</dd>
<dt><strong><code>loop</code></strong> :&ensp;<code>Optional[asyncio.AbstractEventLoop]</code>, optional</dt>
<dd>The event loop to use. Defaults to the current event loop.</dd>
<dt><strong><code>capacity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The capacity of the internal frame queue. Defaults to 0 (unbounded).</dd>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The sample rate for the audio stream in Hz. Defaults to 48000.</dd>
<dt><strong><code>num_channels</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of audio channels. Defaults to 1.</dd>
</dl>
<p>noise_cancellation (Optional[NoiseCancellationOptions], optional):
If noise cancellation is used, pass a <code><a title="livekit.rtc.NoiseCancellationOptions" href="#livekit.rtc.NoiseCancellationOptions">NoiseCancellationOptions</a></code> instance
created by the noise cancellation module.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="livekit.rtc.AudioStream" href="#livekit.rtc.AudioStream">AudioStream</a></code></dt>
<dd>An instance of <code><a title="livekit.rtc.AudioStream" href="#livekit.rtc.AudioStream">AudioStream</a></code> that can be used to receive audio frames.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">audio_stream = AudioStream.from_participant(
    participant=participant,
    track_source=TrackSource.MICROPHONE,
    sample_rate=24000,
    num_channels=1,
)
</code></pre></div>
</dd>
<dt id="livekit.rtc.AudioStream.from_track"><code class="name flex">
<span>def <span class="ident">from_track</span></span>(<span>*,<br>track: <a title="livekit.rtc.Track" href="#livekit.rtc.Track">Track</a>,<br>loop: Optional[asyncio.AbstractEventLoop] = None,<br>capacity: int = 0,<br>sample_rate: int = 48000,<br>num_channels: int = 1,<br>noise_cancellation: Optional[<a title="livekit.rtc.NoiseCancellationOptions" href="#livekit.rtc.NoiseCancellationOptions">NoiseCancellationOptions</a>] = None) ‑> <a title="livekit.rtc.audio_stream.AudioStream" href="audio_stream.html#livekit.rtc.audio_stream.AudioStream">AudioStream</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an <code><a title="livekit.rtc.AudioStream" href="#livekit.rtc.AudioStream">AudioStream</a></code> from an existing audio track.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>track</code></strong> :&ensp;<code><a title="livekit.rtc.Track" href="#livekit.rtc.Track">Track</a></code></dt>
<dd>The audio track from which to receive audio.</dd>
<dt><strong><code>loop</code></strong> :&ensp;<code>Optional[asyncio.AbstractEventLoop]</code>, optional</dt>
<dd>The event loop to use. Defaults to the current event loop.</dd>
<dt><strong><code>capacity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The capacity of the internal frame queue. Defaults to 0 (unbounded).</dd>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The sample rate for the audio stream in Hz. Defaults to 48000.</dd>
<dt><strong><code>num_channels</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of audio channels. Defaults to 1.</dd>
</dl>
<p>noise_cancellation (Optional[NoiseCancellationOptions], optional):
If noise cancellation is used, pass a <code><a title="livekit.rtc.NoiseCancellationOptions" href="#livekit.rtc.NoiseCancellationOptions">NoiseCancellationOptions</a></code> instance
created by the noise cancellation module.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="livekit.rtc.AudioStream" href="#livekit.rtc.AudioStream">AudioStream</a></code></dt>
<dd>An instance of <code><a title="livekit.rtc.AudioStream" href="#livekit.rtc.AudioStream">AudioStream</a></code> that can be used to receive audio frames.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">audio_stream = AudioStream.from_track(
    track=audio_track,
    sample_rate=44100,
    num_channels=2,
)
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.AudioStream.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self) -&gt; None:
    &#34;&#34;&#34;Asynchronously close the audio stream.

    This method cleans up resources associated with the audio stream and waits for
    any pending operations to complete.
    &#34;&#34;&#34;
    self._ffi_handle.dispose()
    await self._task</code></pre>
</details>
<div class="desc"><p>Asynchronously close the audio stream.</p>
<p>This method cleans up resources associated with the audio stream and waits for
any pending operations to complete.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.ByteStreamInfo"><code class="flex name class">
<span>class <span class="ident">ByteStreamInfo</span></span>
<span>(</span><span>stream_id: str,<br>mime_type: str,<br>topic: str,<br>timestamp: int,<br>size: Optional[int],<br>attributes: Optional[Dict[str, str]],<br>name: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ByteStreamInfo(BaseStreamInfo):
    name: str</code></pre>
</details>
<div class="desc"><p>ByteStreamInfo(stream_id: 'str', mime_type: 'str', topic: 'str', timestamp: 'int', size: 'Optional[int]', attributes: 'Optional[Dict[str, str]]', name: 'str')</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.data_stream.BaseStreamInfo" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo">BaseStreamInfo</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.ByteStreamInfo.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livekit.rtc.data_stream.BaseStreamInfo" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo">BaseStreamInfo</a></b></code>:
<ul class="hlist">
<li><code><a title="livekit.rtc.data_stream.BaseStreamInfo.attributes" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo.attributes">attributes</a></code></li>
<li><code><a title="livekit.rtc.data_stream.BaseStreamInfo.mime_type" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo.mime_type">mime_type</a></code></li>
<li><code><a title="livekit.rtc.data_stream.BaseStreamInfo.size" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo.size">size</a></code></li>
<li><code><a title="livekit.rtc.data_stream.BaseStreamInfo.stream_id" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo.stream_id">stream_id</a></code></li>
<li><code><a title="livekit.rtc.data_stream.BaseStreamInfo.timestamp" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo.timestamp">timestamp</a></code></li>
<li><code><a title="livekit.rtc.data_stream.BaseStreamInfo.topic" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo.topic">topic</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livekit.rtc.ByteStreamReader"><code class="flex name class">
<span>class <span class="ident">ByteStreamReader</span></span>
<span>(</span><span>header: proto_DataStream.Header, capacity: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ByteStreamReader:
    def __init__(self, header: proto_DataStream.Header, capacity: int = 0) -&gt; None:
        self._header = header
        self._info = ByteStreamInfo(
            stream_id=header.stream_id,
            mime_type=header.mime_type,
            topic=header.topic,
            timestamp=header.timestamp,
            size=header.total_length,
            attributes=dict(header.attributes),
            name=header.byte_header.name,
        )
        self._queue: asyncio.Queue[proto_DataStream.Chunk | None] = asyncio.Queue(capacity)

    async def _on_chunk_update(self, chunk: proto_DataStream.Chunk):
        await self._queue.put(chunk)

    async def _on_stream_close(self, trailer: proto_DataStream.Trailer):
        self.info.attributes = self.info.attributes or {}
        self.info.attributes.update(trailer.attributes)
        await self._queue.put(None)

    def __aiter__(self) -&gt; AsyncIterator[bytes]:
        return self

    async def __anext__(self) -&gt; bytes:
        item = await self._queue.get()
        if item is None:
            raise StopAsyncIteration

        return item.content

    @property
    def info(self) -&gt; ByteStreamInfo:
        return self._info</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.ByteStreamReader.info"><code class="name">prop <span class="ident">info</span> : <a title="livekit.rtc.ByteStreamInfo" href="#livekit.rtc.ByteStreamInfo">ByteStreamInfo</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def info(self) -&gt; ByteStreamInfo:
    return self._info</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.ByteStreamWriter"><code class="flex name class">
<span>class <span class="ident">ByteStreamWriter</span></span>
<span>(</span><span>local_participant: <a title="livekit.rtc.LocalParticipant" href="#livekit.rtc.LocalParticipant">LocalParticipant</a>,<br>*,<br>name: str,<br>topic: str = '',<br>attributes: Optional[Dict[str, str]] = None,<br>stream_id: str | None = None,<br>total_size: int | None = None,<br>mime_type: str = 'application/octet-stream',<br>destination_identities: Optional[List[str]] = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ByteStreamWriter(BaseStreamWriter):
    def __init__(
        self,
        local_participant: LocalParticipant,
        *,
        name: str,
        topic: str = &#34;&#34;,
        attributes: Optional[Dict[str, str]] = None,
        stream_id: str | None = None,
        total_size: int | None = None,
        mime_type: str = &#34;application/octet-stream&#34;,
        destination_identities: Optional[List[str]] = None,
    ) -&gt; None:
        super().__init__(
            local_participant,
            topic,
            attributes,
            stream_id,
            total_size,
            mime_type=mime_type,
            destination_identities=destination_identities,
        )
        self._header.byte_header.name = name
        self._info = ByteStreamInfo(
            stream_id=self._header.stream_id,
            mime_type=self._header.mime_type,
            topic=self._header.topic,
            timestamp=self._header.timestamp,
            size=self._header.total_length,
            attributes=dict(self._header.attributes),
            name=self._header.byte_header.name,
        )
        self._write_lock = asyncio.Lock()

    async def write(self, data: bytes):
        async with self._write_lock:
            chunked_data = [
                data[i : i + STREAM_CHUNK_SIZE] for i in range(0, len(data), STREAM_CHUNK_SIZE)
            ]

            for chunk in chunked_data:
                self._next_chunk_index += 1
                chunk_msg = proto_DataStream.Chunk(
                    stream_id=self._header.stream_id,
                    chunk_index=self._next_chunk_index,
                    content=chunk,
                )
                await self._send_chunk(chunk_msg)

    @property
    def info(self) -&gt; ByteStreamInfo:
        return self._info</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.data_stream.BaseStreamWriter" href="data_stream.html#livekit.rtc.data_stream.BaseStreamWriter">BaseStreamWriter</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.ByteStreamWriter.info"><code class="name">prop <span class="ident">info</span> : <a title="livekit.rtc.ByteStreamInfo" href="#livekit.rtc.ByteStreamInfo">ByteStreamInfo</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def info(self) -&gt; ByteStreamInfo:
    return self._info</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.ByteStreamWriter.write"><code class="name flex">
<span>async def <span class="ident">write</span></span>(<span>self, data: bytes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def write(self, data: bytes):
    async with self._write_lock:
        chunked_data = [
            data[i : i + STREAM_CHUNK_SIZE] for i in range(0, len(data), STREAM_CHUNK_SIZE)
        ]

        for chunk in chunked_data:
            self._next_chunk_index += 1
            chunk_msg = proto_DataStream.Chunk(
                stream_id=self._header.stream_id,
                chunk_index=self._next_chunk_index,
                content=chunk,
            )
            await self._send_chunk(chunk_msg)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.ConnectError"><code class="flex name class">
<span>class <span class="ident">ConnectError</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConnectError(Exception):
    def __init__(self, message: str):
        self.message = message</code></pre>
</details>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="livekit.rtc.DataPacket"><code class="flex name class">
<span>class <span class="ident">DataPacket</span></span>
<span>(</span><span>data: bytes,<br>kind: proto_room.DataPacketKind.ValueType,<br>participant: <a title="livekit.rtc.RemoteParticipant" href="#livekit.rtc.RemoteParticipant">RemoteParticipant</a> | None,<br>topic: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class DataPacket:
    data: bytes
    &#34;&#34;&#34;The payload of the data packet.&#34;&#34;&#34;
    kind: proto_room.DataPacketKind.ValueType
    &#34;&#34;&#34;Type of the data packet (e.g., RELIABLE, LOSSY).&#34;&#34;&#34;
    participant: RemoteParticipant | None
    &#34;&#34;&#34;Participant who sent the data. None when sent by a server SDK.&#34;&#34;&#34;
    topic: str | None = None
    &#34;&#34;&#34;Topic associated with the data packet.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>DataPacket(data: 'bytes', kind: 'proto_room.DataPacketKind.ValueType', participant: 'RemoteParticipant | None', topic: 'str | None' = None)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.DataPacket.data"><code class="name">var <span class="ident">data</span> : bytes</code></dt>
<dd>
<div class="desc"><p>The payload of the data packet.</p></div>
</dd>
<dt id="livekit.rtc.DataPacket.kind"><code class="name">var <span class="ident">kind</span> : int</code></dt>
<dd>
<div class="desc"><p>Type of the data packet (e.g., RELIABLE, LOSSY).</p></div>
</dd>
<dt id="livekit.rtc.DataPacket.participant"><code class="name">var <span class="ident">participant</span> : <a title="livekit.rtc.participant.RemoteParticipant" href="participant.html#livekit.rtc.participant.RemoteParticipant">RemoteParticipant</a> | None</code></dt>
<dd>
<div class="desc"><p>Participant who sent the data. None when sent by a server SDK.</p></div>
</dd>
<dt id="livekit.rtc.DataPacket.topic"><code class="name">var <span class="ident">topic</span> : str | None</code></dt>
<dd>
<div class="desc"><p>Topic associated with the data packet.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.E2EEManager"><code class="flex name class">
<span>class <span class="ident">E2EEManager</span></span>
<span>(</span><span>room_handle: int,<br>options: <a title="livekit.rtc.e2ee.E2EEOptions" href="e2ee.html#livekit.rtc.e2ee.E2EEOptions">E2EEOptions</a> | None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class E2EEManager:
    def __init__(self, room_handle: int, options: Optional[E2EEOptions]):
        self.options = options
        self._room_handle = room_handle
        self._enabled = options is not None

        if options is not None:
            self._key_provider = KeyProvider(self._room_handle, options.key_provider_options)

    @property
    def key_provider(self) -&gt; Optional[KeyProvider]:
        return self._key_provider

    @property
    def enabled(self) -&gt; bool:
        return self._enabled

    def set_enabled(self, enabled: bool) -&gt; None:
        &#34;&#34;&#34;Enables or disables end-to-end encryption.

        Parameters:
            enabled (bool): True to enable, False to disable.

        Example:
            ```python
            e2ee_manager.set_enabled(True)
            ```
        &#34;&#34;&#34;
        self._enabled = enabled
        req = proto_ffi.FfiRequest()
        req.e2ee.room_handle = self._room_handle
        req.e2ee.manager_set_enabled.enabled = enabled
        FfiClient.instance.request(req)

    def frame_cryptors(self) -&gt; List[FrameCryptor]:
        &#34;&#34;&#34;Retrieves the list of frame cryptors for participants.

        Returns:
            List[FrameCryptor]: A list of FrameCryptor instances.

        Example:
            ```python
            cryptors = e2ee_manager.frame_cryptors()
            for cryptor in cryptors:
                print(cryptor.participant_identity)
            ```
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.e2ee.room_handle = self._room_handle

        resp = FfiClient.instance.request(req)
        frame_cryptors = []
        for frame_cryptor in resp.e2ee.manager_get_frame_cryptors.frame_cryptors:
            frame_cryptors.append(
                FrameCryptor(
                    self._room_handle,
                    frame_cryptor.participant_identity,
                    frame_cryptor.key_index,
                    frame_cryptor.enabled,
                )
            )
        return frame_cryptors</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.E2EEManager.enabled"><code class="name">prop <span class="ident">enabled</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def enabled(self) -&gt; bool:
    return self._enabled</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.E2EEManager.key_provider"><code class="name">prop <span class="ident">key_provider</span> : <a title="livekit.rtc.e2ee.KeyProvider" href="e2ee.html#livekit.rtc.e2ee.KeyProvider">KeyProvider</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def key_provider(self) -&gt; Optional[KeyProvider]:
    return self._key_provider</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.E2EEManager.frame_cryptors"><code class="name flex">
<span>def <span class="ident">frame_cryptors</span></span>(<span>self) ‑> List[<a title="livekit.rtc.e2ee.FrameCryptor" href="e2ee.html#livekit.rtc.e2ee.FrameCryptor">FrameCryptor</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frame_cryptors(self) -&gt; List[FrameCryptor]:
    &#34;&#34;&#34;Retrieves the list of frame cryptors for participants.

    Returns:
        List[FrameCryptor]: A list of FrameCryptor instances.

    Example:
        ```python
        cryptors = e2ee_manager.frame_cryptors()
        for cryptor in cryptors:
            print(cryptor.participant_identity)
        ```
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.e2ee.room_handle = self._room_handle

    resp = FfiClient.instance.request(req)
    frame_cryptors = []
    for frame_cryptor in resp.e2ee.manager_get_frame_cryptors.frame_cryptors:
        frame_cryptors.append(
            FrameCryptor(
                self._room_handle,
                frame_cryptor.participant_identity,
                frame_cryptor.key_index,
                frame_cryptor.enabled,
            )
        )
    return frame_cryptors</code></pre>
</details>
<div class="desc"><p>Retrieves the list of frame cryptors for participants.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="livekit.rtc.FrameCryptor" href="#livekit.rtc.FrameCryptor">FrameCryptor</a>]</code></dt>
<dd>A list of FrameCryptor instances.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">cryptors = e2ee_manager.frame_cryptors()
for cryptor in cryptors:
    print(cryptor.participant_identity)
</code></pre></div>
</dd>
<dt id="livekit.rtc.E2EEManager.set_enabled"><code class="name flex">
<span>def <span class="ident">set_enabled</span></span>(<span>self, enabled: bool) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enabled(self, enabled: bool) -&gt; None:
    &#34;&#34;&#34;Enables or disables end-to-end encryption.

    Parameters:
        enabled (bool): True to enable, False to disable.

    Example:
        ```python
        e2ee_manager.set_enabled(True)
        ```
    &#34;&#34;&#34;
    self._enabled = enabled
    req = proto_ffi.FfiRequest()
    req.e2ee.room_handle = self._room_handle
    req.e2ee.manager_set_enabled.enabled = enabled
    FfiClient.instance.request(req)</code></pre>
</details>
<div class="desc"><p>Enables or disables end-to-end encryption.</p>
<h2 id="parameters">Parameters</h2>
<p>enabled (bool): True to enable, False to disable.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">e2ee_manager.set_enabled(True)
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.E2EEOptions"><code class="flex name class">
<span>class <span class="ident">E2EEOptions</span></span>
<span>(</span><span>key_provider_options: <a title="livekit.rtc.e2ee.KeyProviderOptions" href="e2ee.html#livekit.rtc.e2ee.KeyProviderOptions">KeyProviderOptions</a> = &lt;factory&gt;,<br>encryption_type: int = 1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class E2EEOptions:
    key_provider_options: KeyProviderOptions = field(default_factory=KeyProviderOptions)
    encryption_type: proto_e2ee.EncryptionType.ValueType = proto_e2ee.EncryptionType.GCM</code></pre>
</details>
<div class="desc"><p>E2EEOptions(key_provider_options: livekit.rtc.e2ee.KeyProviderOptions = <factory>, encryption_type: int = 1)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.E2EEOptions.encryption_type"><code class="name">var <span class="ident">encryption_type</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.E2EEOptions.key_provider_options"><code class="name">var <span class="ident">key_provider_options</span> : <a title="livekit.rtc.e2ee.KeyProviderOptions" href="e2ee.html#livekit.rtc.e2ee.KeyProviderOptions">KeyProviderOptions</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.EventEmitter"><code class="flex name class">
<span>class <span class="ident">EventEmitter</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventEmitter(Generic[T_contra]):
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Initialize a new instance of EventEmitter.
        &#34;&#34;&#34;
        self._events: Dict[T_contra, Set[Callable]] = dict()

    def emit(self, event: T_contra, *args) -&gt; None:
        &#34;&#34;&#34;
        Trigger all callbacks associated with the given event.

        Args:
            event (T): The event to emit.
            *args: Positional arguments to pass to the callbacks.

        Example:
            Basic usage of emit:

            ```python
            emitter = EventEmitter[str]()

            def greet(name):
                print(f&#34;Hello, {name}!&#34;)

            emitter.on(&#39;greet&#39;, greet)
            emitter.emit(&#39;greet&#39;, &#39;Alice&#39;)  # Output: Hello, Alice!
            ```
        &#34;&#34;&#34;
        if event in self._events:
            callables = self._events[event].copy()
            for callback in callables:
                try:
                    sig = inspect.signature(callback)
                    params = sig.parameters.values()

                    has_varargs = any(p.kind == p.VAR_POSITIONAL for p in params)
                    if has_varargs:
                        callback(*args)
                    else:
                        positional_params = [
                            p
                            for p in params
                            if p.kind in (p.POSITIONAL_ONLY, p.POSITIONAL_OR_KEYWORD)
                        ]
                        num_params = len(positional_params)
                        num_args = min(len(args), num_params)
                        callback_args = args[:num_args]

                        callback(*callback_args)
                except TypeError:
                    raise
                except Exception:
                    logger.exception(f&#34;failed to emit event {event}&#34;)

    def once(self, event: T_contra, callback: Optional[Callable] = None) -&gt; Callable:
        &#34;&#34;&#34;
        Register a callback to be called only once when the event is emitted.

        If a callback is provided, it registers the callback directly.
        If no callback is provided, it returns a decorator for use with function definitions.

        Args:
            event (T): The event to listen for.
            callback (Callable, optional): The callback to register. Defaults to None.

        Returns:
            Callable: The registered callback or a decorator if callback is None.

        Example:
            Using once with a direct callback:

            ```python
            emitter = EventEmitter[str]()

            def greet_once(name):
                print(f&#34;Hello once, {name}!&#34;)

            emitter.once(&#39;greet&#39;, greet_once)
            emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # Output: Hello once, Bob!
            emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # No output, callback was removed after first call
            ```

            Using once as a decorator:

            ```python
            emitter = EventEmitter[str]()

            @emitter.once(&#39;greet&#39;)
            def greet_once(name):
                print(f&#34;Hello once, {name}!&#34;)

            emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # Output: Hello once, Bob!
            emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # No output
            ```
        &#34;&#34;&#34;
        if callback is not None:

            def once_callback(*args, **kwargs):
                self.off(event, once_callback)
                callback(*args, **kwargs)

            return self.on(event, once_callback)
        else:

            def decorator(callback: Callable) -&gt; Callable:
                self.once(event, callback)
                return callback

            return decorator

    def on(self, event: T_contra, callback: Optional[Callable] = None) -&gt; Callable:
        &#34;&#34;&#34;
        Register a callback to be called whenever the event is emitted.

        If a callback is provided, it registers the callback directly.
        If no callback is provided, it returns a decorator for use with function definitions.

        Args:
            event (T): The event to listen for.
            callback (Callable, optional): The callback to register. Defaults to None.

        Returns:
            Callable: The registered callback or a decorator if callback is None.

        Example:
            Using on with a direct callback:

            ```python
            emitter = EventEmitter[str]()

            def greet(name):
                print(f&#34;Hello, {name}!&#34;)

            emitter.on(&#39;greet&#39;, greet)
            emitter.emit(&#39;greet&#39;, &#39;Charlie&#39;)  # Output: Hello, Charlie!
            ```

            Using on as a decorator:

            ```python
            emitter = EventEmitter[str]()

            @emitter.on(&#39;greet&#39;)
            def greet(name):
                print(f&#34;Hello, {name}!&#34;)

            emitter.emit(&#39;greet&#39;, &#39;Charlie&#39;)  # Output: Hello, Charlie!
            ```
        &#34;&#34;&#34;
        if callback is not None:
            if asyncio.iscoroutinefunction(callback):
                raise ValueError(
                    &#34;Cannot register an async callback with `.on()`. Use `asyncio.create_task` within your synchronous callback instead.&#34;
                )

            if event not in self._events:
                self._events[event] = set()
            self._events[event].add(callback)
            return callback
        else:

            def decorator(callback: Callable) -&gt; Callable:
                self.on(event, callback)
                return callback

            return decorator

    def off(self, event: T_contra, callback: Callable) -&gt; None:
        &#34;&#34;&#34;
        Unregister a callback from an event.

        Args:
            event (T): The event to stop listening to.
            callback (Callable): The callback to remove.

        Example:
            Removing a callback:

            ```python
            emitter = EventEmitter[str]()

            def greet(name):
                print(f&#34;Hello, {name}!&#34;)

            emitter.on(&#39;greet&#39;, greet)
            emitter.off(&#39;greet&#39;, greet)
            emitter.emit(&#39;greet&#39;, &#39;Dave&#39;)  # No output, callback was removed
            ```
        &#34;&#34;&#34;
        if event in self._events:
            self._events[event].discard(callback)</code></pre>
</details>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::</p>
<pre><code>class Mapping[KT, VT]:
    def __getitem__(self, key: KT) -&gt; VT:
        ...
    # Etc.
</code></pre>
<p>On older versions of Python, however, generic classes have to
explicitly inherit from Generic.</p>
<p>After a class has been declared to be generic, it can then be used as
follows::</p>
<pre><code>def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
    try:
        return mapping[key]
    except KeyError:
        return default
</code></pre>
<p>Initialize a new instance of EventEmitter.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="livekit.agents.ipc.proc_pool.ProcPool" href="../agents/ipc/proc_pool.html#livekit.agents.ipc.proc_pool.ProcPool">ProcPool</a></li>
<li><a title="livekit.agents.llm.llm.LLM" href="../agents/llm/llm.html#livekit.agents.llm.llm.LLM">LLM</a></li>
<li><a title="livekit.agents.llm.realtime.RealtimeSession" href="../agents/llm/realtime.html#livekit.agents.llm.realtime.RealtimeSession">RealtimeSession</a></li>
<li><a title="livekit.agents.stt.stt.STT" href="../agents/stt/stt.html#livekit.agents.stt.stt.STT">STT</a></li>
<li><a title="livekit.agents.tts.tts.TTS" href="../agents/tts/tts.html#livekit.agents.tts.tts.TTS">TTS</a></li>
<li><a title="livekit.agents.vad.VAD" href="../agents/vad.html#livekit.agents.vad.VAD">VAD</a></li>
<li>livekit.agents.voice.agent_session.AgentSession</li>
<li>livekit.agents.voice.avatar._queue_io.QueueAudioOutput</li>
<li>livekit.agents.voice.avatar._types.AudioReceiver</li>
<li>livekit.agents.voice.io.AudioOutput</li>
<li><a title="livekit.agents.worker.Worker" href="../agents/worker.html#livekit.agents.worker.Worker">Worker</a></li>
<li><a title="livekit.rtc.room.Room" href="room.html#livekit.rtc.room.Room">Room</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.EventEmitter.emit"><code class="name flex">
<span>def <span class="ident">emit</span></span>(<span>self, event: -T_contra, *args) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emit(self, event: T_contra, *args) -&gt; None:
    &#34;&#34;&#34;
    Trigger all callbacks associated with the given event.

    Args:
        event (T): The event to emit.
        *args: Positional arguments to pass to the callbacks.

    Example:
        Basic usage of emit:

        ```python
        emitter = EventEmitter[str]()

        def greet(name):
            print(f&#34;Hello, {name}!&#34;)

        emitter.on(&#39;greet&#39;, greet)
        emitter.emit(&#39;greet&#39;, &#39;Alice&#39;)  # Output: Hello, Alice!
        ```
    &#34;&#34;&#34;
    if event in self._events:
        callables = self._events[event].copy()
        for callback in callables:
            try:
                sig = inspect.signature(callback)
                params = sig.parameters.values()

                has_varargs = any(p.kind == p.VAR_POSITIONAL for p in params)
                if has_varargs:
                    callback(*args)
                else:
                    positional_params = [
                        p
                        for p in params
                        if p.kind in (p.POSITIONAL_ONLY, p.POSITIONAL_OR_KEYWORD)
                    ]
                    num_params = len(positional_params)
                    num_args = min(len(args), num_params)
                    callback_args = args[:num_args]

                    callback(*callback_args)
            except TypeError:
                raise
            except Exception:
                logger.exception(f&#34;failed to emit event {event}&#34;)</code></pre>
</details>
<div class="desc"><p>Trigger all callbacks associated with the given event.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>T</code></dt>
<dd>The event to emit.</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>Positional arguments to pass to the callbacks.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Basic usage of emit:</p>
<pre><code class="language-python">emitter = EventEmitter[str]()

def greet(name):
    print(f&quot;Hello, {name}!&quot;)

emitter.on('greet', greet)
emitter.emit('greet', 'Alice')  # Output: Hello, Alice!
</code></pre></div>
</dd>
<dt id="livekit.rtc.EventEmitter.off"><code class="name flex">
<span>def <span class="ident">off</span></span>(<span>self, event: -T_contra, callback: Callable) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def off(self, event: T_contra, callback: Callable) -&gt; None:
    &#34;&#34;&#34;
    Unregister a callback from an event.

    Args:
        event (T): The event to stop listening to.
        callback (Callable): The callback to remove.

    Example:
        Removing a callback:

        ```python
        emitter = EventEmitter[str]()

        def greet(name):
            print(f&#34;Hello, {name}!&#34;)

        emitter.on(&#39;greet&#39;, greet)
        emitter.off(&#39;greet&#39;, greet)
        emitter.emit(&#39;greet&#39;, &#39;Dave&#39;)  # No output, callback was removed
        ```
    &#34;&#34;&#34;
    if event in self._events:
        self._events[event].discard(callback)</code></pre>
</details>
<div class="desc"><p>Unregister a callback from an event.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>T</code></dt>
<dd>The event to stop listening to.</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>Callable</code></dt>
<dd>The callback to remove.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Removing a callback:</p>
<pre><code class="language-python">emitter = EventEmitter[str]()

def greet(name):
    print(f&quot;Hello, {name}!&quot;)

emitter.on('greet', greet)
emitter.off('greet', greet)
emitter.emit('greet', 'Dave')  # No output, callback was removed
</code></pre></div>
</dd>
<dt id="livekit.rtc.EventEmitter.on"><code class="name flex">
<span>def <span class="ident">on</span></span>(<span>self, event: -T_contra, callback: Callable | None = None) ‑> Callable</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on(self, event: T_contra, callback: Optional[Callable] = None) -&gt; Callable:
    &#34;&#34;&#34;
    Register a callback to be called whenever the event is emitted.

    If a callback is provided, it registers the callback directly.
    If no callback is provided, it returns a decorator for use with function definitions.

    Args:
        event (T): The event to listen for.
        callback (Callable, optional): The callback to register. Defaults to None.

    Returns:
        Callable: The registered callback or a decorator if callback is None.

    Example:
        Using on with a direct callback:

        ```python
        emitter = EventEmitter[str]()

        def greet(name):
            print(f&#34;Hello, {name}!&#34;)

        emitter.on(&#39;greet&#39;, greet)
        emitter.emit(&#39;greet&#39;, &#39;Charlie&#39;)  # Output: Hello, Charlie!
        ```

        Using on as a decorator:

        ```python
        emitter = EventEmitter[str]()

        @emitter.on(&#39;greet&#39;)
        def greet(name):
            print(f&#34;Hello, {name}!&#34;)

        emitter.emit(&#39;greet&#39;, &#39;Charlie&#39;)  # Output: Hello, Charlie!
        ```
    &#34;&#34;&#34;
    if callback is not None:
        if asyncio.iscoroutinefunction(callback):
            raise ValueError(
                &#34;Cannot register an async callback with `.on()`. Use `asyncio.create_task` within your synchronous callback instead.&#34;
            )

        if event not in self._events:
            self._events[event] = set()
        self._events[event].add(callback)
        return callback
    else:

        def decorator(callback: Callable) -&gt; Callable:
            self.on(event, callback)
            return callback

        return decorator</code></pre>
</details>
<div class="desc"><p>Register a callback to be called whenever the event is emitted.</p>
<p>If a callback is provided, it registers the callback directly.
If no callback is provided, it returns a decorator for use with function definitions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>T</code></dt>
<dd>The event to listen for.</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>The callback to register. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable</code></dt>
<dd>The registered callback or a decorator if callback is None.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Using on with a direct callback:</p>
<pre><code class="language-python">emitter = EventEmitter[str]()

def greet(name):
    print(f&quot;Hello, {name}!&quot;)

emitter.on('greet', greet)
emitter.emit('greet', 'Charlie')  # Output: Hello, Charlie!
</code></pre>
<p>Using on as a decorator:</p>
<pre><code class="language-python">emitter = EventEmitter[str]()

@emitter.on('greet')
def greet(name):
    print(f&quot;Hello, {name}!&quot;)

emitter.emit('greet', 'Charlie')  # Output: Hello, Charlie!
</code></pre></div>
</dd>
<dt id="livekit.rtc.EventEmitter.once"><code class="name flex">
<span>def <span class="ident">once</span></span>(<span>self, event: -T_contra, callback: Callable | None = None) ‑> Callable</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def once(self, event: T_contra, callback: Optional[Callable] = None) -&gt; Callable:
    &#34;&#34;&#34;
    Register a callback to be called only once when the event is emitted.

    If a callback is provided, it registers the callback directly.
    If no callback is provided, it returns a decorator for use with function definitions.

    Args:
        event (T): The event to listen for.
        callback (Callable, optional): The callback to register. Defaults to None.

    Returns:
        Callable: The registered callback or a decorator if callback is None.

    Example:
        Using once with a direct callback:

        ```python
        emitter = EventEmitter[str]()

        def greet_once(name):
            print(f&#34;Hello once, {name}!&#34;)

        emitter.once(&#39;greet&#39;, greet_once)
        emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # Output: Hello once, Bob!
        emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # No output, callback was removed after first call
        ```

        Using once as a decorator:

        ```python
        emitter = EventEmitter[str]()

        @emitter.once(&#39;greet&#39;)
        def greet_once(name):
            print(f&#34;Hello once, {name}!&#34;)

        emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # Output: Hello once, Bob!
        emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # No output
        ```
    &#34;&#34;&#34;
    if callback is not None:

        def once_callback(*args, **kwargs):
            self.off(event, once_callback)
            callback(*args, **kwargs)

        return self.on(event, once_callback)
    else:

        def decorator(callback: Callable) -&gt; Callable:
            self.once(event, callback)
            return callback

        return decorator</code></pre>
</details>
<div class="desc"><p>Register a callback to be called only once when the event is emitted.</p>
<p>If a callback is provided, it registers the callback directly.
If no callback is provided, it returns a decorator for use with function definitions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>T</code></dt>
<dd>The event to listen for.</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>The callback to register. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable</code></dt>
<dd>The registered callback or a decorator if callback is None.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Using once with a direct callback:</p>
<pre><code class="language-python">emitter = EventEmitter[str]()

def greet_once(name):
    print(f&quot;Hello once, {name}!&quot;)

emitter.once('greet', greet_once)
emitter.emit('greet', 'Bob')    # Output: Hello once, Bob!
emitter.emit('greet', 'Bob')    # No output, callback was removed after first call
</code></pre>
<p>Using once as a decorator:</p>
<pre><code class="language-python">emitter = EventEmitter[str]()

@emitter.once('greet')
def greet_once(name):
    print(f&quot;Hello once, {name}!&quot;)

emitter.emit('greet', 'Bob')    # Output: Hello once, Bob!
emitter.emit('greet', 'Bob')    # No output
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.FrameCryptor"><code class="flex name class">
<span>class <span class="ident">FrameCryptor</span></span>
<span>(</span><span>room_handle: int, participant_identity: str, key_index: int, enabled: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FrameCryptor:
    def __init__(self, room_handle: int, participant_identity: str, key_index: int, enabled: bool):
        self._room_handle = room_handle
        self._enabled = enabled
        self._participant_identity = participant_identity
        self._key_index = key_index

    @property
    def participant_identity(self) -&gt; str:
        return self._participant_identity

    @property
    def key_index(self) -&gt; int:
        return self._key_index

    @property
    def enabled(self) -&gt; bool:
        return self._enabled

    def set_enabled(self, enabled: bool) -&gt; None:
        &#34;&#34;&#34;Enables or disables frame encryption.

        Parameters:
            enabled (bool): True to enable, False to disable.

        Example:
            ```python
            frame_cryptor.set_enabled(True)
            ```
        &#34;&#34;&#34;
        self._enabled = enabled
        req = proto_ffi.FfiRequest()
        req.e2ee.room_handle = self._room_handle
        req.e2ee.cryptor_set_enabled.participant_identity = self._participant_identity
        req.e2ee.cryptor_set_enabled.enabled = enabled
        FfiClient.instance.request(req)

    def set_key_index(self, key_index: int) -&gt; None:
        &#34;&#34;&#34;Sets the key index for encryption/decryption.

        Parameters:
            key_index (int): The new key index.

        Example:
            ```python
            frame_cryptor.set_key_index(3)
            ```
        &#34;&#34;&#34;
        self._key_index = key_index
        req = proto_ffi.FfiRequest()
        req.e2ee.room_handle = self._room_handle
        req.e2ee.cryptor_set_key_index.participant_identity = self._participant_identity
        req.e2ee.cryptor_set_key_index.key_index = key_index
        FfiClient.instance.request(req)</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.FrameCryptor.enabled"><code class="name">prop <span class="ident">enabled</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def enabled(self) -&gt; bool:
    return self._enabled</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.FrameCryptor.key_index"><code class="name">prop <span class="ident">key_index</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def key_index(self) -&gt; int:
    return self._key_index</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.FrameCryptor.participant_identity"><code class="name">prop <span class="ident">participant_identity</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def participant_identity(self) -&gt; str:
    return self._participant_identity</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.FrameCryptor.set_enabled"><code class="name flex">
<span>def <span class="ident">set_enabled</span></span>(<span>self, enabled: bool) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enabled(self, enabled: bool) -&gt; None:
    &#34;&#34;&#34;Enables or disables frame encryption.

    Parameters:
        enabled (bool): True to enable, False to disable.

    Example:
        ```python
        frame_cryptor.set_enabled(True)
        ```
    &#34;&#34;&#34;
    self._enabled = enabled
    req = proto_ffi.FfiRequest()
    req.e2ee.room_handle = self._room_handle
    req.e2ee.cryptor_set_enabled.participant_identity = self._participant_identity
    req.e2ee.cryptor_set_enabled.enabled = enabled
    FfiClient.instance.request(req)</code></pre>
</details>
<div class="desc"><p>Enables or disables frame encryption.</p>
<h2 id="parameters">Parameters</h2>
<p>enabled (bool): True to enable, False to disable.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">frame_cryptor.set_enabled(True)
</code></pre></div>
</dd>
<dt id="livekit.rtc.FrameCryptor.set_key_index"><code class="name flex">
<span>def <span class="ident">set_key_index</span></span>(<span>self, key_index: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_key_index(self, key_index: int) -&gt; None:
    &#34;&#34;&#34;Sets the key index for encryption/decryption.

    Parameters:
        key_index (int): The new key index.

    Example:
        ```python
        frame_cryptor.set_key_index(3)
        ```
    &#34;&#34;&#34;
    self._key_index = key_index
    req = proto_ffi.FfiRequest()
    req.e2ee.room_handle = self._room_handle
    req.e2ee.cryptor_set_key_index.participant_identity = self._participant_identity
    req.e2ee.cryptor_set_key_index.key_index = key_index
    FfiClient.instance.request(req)</code></pre>
</details>
<div class="desc"><p>Sets the key index for encryption/decryption.</p>
<h2 id="parameters">Parameters</h2>
<p>key_index (int): The new key index.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">frame_cryptor.set_key_index(3)
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.IceServer"><code class="flex name class">
<span>class <span class="ident">IceServer</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>google._upb._message.Message</li>
<li>google.protobuf.message.Message</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.rtc.IceServer.DESCRIPTOR"><code class="name">var <span class="ident">DESCRIPTOR</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.KeyProvider"><code class="flex name class">
<span>class <span class="ident">KeyProvider</span></span>
<span>(</span><span>room_handle: int,<br>options: <a title="livekit.rtc.e2ee.KeyProviderOptions" href="e2ee.html#livekit.rtc.e2ee.KeyProviderOptions">KeyProviderOptions</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyProvider:
    def __init__(self, room_handle: int, options: KeyProviderOptions):
        self._options = options
        self._room_handle = room_handle

    @property
    def options(self) -&gt; KeyProviderOptions:
        return self._options

    def set_shared_key(self, key: bytes, key_index: int) -&gt; None:
        &#34;&#34;&#34;Sets the shared encryption key.

        Parameters:
            key (bytes): The new shared key.
            key_index (int): The index of the key.

        Example:
            ```python
            key_provider.set_shared_key(b&#34;my_shared_key&#34;, key_index=1)
            ```
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.e2ee.room_handle = self._room_handle
        req.e2ee.set_shared_key.key_index = key_index
        req.e2ee.set_shared_key.shared_key = key
        FfiClient.instance.request(req)

    def export_shared_key(self, key_index: int) -&gt; bytes:
        &#34;&#34;&#34;Exports the shared encryption key.

        Parameters:
            key_index (int): The index of the key to export.

        Returns:
            bytes: The exported shared key.

        Example:
            ```python
            key = key_provider.export_shared_key(key_index=1)
            ```
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.e2ee.room_handle = self._room_handle
        req.e2ee.get_shared_key.key_index = key_index
        resp = FfiClient.instance.request(req)
        key = resp.e2ee.get_shared_key.key
        return key

    def ratchet_shared_key(self, key_index: int) -&gt; bytes:
        &#34;&#34;&#34;Ratchets the shared encryption key to a new key.

        Parameters:
            key_index (int): The index of the key to ratchet.

        Returns:
            bytes: The new ratcheted shared key.

        Example:
            ```python
            new_key = key_provider.ratchet_shared_key(key_index=1)
            ```
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.e2ee.room_handle = self._room_handle
        req.e2ee.ratchet_shared_key.key_index = key_index

        resp = FfiClient.instance.request(req)

        new_key = resp.e2ee.ratchet_shared_key.new_key
        return new_key

    def set_key(self, participant_identity: str, key: bytes, key_index: int) -&gt; None:
        &#34;&#34;&#34;Sets the encryption key for a specific participant.

        Parameters:
            participant_identity (str): The identity of the participant.
            key (bytes): The encryption key to set.
            key_index (int): The index of the key.

        Example:
            ```python
            key_provider.set_key(&#34;participant123&#34;, b&#34;participant_key&#34;, key_index=2)
            ```
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.e2ee.room_handle = self._room_handle
        req.e2ee.set_key.participant_identity = participant_identity
        req.e2ee.set_key.key_index = key_index
        req.e2ee.set_key.key = key

        self.key_index = key_index
        FfiClient.instance.request(req)

    def export_key(self, participant_identity: str, key_index: int) -&gt; bytes:
        &#34;&#34;&#34;Exports the encryption key for a specific participant.

        Parameters:
            participant_identity (str): The identity of the participant.
            key_index (int): The index of the key to export.

        Returns:
            bytes: The exported key.

        Example:
            ```python
            key = key_provider.export_key(&#34;participant123&#34;, key_index=2)
            ```
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.e2ee.room_handle = self._room_handle
        req.e2ee.get_key.participant_identity = participant_identity
        req.e2ee.get_key.key_index = key_index
        resp = FfiClient.instance.request(req)
        key = resp.e2ee.get_key.key
        return key

    def ratchet_key(self, participant_identity: str, key_index: int) -&gt; bytes:
        &#34;&#34;&#34;Ratchets the encryption key for a specific participant to a new key.

        Parameters:
            participant_identity (str): The identity of the participant.
            key_index (int): The index of the key to ratchet.

        Returns:
            bytes: The new ratcheted key.

        Example:
            ```python
            new_key = key_provider.ratchet_key(&#34;participant123&#34;, key_index=2)
            ```
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.e2ee.room_handle = self._room_handle
        req.e2ee.ratchet_key.participant_identity = participant_identity
        req.e2ee.ratchet_key.key_index = key_index

        resp = FfiClient.instance.request(req)
        new_key = resp.e2ee.ratchet_key.new_key
        return new_key</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.KeyProvider.options"><code class="name">prop <span class="ident">options</span> : <a title="livekit.rtc.e2ee.KeyProviderOptions" href="e2ee.html#livekit.rtc.e2ee.KeyProviderOptions">KeyProviderOptions</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def options(self) -&gt; KeyProviderOptions:
    return self._options</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.KeyProvider.export_key"><code class="name flex">
<span>def <span class="ident">export_key</span></span>(<span>self, participant_identity: str, key_index: int) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_key(self, participant_identity: str, key_index: int) -&gt; bytes:
    &#34;&#34;&#34;Exports the encryption key for a specific participant.

    Parameters:
        participant_identity (str): The identity of the participant.
        key_index (int): The index of the key to export.

    Returns:
        bytes: The exported key.

    Example:
        ```python
        key = key_provider.export_key(&#34;participant123&#34;, key_index=2)
        ```
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.e2ee.room_handle = self._room_handle
    req.e2ee.get_key.participant_identity = participant_identity
    req.e2ee.get_key.key_index = key_index
    resp = FfiClient.instance.request(req)
    key = resp.e2ee.get_key.key
    return key</code></pre>
</details>
<div class="desc"><p>Exports the encryption key for a specific participant.</p>
<h2 id="parameters">Parameters</h2>
<p>participant_identity (str): The identity of the participant.
key_index (int): The index of the key to export.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The exported key.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">key = key_provider.export_key(&quot;participant123&quot;, key_index=2)
</code></pre></div>
</dd>
<dt id="livekit.rtc.KeyProvider.export_shared_key"><code class="name flex">
<span>def <span class="ident">export_shared_key</span></span>(<span>self, key_index: int) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_shared_key(self, key_index: int) -&gt; bytes:
    &#34;&#34;&#34;Exports the shared encryption key.

    Parameters:
        key_index (int): The index of the key to export.

    Returns:
        bytes: The exported shared key.

    Example:
        ```python
        key = key_provider.export_shared_key(key_index=1)
        ```
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.e2ee.room_handle = self._room_handle
    req.e2ee.get_shared_key.key_index = key_index
    resp = FfiClient.instance.request(req)
    key = resp.e2ee.get_shared_key.key
    return key</code></pre>
</details>
<div class="desc"><p>Exports the shared encryption key.</p>
<h2 id="parameters">Parameters</h2>
<p>key_index (int): The index of the key to export.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The exported shared key.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">key = key_provider.export_shared_key(key_index=1)
</code></pre></div>
</dd>
<dt id="livekit.rtc.KeyProvider.ratchet_key"><code class="name flex">
<span>def <span class="ident">ratchet_key</span></span>(<span>self, participant_identity: str, key_index: int) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ratchet_key(self, participant_identity: str, key_index: int) -&gt; bytes:
    &#34;&#34;&#34;Ratchets the encryption key for a specific participant to a new key.

    Parameters:
        participant_identity (str): The identity of the participant.
        key_index (int): The index of the key to ratchet.

    Returns:
        bytes: The new ratcheted key.

    Example:
        ```python
        new_key = key_provider.ratchet_key(&#34;participant123&#34;, key_index=2)
        ```
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.e2ee.room_handle = self._room_handle
    req.e2ee.ratchet_key.participant_identity = participant_identity
    req.e2ee.ratchet_key.key_index = key_index

    resp = FfiClient.instance.request(req)
    new_key = resp.e2ee.ratchet_key.new_key
    return new_key</code></pre>
</details>
<div class="desc"><p>Ratchets the encryption key for a specific participant to a new key.</p>
<h2 id="parameters">Parameters</h2>
<p>participant_identity (str): The identity of the participant.
key_index (int): The index of the key to ratchet.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The new ratcheted key.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">new_key = key_provider.ratchet_key(&quot;participant123&quot;, key_index=2)
</code></pre></div>
</dd>
<dt id="livekit.rtc.KeyProvider.ratchet_shared_key"><code class="name flex">
<span>def <span class="ident">ratchet_shared_key</span></span>(<span>self, key_index: int) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ratchet_shared_key(self, key_index: int) -&gt; bytes:
    &#34;&#34;&#34;Ratchets the shared encryption key to a new key.

    Parameters:
        key_index (int): The index of the key to ratchet.

    Returns:
        bytes: The new ratcheted shared key.

    Example:
        ```python
        new_key = key_provider.ratchet_shared_key(key_index=1)
        ```
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.e2ee.room_handle = self._room_handle
    req.e2ee.ratchet_shared_key.key_index = key_index

    resp = FfiClient.instance.request(req)

    new_key = resp.e2ee.ratchet_shared_key.new_key
    return new_key</code></pre>
</details>
<div class="desc"><p>Ratchets the shared encryption key to a new key.</p>
<h2 id="parameters">Parameters</h2>
<p>key_index (int): The index of the key to ratchet.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The new ratcheted shared key.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">new_key = key_provider.ratchet_shared_key(key_index=1)
</code></pre></div>
</dd>
<dt id="livekit.rtc.KeyProvider.set_key"><code class="name flex">
<span>def <span class="ident">set_key</span></span>(<span>self, participant_identity: str, key: bytes, key_index: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_key(self, participant_identity: str, key: bytes, key_index: int) -&gt; None:
    &#34;&#34;&#34;Sets the encryption key for a specific participant.

    Parameters:
        participant_identity (str): The identity of the participant.
        key (bytes): The encryption key to set.
        key_index (int): The index of the key.

    Example:
        ```python
        key_provider.set_key(&#34;participant123&#34;, b&#34;participant_key&#34;, key_index=2)
        ```
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.e2ee.room_handle = self._room_handle
    req.e2ee.set_key.participant_identity = participant_identity
    req.e2ee.set_key.key_index = key_index
    req.e2ee.set_key.key = key

    self.key_index = key_index
    FfiClient.instance.request(req)</code></pre>
</details>
<div class="desc"><p>Sets the encryption key for a specific participant.</p>
<h2 id="parameters">Parameters</h2>
<p>participant_identity (str): The identity of the participant.
key (bytes): The encryption key to set.
key_index (int): The index of the key.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">key_provider.set_key(&quot;participant123&quot;, b&quot;participant_key&quot;, key_index=2)
</code></pre></div>
</dd>
<dt id="livekit.rtc.KeyProvider.set_shared_key"><code class="name flex">
<span>def <span class="ident">set_shared_key</span></span>(<span>self, key: bytes, key_index: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_shared_key(self, key: bytes, key_index: int) -&gt; None:
    &#34;&#34;&#34;Sets the shared encryption key.

    Parameters:
        key (bytes): The new shared key.
        key_index (int): The index of the key.

    Example:
        ```python
        key_provider.set_shared_key(b&#34;my_shared_key&#34;, key_index=1)
        ```
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.e2ee.room_handle = self._room_handle
    req.e2ee.set_shared_key.key_index = key_index
    req.e2ee.set_shared_key.shared_key = key
    FfiClient.instance.request(req)</code></pre>
</details>
<div class="desc"><p>Sets the shared encryption key.</p>
<h2 id="parameters">Parameters</h2>
<p>key (bytes): The new shared key.
key_index (int): The index of the key.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">key_provider.set_shared_key(b&quot;my_shared_key&quot;, key_index=1)
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.KeyProviderOptions"><code class="flex name class">
<span>class <span class="ident">KeyProviderOptions</span></span>
<span>(</span><span>shared_key: bytes | None = None,<br>ratchet_salt: bytes = b'LKFrameEncryptionKey',<br>ratchet_window_size: int = 16,<br>failure_tolerance: int = -1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class KeyProviderOptions:
    shared_key: Optional[bytes] = None
    ratchet_salt: bytes = DEFAULT_RATCHET_SALT
    ratchet_window_size: int = DEFAULT_RATCHET_WINDOW_SIZE
    failure_tolerance: int = DEFAULT_FAILURE_TOLERANCE</code></pre>
</details>
<div class="desc"><p>KeyProviderOptions(shared_key: Optional[bytes] = None, ratchet_salt: bytes = b'LKFrameEncryptionKey', ratchet_window_size: int = 16, failure_tolerance: int = -1)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.KeyProviderOptions.failure_tolerance"><code class="name">var <span class="ident">failure_tolerance</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.KeyProviderOptions.ratchet_salt"><code class="name">var <span class="ident">ratchet_salt</span> : bytes</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.KeyProviderOptions.ratchet_window_size"><code class="name">var <span class="ident">ratchet_window_size</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.KeyProviderOptions.shared_key"><code class="name">var <span class="ident">shared_key</span> : bytes | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.LocalAudioTrack"><code class="flex name class">
<span>class <span class="ident">LocalAudioTrack</span></span>
<span>(</span><span>info: track_pb2.OwnedTrack)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocalAudioTrack(Track):
    def __init__(self, info: proto_track.OwnedTrack):
        super().__init__(info)

    @staticmethod
    def create_audio_track(name: str, source: &#34;AudioSource&#34;) -&gt; &#34;LocalAudioTrack&#34;:
        req = proto_ffi.FfiRequest()
        req.create_audio_track.name = name
        req.create_audio_track.source_handle = source._ffi_handle.handle

        resp = FfiClient.instance.request(req)
        return LocalAudioTrack(resp.create_audio_track.track)

    def mute(self):
        req = proto_ffi.FfiRequest()
        req.local_track_mute.track_handle = self._ffi_handle.handle
        req.local_track_mute.mute = True
        FfiClient.instance.request(req)
        self._info.muted = True

    def unmute(self):
        req = proto_ffi.FfiRequest()
        req.local_track_mute.track_handle = self._ffi_handle.handle
        req.local_track_mute.mute = False
        FfiClient.instance.request(req)
        self._info.muted = False

    def __repr__(self) -&gt; str:
        return f&#34;rtc.LocalAudioTrack(sid={self.sid}, name={self.name})&#34;</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.track.Track" href="track.html#livekit.rtc.track.Track">Track</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="livekit.rtc.LocalAudioTrack.create_audio_track"><code class="name flex">
<span>def <span class="ident">create_audio_track</span></span>(<span>name: str,<br>source: <a title="livekit.rtc.AudioSource" href="#livekit.rtc.AudioSource">AudioSource</a>) ‑> <a title="livekit.rtc.LocalAudioTrack" href="#livekit.rtc.LocalAudioTrack">LocalAudioTrack</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_audio_track(name: str, source: &#34;AudioSource&#34;) -&gt; &#34;LocalAudioTrack&#34;:
    req = proto_ffi.FfiRequest()
    req.create_audio_track.name = name
    req.create_audio_track.source_handle = source._ffi_handle.handle

    resp = FfiClient.instance.request(req)
    return LocalAudioTrack(resp.create_audio_track.track)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.LocalAudioTrack.mute"><code class="name flex">
<span>def <span class="ident">mute</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mute(self):
    req = proto_ffi.FfiRequest()
    req.local_track_mute.track_handle = self._ffi_handle.handle
    req.local_track_mute.mute = True
    FfiClient.instance.request(req)
    self._info.muted = True</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.LocalAudioTrack.unmute"><code class="name flex">
<span>def <span class="ident">unmute</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unmute(self):
    req = proto_ffi.FfiRequest()
    req.local_track_mute.track_handle = self._ffi_handle.handle
    req.local_track_mute.mute = False
    FfiClient.instance.request(req)
    self._info.muted = False</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.LocalParticipant"><code class="flex name class">
<span>class <span class="ident">LocalParticipant</span></span>
<span>(</span><span>room_queue: BroadcastQueue[proto_ffi.FfiEvent],<br>owned_info: proto_participant.OwnedParticipant)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocalParticipant(Participant):
    &#34;&#34;&#34;Represents the local participant in a room.&#34;&#34;&#34;

    def __init__(
        self,
        room_queue: BroadcastQueue[proto_ffi.FfiEvent],
        owned_info: proto_participant.OwnedParticipant,
    ) -&gt; None:
        super().__init__(owned_info)
        self._room_queue = room_queue
        self._track_publications: dict[str, LocalTrackPublication] = {}  # type: ignore
        self._rpc_handlers: Dict[str, RpcHandler] = {}

    @property
    def track_publications(self) -&gt; Mapping[str, LocalTrackPublication]:
        &#34;&#34;&#34;
        A dictionary of track publications associated with the participant.
        &#34;&#34;&#34;
        return self._track_publications

    async def publish_data(
        self,
        payload: Union[bytes, str],
        *,
        reliable: bool = True,
        destination_identities: List[str] = [],
        topic: str = &#34;&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;
        Publish arbitrary data to the room.

        Args:
            payload (Union[bytes, str]): The data to publish.
            reliable (bool, optional): Whether to send reliably or not. Defaults to True.
            destination_identities (List[str], optional): List of participant identities to send to. Defaults to [].
            topic (str, optional): The topic under which to publish the data. Defaults to &#34;&#34;.

        Raises:
            PublishDataError: If there is an error in publishing data.
        &#34;&#34;&#34;
        if isinstance(payload, str):
            payload = payload.encode(&#34;utf-8&#34;)

        data_len = len(payload)
        cdata = (ctypes.c_byte * data_len)(*payload)

        req = proto_ffi.FfiRequest()
        req.publish_data.local_participant_handle = self._ffi_handle.handle
        req.publish_data.data_ptr = ctypes.addressof(cdata)
        req.publish_data.data_len = data_len
        req.publish_data.reliable = reliable
        req.publish_data.topic = topic
        req.publish_data.destination_identities.extend(destination_identities)

        queue = FfiClient.instance.queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            cb: proto_ffi.FfiEvent = await queue.wait_for(
                lambda e: e.publish_data.async_id == resp.publish_data.async_id
            )
        finally:
            FfiClient.instance.queue.unsubscribe(queue)

        if cb.publish_data.error:
            raise PublishDataError(cb.publish_data.error)

    async def publish_dtmf(self, *, code: int, digit: str) -&gt; None:
        &#34;&#34;&#34;
        Publish SIP DTMF message.

        Args:
            code (int): DTMF code.
            digit (str): DTMF digit.

        Raises:
            PublishDTMFError: If there is an error in publishing SIP DTMF message.
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.publish_sip_dtmf.local_participant_handle = self._ffi_handle.handle
        req.publish_sip_dtmf.code = code
        req.publish_sip_dtmf.digit = digit

        queue = FfiClient.instance.queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            cb: proto_ffi.FfiEvent = await queue.wait_for(
                lambda e: e.publish_sip_dtmf.async_id == resp.publish_sip_dtmf.async_id
            )
        finally:
            FfiClient.instance.queue.unsubscribe(queue)

        if cb.publish_sip_dtmf.error:
            raise PublishDTMFError(cb.publish_sip_dtmf.error)

    async def publish_transcription(self, transcription: Transcription) -&gt; None:
        &#34;&#34;&#34;
        Publish transcription data to the room.

        Args:
            transcription (Transcription): The transcription data to publish.

        Raises:
            PublishTranscriptionError: If there is an error in publishing transcription.
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        proto_segments = [
            ProtoTranscriptionSegment(
                id=s.id,
                text=s.text,
                start_time=s.start_time,
                end_time=s.end_time,
                final=s.final,
                language=s.language,
            )
            for s in transcription.segments
        ]
        # fmt: off
        req.publish_transcription.local_participant_handle = self._ffi_handle.handle
        req.publish_transcription.participant_identity = transcription.participant_identity
        req.publish_transcription.segments.extend(proto_segments)
        req.publish_transcription.track_id = transcription.track_sid
        # fmt: on
        queue = FfiClient.instance.queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            cb: proto_ffi.FfiEvent = await queue.wait_for(
                lambda e: e.publish_transcription.async_id == resp.publish_transcription.async_id
            )
        finally:
            FfiClient.instance.queue.unsubscribe(queue)

        if cb.publish_transcription.error:
            raise PublishTranscriptionError(cb.publish_transcription.error)

    async def perform_rpc(
        self,
        *,
        destination_identity: str,
        method: str,
        payload: str,
        response_timeout: Optional[float] = None,
    ) -&gt; str:
        &#34;&#34;&#34;
        Initiate an RPC call to a remote participant.

        Args:
            destination_identity (str): The `identity` of the destination participant
            method (str): The method name to call
            payload (str): The method payload
            response_timeout (Optional[float]): Timeout for receiving a response after initial connection

        Returns:
            str: The response payload

        Raises:
            RpcError: On failure. Details in `message`.
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.perform_rpc.local_participant_handle = self._ffi_handle.handle
        req.perform_rpc.destination_identity = destination_identity
        req.perform_rpc.method = method
        req.perform_rpc.payload = payload
        if response_timeout is not None:
            req.perform_rpc.response_timeout_ms = int(response_timeout * 1000)

        queue = FfiClient.instance.queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            cb = await queue.wait_for(
                lambda e: (e.perform_rpc.async_id == resp.perform_rpc.async_id)
            )
        finally:
            FfiClient.instance.queue.unsubscribe(queue)

        if cb.perform_rpc.HasField(&#34;error&#34;):
            raise RpcError._from_proto(cb.perform_rpc.error)

        return cb.perform_rpc.payload

    def register_rpc_method(
        self,
        method_name: str,
        handler: Optional[F] = None,
    ) -&gt; Union[F, Callable[[F], F]]:
        &#34;&#34;&#34;
        Establishes the participant as a receiver for calls of the specified RPC method.
        Can be used either as a decorator or a regular method.

        The handler will receive one argument of type `RpcInvocationData` and should return a string response which will be forwarded back to the caller.

        The handler may be synchronous or asynchronous.

        If unable to respond within `response_timeout`, the caller will hang up and receive an error on their side.

        You may raise errors of type `RpcError` in the handler, and they will be forwarded to the caller.

        Other errors raised in your handler will be caught and forwarded to the caller as &#34;1500 Application Error&#34;.

        Args:
            method_name (str): The name of the indicated RPC method.
            handler (Optional[Callable]): Handler to be invoked whenever an RPC request for this method is received.  Omit this argument to use the decorator syntax.

        Returns:
            None (when used as a decorator it returns the decorator function)

        Example:
            # As a decorator:
            @room.local_participant.register_rpc_method(&#34;greet&#34;)
            async def greet_handler(data: RpcInvocationData) -&gt; str:
                print(f&#34;Received greeting from {data.caller_identity}: {data.payload}&#34;)
                return f&#34;Hello, {data.caller_identity}!&#34;

            # As a regular method:
            async def greet_handler(data: RpcInvocationData) -&gt; str:
                print(f&#34;Received greeting from {data.caller_identity}: {data.payload}&#34;)
                return f&#34;Hello, {data.caller_identity}!&#34;

            room.local_participant.register_rpc_method(&#39;greet&#39;, greet_handler)
        &#34;&#34;&#34;

        def register(handler_func: F) -&gt; F:
            self._rpc_handlers[method_name] = handler_func
            req = proto_ffi.FfiRequest()
            req.register_rpc_method.local_participant_handle = self._ffi_handle.handle
            req.register_rpc_method.method = method_name
            FfiClient.instance.request(req)
            return handler_func

        if handler is not None:
            return register(handler)
        else:
            return register

    def unregister_rpc_method(self, method: str) -&gt; None:
        &#34;&#34;&#34;
        Unregisters a previously registered RPC method.

        Args:
            method (str): The name of the RPC method to unregister
        &#34;&#34;&#34;
        self._rpc_handlers.pop(method, None)

        req = proto_ffi.FfiRequest()
        req.unregister_rpc_method.local_participant_handle = self._ffi_handle.handle
        req.unregister_rpc_method.method = method

        FfiClient.instance.request(req)

    def set_track_subscription_permissions(
        self,
        *,
        allow_all_participants: bool,
        participant_permissions: Optional[List[ParticipantTrackPermission]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Set the track subscription permissions for the local participant.

        Args:
            allow_all_participants (bool): Whether to allow all participants to subscribe to this participant&#39;s tracks.
            participant_permissions (List[ParticipantTrackPermission]): Participant-specific track subscription permissions, ignored if `allow_all_participants` is True.
        &#34;&#34;&#34;
        if participant_permissions is None:
            participant_permissions = []

        req = proto_ffi.FfiRequest()
        req.set_track_subscription_permissions.local_participant_handle = self._ffi_handle.handle
        req.set_track_subscription_permissions.all_participants_allowed = allow_all_participants
        req.set_track_subscription_permissions.permissions.extend(participant_permissions)
        FfiClient.instance.request(req)

    async def _handle_rpc_method_invocation(
        self,
        invocation_id: int,
        method: str,
        request_id: str,
        caller_identity: str,
        payload: str,
        response_timeout: float,
    ) -&gt; None:
        response_error: Optional[RpcError] = None
        response_payload: Optional[str] = None

        params = RpcInvocationData(request_id, caller_identity, payload, response_timeout)

        handler = self._rpc_handlers.get(method)

        if not handler:
            response_error = RpcError._built_in(RpcError.ErrorCode.UNSUPPORTED_METHOD)
        else:
            try:
                if asyncio.iscoroutinefunction(handler):
                    try:
                        response_payload = await asyncio.wait_for(
                            handler(params), timeout=response_timeout
                        )
                    except asyncio.TimeoutError:
                        raise RpcError._built_in(RpcError.ErrorCode.RESPONSE_TIMEOUT)
                    except asyncio.CancelledError:
                        raise RpcError._built_in(RpcError.ErrorCode.RECIPIENT_DISCONNECTED)
                else:
                    response_payload = cast(Optional[str], handler(params))
            except RpcError as error:
                response_error = error
            except Exception:
                logger.exception(
                    f&#34;Uncaught error returned by RPC handler for {method}. &#34;
                    &#34;Returning APPLICATION_ERROR instead. &#34;
                )
                response_error = RpcError._built_in(RpcError.ErrorCode.APPLICATION_ERROR)

        req = proto_ffi.FfiRequest(
            rpc_method_invocation_response=RpcMethodInvocationResponseRequest(
                local_participant_handle=self._ffi_handle.handle,
                invocation_id=invocation_id,
                error=response_error._to_proto() if response_error else None,
                payload=response_payload,
            )
        )

        res = FfiClient.instance.request(req)

        if res.rpc_method_invocation_response.error:
            err = res.rpc_method_invocation_response.error
            logger.error(f&#34;error sending rpc method invocation response: {err}&#34;)

    async def set_metadata(self, metadata: str) -&gt; None:
        &#34;&#34;&#34;
        Set the metadata for the local participant.

        Note: this requires `canUpdateOwnMetadata` permission.

        Args:
            metadata (str): The new metadata.
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.set_local_metadata.local_participant_handle = self._ffi_handle.handle
        req.set_local_metadata.metadata = metadata

        queue = FfiClient.instance.queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            await queue.wait_for(
                lambda e: e.set_local_metadata.async_id == resp.set_local_metadata.async_id
            )
        finally:
            FfiClient.instance.queue.unsubscribe(queue)

    async def set_name(self, name: str) -&gt; None:
        &#34;&#34;&#34;
        Set the name for the local participant.

        Note: this requires `canUpdateOwnMetadata` permission.

        Args:
            name (str): The new name.
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.set_local_name.local_participant_handle = self._ffi_handle.handle
        req.set_local_name.name = name

        queue = FfiClient.instance.queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            await queue.wait_for(
                lambda e: e.set_local_name.async_id == resp.set_local_name.async_id
            )
        finally:
            FfiClient.instance.queue.unsubscribe(queue)

    async def set_attributes(self, attributes: dict[str, str]) -&gt; None:
        &#34;&#34;&#34;
        Set custom attributes for the local participant.

        Note: this requires `canUpdateOwnMetadata` permission.

        Args:
            attributes (dict[str, str]): A dictionary of attributes to set.
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.set_local_attributes.local_participant_handle = self._ffi_handle.handle
        existing_attributes = {
            entry.key: entry.value for entry in req.set_local_attributes.attributes
        }
        existing_attributes.update(attributes)

        for key, value in existing_attributes.items():
            entry = req.set_local_attributes.attributes.add()
            entry.key = key
            entry.value = value

        queue = FfiClient.instance.queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            await queue.wait_for(
                lambda e: e.set_local_attributes.async_id == resp.set_local_attributes.async_id
            )
        finally:
            FfiClient.instance.queue.unsubscribe(queue)

    async def stream_text(
        self,
        *,
        destination_identities: Optional[List[str]] = None,
        topic: str = &#34;&#34;,
        attributes: Optional[Dict[str, str]] = None,
        stream_id: str | None = None,
        reply_to_id: str | None = None,
        total_size: int | None = None,
        sender_identity: str | None = None,
    ) -&gt; TextStreamWriter:
        &#34;&#34;&#34;
        Returns a TextStreamWriter that allows to write individual chunks of text to a text stream.
        In most cases where you want to simply send a text message use send_text() instead.
        &#34;&#34;&#34;
        writer = TextStreamWriter(
            self,
            topic=topic,
            attributes=attributes,
            reply_to_id=reply_to_id,
            destination_identities=destination_identities,
            total_size=total_size,
            stream_id=stream_id,
            sender_identity=sender_identity,
        )

        await writer._send_header()

        return writer

    async def send_text(
        self,
        text: str,
        *,
        destination_identities: Optional[List[str]] = None,
        topic: str = &#34;&#34;,
        attributes: Optional[Dict[str, str]] = None,
        reply_to_id: str | None = None,
    ):
        total_size = len(text.encode())
        writer = await self.stream_text(
            destination_identities=destination_identities,
            topic=topic,
            attributes=attributes,
            reply_to_id=reply_to_id,
            total_size=total_size,
        )

        await writer.write(text)
        await writer.aclose()

        return writer.info

    async def stream_bytes(
        self,
        name: str,
        *,
        total_size: int | None = None,
        mime_type: str = &#34;application/octet-stream&#34;,
        attributes: Optional[Dict[str, str]] = None,
        stream_id: str | None = None,
        destination_identities: Optional[List[str]] = None,
        topic: str = &#34;&#34;,
    ) -&gt; ByteStreamWriter:
        &#34;&#34;&#34;
        Returns a ByteStreamWriter that allows to write individual chunks of bytes to a byte stream.
        In cases where you want to simply send a file from the file system use send_file() instead.
        &#34;&#34;&#34;
        writer = ByteStreamWriter(
            self,
            name=name,
            attributes=attributes,
            total_size=total_size,
            stream_id=stream_id,
            mime_type=mime_type,
            destination_identities=destination_identities,
            topic=topic,
        )

        await writer._send_header()

        return writer

    async def send_file(
        self,
        file_path: str,
        *,
        topic: str = &#34;&#34;,
        destination_identities: Optional[List[str]] = None,
        attributes: Optional[Dict[str, str]] = None,
        stream_id: str | None = None,
    ) -&gt; ByteStreamInfo:
        file_size = os.path.getsize(file_path)
        file_name = os.path.basename(file_path)
        mime_type, _ = mimetypes.guess_type(file_path)
        if mime_type is None:
            mime_type = &#34;application/octet-stream&#34;  # Fallback MIME type for unknown files

        writer: ByteStreamWriter = await self.stream_bytes(
            name=file_name,
            total_size=file_size,
            mime_type=mime_type,
            attributes=attributes,
            stream_id=stream_id,
            destination_identities=destination_identities,
            topic=topic,
        )

        async with aiofiles.open(file_path, &#34;rb&#34;) as f:
            while bytes := await f.read(STREAM_CHUNK_SIZE):
                await writer.write(bytes)
        await writer.aclose()

        return writer.info

    async def publish_track(
        self, track: LocalTrack, options: TrackPublishOptions = TrackPublishOptions()
    ) -&gt; LocalTrackPublication:
        &#34;&#34;&#34;
        Publish a local track to the room.

        Args:
            track (LocalTrack): The track to publish.
            options (TrackPublishOptions, optional): Options for publishing the track.

        Returns:
            LocalTrackPublication: The publication of the published track.

        Raises:
            PublishTrackError: If there is an error in publishing the track.
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.publish_track.track_handle = track._ffi_handle.handle
        req.publish_track.local_participant_handle = self._ffi_handle.handle
        req.publish_track.options.CopyFrom(options)

        queue = self._room_queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            cb: proto_ffi.FfiEvent = await queue.wait_for(
                lambda e: e.publish_track.async_id == resp.publish_track.async_id
            )

            if cb.publish_track.error:
                raise PublishTrackError(cb.publish_track.error)

            track_publication = LocalTrackPublication(cb.publish_track.publication)
            track_publication._track = track
            track._info.sid = track_publication.sid
            self._track_publications[track_publication.sid] = track_publication

            queue.task_done()
            return track_publication
        finally:
            self._room_queue.unsubscribe(queue)

    async def unpublish_track(self, track_sid: str) -&gt; None:
        &#34;&#34;&#34;
        Unpublish a track from the room.

        Args:
            track_sid (str): The SID of the track to unpublish.

        Raises:
            UnpublishTrackError: If there is an error in unpublishing the track.
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.unpublish_track.local_participant_handle = self._ffi_handle.handle
        req.unpublish_track.track_sid = track_sid
        req.unpublish_track.stop_on_unpublish = True

        queue = self._room_queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            cb: proto_ffi.FfiEvent = await queue.wait_for(
                lambda e: e.unpublish_track.async_id == resp.unpublish_track.async_id
            )

            if cb.unpublish_track.error:
                raise UnpublishTrackError(cb.unpublish_track.error)

            publication = self._track_publications.pop(track_sid)
            publication._track = None
            queue.task_done()
        finally:
            self._room_queue.unsubscribe(queue)

    def __repr__(self) -&gt; str:
        return f&#34;rtc.LocalParticipant(sid={self.sid}, identity={self.identity}, name={self.name})&#34;</code></pre>
</details>
<div class="desc"><p>Represents the local participant in a room.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.participant.Participant" href="participant.html#livekit.rtc.participant.Participant">Participant</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.LocalParticipant.perform_rpc"><code class="name flex">
<span>async def <span class="ident">perform_rpc</span></span>(<span>self,<br>*,<br>destination_identity: str,<br>method: str,<br>payload: str,<br>response_timeout: Optional[float] = None) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def perform_rpc(
    self,
    *,
    destination_identity: str,
    method: str,
    payload: str,
    response_timeout: Optional[float] = None,
) -&gt; str:
    &#34;&#34;&#34;
    Initiate an RPC call to a remote participant.

    Args:
        destination_identity (str): The `identity` of the destination participant
        method (str): The method name to call
        payload (str): The method payload
        response_timeout (Optional[float]): Timeout for receiving a response after initial connection

    Returns:
        str: The response payload

    Raises:
        RpcError: On failure. Details in `message`.
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.perform_rpc.local_participant_handle = self._ffi_handle.handle
    req.perform_rpc.destination_identity = destination_identity
    req.perform_rpc.method = method
    req.perform_rpc.payload = payload
    if response_timeout is not None:
        req.perform_rpc.response_timeout_ms = int(response_timeout * 1000)

    queue = FfiClient.instance.queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        cb = await queue.wait_for(
            lambda e: (e.perform_rpc.async_id == resp.perform_rpc.async_id)
        )
    finally:
        FfiClient.instance.queue.unsubscribe(queue)

    if cb.perform_rpc.HasField(&#34;error&#34;):
        raise RpcError._from_proto(cb.perform_rpc.error)

    return cb.perform_rpc.payload</code></pre>
</details>
<div class="desc"><p>Initiate an RPC call to a remote participant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>destination_identity</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>identity</code> of the destination participant</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>The method name to call</dd>
<dt><strong><code>payload</code></strong> :&ensp;<code>str</code></dt>
<dd>The method payload</dd>
<dt><strong><code>response_timeout</code></strong> :&ensp;<code>Optional[float]</code></dt>
<dd>Timeout for receiving a response after initial connection</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The response payload</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="livekit.rtc.RpcError" href="#livekit.rtc.RpcError">RpcError</a></code></dt>
<dd>On failure. Details in <code>message</code>.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.publish_data"><code class="name flex">
<span>async def <span class="ident">publish_data</span></span>(<span>self,<br>payload: Union[bytes, str],<br>*,<br>reliable: bool = True,<br>destination_identities: List[str] = [],<br>topic: str = '') ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def publish_data(
    self,
    payload: Union[bytes, str],
    *,
    reliable: bool = True,
    destination_identities: List[str] = [],
    topic: str = &#34;&#34;,
) -&gt; None:
    &#34;&#34;&#34;
    Publish arbitrary data to the room.

    Args:
        payload (Union[bytes, str]): The data to publish.
        reliable (bool, optional): Whether to send reliably or not. Defaults to True.
        destination_identities (List[str], optional): List of participant identities to send to. Defaults to [].
        topic (str, optional): The topic under which to publish the data. Defaults to &#34;&#34;.

    Raises:
        PublishDataError: If there is an error in publishing data.
    &#34;&#34;&#34;
    if isinstance(payload, str):
        payload = payload.encode(&#34;utf-8&#34;)

    data_len = len(payload)
    cdata = (ctypes.c_byte * data_len)(*payload)

    req = proto_ffi.FfiRequest()
    req.publish_data.local_participant_handle = self._ffi_handle.handle
    req.publish_data.data_ptr = ctypes.addressof(cdata)
    req.publish_data.data_len = data_len
    req.publish_data.reliable = reliable
    req.publish_data.topic = topic
    req.publish_data.destination_identities.extend(destination_identities)

    queue = FfiClient.instance.queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        cb: proto_ffi.FfiEvent = await queue.wait_for(
            lambda e: e.publish_data.async_id == resp.publish_data.async_id
        )
    finally:
        FfiClient.instance.queue.unsubscribe(queue)

    if cb.publish_data.error:
        raise PublishDataError(cb.publish_data.error)</code></pre>
</details>
<div class="desc"><p>Publish arbitrary data to the room.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>payload</code></strong> :&ensp;<code>Union[bytes, str]</code></dt>
<dd>The data to publish.</dd>
<dt><strong><code>reliable</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to send reliably or not. Defaults to True.</dd>
<dt><strong><code>destination_identities</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of participant identities to send to. Defaults to [].</dd>
<dt><strong><code>topic</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The topic under which to publish the data. Defaults to "".</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>PublishDataError</code></dt>
<dd>If there is an error in publishing data.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.publish_dtmf"><code class="name flex">
<span>async def <span class="ident">publish_dtmf</span></span>(<span>self, *, code: int, digit: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def publish_dtmf(self, *, code: int, digit: str) -&gt; None:
    &#34;&#34;&#34;
    Publish SIP DTMF message.

    Args:
        code (int): DTMF code.
        digit (str): DTMF digit.

    Raises:
        PublishDTMFError: If there is an error in publishing SIP DTMF message.
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.publish_sip_dtmf.local_participant_handle = self._ffi_handle.handle
    req.publish_sip_dtmf.code = code
    req.publish_sip_dtmf.digit = digit

    queue = FfiClient.instance.queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        cb: proto_ffi.FfiEvent = await queue.wait_for(
            lambda e: e.publish_sip_dtmf.async_id == resp.publish_sip_dtmf.async_id
        )
    finally:
        FfiClient.instance.queue.unsubscribe(queue)

    if cb.publish_sip_dtmf.error:
        raise PublishDTMFError(cb.publish_sip_dtmf.error)</code></pre>
</details>
<div class="desc"><p>Publish SIP DTMF message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>code</code></strong> :&ensp;<code>int</code></dt>
<dd>DTMF code.</dd>
<dt><strong><code>digit</code></strong> :&ensp;<code>str</code></dt>
<dd>DTMF digit.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>PublishDTMFError</code></dt>
<dd>If there is an error in publishing SIP DTMF message.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.publish_track"><code class="name flex">
<span>async def <span class="ident">publish_track</span></span>(<span>self,<br>track: LocalTrack,<br>options: <a title="livekit.rtc.TrackPublishOptions" href="#livekit.rtc.TrackPublishOptions">TrackPublishOptions</a> = ) ‑> <a title="livekit.rtc.track_publication.LocalTrackPublication" href="track_publication.html#livekit.rtc.track_publication.LocalTrackPublication">LocalTrackPublication</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def publish_track(
    self, track: LocalTrack, options: TrackPublishOptions = TrackPublishOptions()
) -&gt; LocalTrackPublication:
    &#34;&#34;&#34;
    Publish a local track to the room.

    Args:
        track (LocalTrack): The track to publish.
        options (TrackPublishOptions, optional): Options for publishing the track.

    Returns:
        LocalTrackPublication: The publication of the published track.

    Raises:
        PublishTrackError: If there is an error in publishing the track.
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.publish_track.track_handle = track._ffi_handle.handle
    req.publish_track.local_participant_handle = self._ffi_handle.handle
    req.publish_track.options.CopyFrom(options)

    queue = self._room_queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        cb: proto_ffi.FfiEvent = await queue.wait_for(
            lambda e: e.publish_track.async_id == resp.publish_track.async_id
        )

        if cb.publish_track.error:
            raise PublishTrackError(cb.publish_track.error)

        track_publication = LocalTrackPublication(cb.publish_track.publication)
        track_publication._track = track
        track._info.sid = track_publication.sid
        self._track_publications[track_publication.sid] = track_publication

        queue.task_done()
        return track_publication
    finally:
        self._room_queue.unsubscribe(queue)</code></pre>
</details>
<div class="desc"><p>Publish a local track to the room.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>track</code></strong> :&ensp;<code>LocalTrack</code></dt>
<dd>The track to publish.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code><a title="livekit.rtc.TrackPublishOptions" href="#livekit.rtc.TrackPublishOptions">TrackPublishOptions</a></code>, optional</dt>
<dd>Options for publishing the track.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="livekit.rtc.LocalTrackPublication" href="#livekit.rtc.LocalTrackPublication">LocalTrackPublication</a></code></dt>
<dd>The publication of the published track.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>PublishTrackError</code></dt>
<dd>If there is an error in publishing the track.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.publish_transcription"><code class="name flex">
<span>async def <span class="ident">publish_transcription</span></span>(<span>self,<br>transcription: <a title="livekit.rtc.Transcription" href="#livekit.rtc.Transcription">Transcription</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def publish_transcription(self, transcription: Transcription) -&gt; None:
    &#34;&#34;&#34;
    Publish transcription data to the room.

    Args:
        transcription (Transcription): The transcription data to publish.

    Raises:
        PublishTranscriptionError: If there is an error in publishing transcription.
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    proto_segments = [
        ProtoTranscriptionSegment(
            id=s.id,
            text=s.text,
            start_time=s.start_time,
            end_time=s.end_time,
            final=s.final,
            language=s.language,
        )
        for s in transcription.segments
    ]
    # fmt: off
    req.publish_transcription.local_participant_handle = self._ffi_handle.handle
    req.publish_transcription.participant_identity = transcription.participant_identity
    req.publish_transcription.segments.extend(proto_segments)
    req.publish_transcription.track_id = transcription.track_sid
    # fmt: on
    queue = FfiClient.instance.queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        cb: proto_ffi.FfiEvent = await queue.wait_for(
            lambda e: e.publish_transcription.async_id == resp.publish_transcription.async_id
        )
    finally:
        FfiClient.instance.queue.unsubscribe(queue)

    if cb.publish_transcription.error:
        raise PublishTranscriptionError(cb.publish_transcription.error)</code></pre>
</details>
<div class="desc"><p>Publish transcription data to the room.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transcription</code></strong> :&ensp;<code><a title="livekit.rtc.Transcription" href="#livekit.rtc.Transcription">Transcription</a></code></dt>
<dd>The transcription data to publish.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>PublishTranscriptionError</code></dt>
<dd>If there is an error in publishing transcription.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.register_rpc_method"><code class="name flex">
<span>def <span class="ident">register_rpc_method</span></span>(<span>self, method_name: str, handler: Optional[F] = None) ‑> ~F | Callable[[~F], ~F]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_rpc_method(
    self,
    method_name: str,
    handler: Optional[F] = None,
) -&gt; Union[F, Callable[[F], F]]:
    &#34;&#34;&#34;
    Establishes the participant as a receiver for calls of the specified RPC method.
    Can be used either as a decorator or a regular method.

    The handler will receive one argument of type `RpcInvocationData` and should return a string response which will be forwarded back to the caller.

    The handler may be synchronous or asynchronous.

    If unable to respond within `response_timeout`, the caller will hang up and receive an error on their side.

    You may raise errors of type `RpcError` in the handler, and they will be forwarded to the caller.

    Other errors raised in your handler will be caught and forwarded to the caller as &#34;1500 Application Error&#34;.

    Args:
        method_name (str): The name of the indicated RPC method.
        handler (Optional[Callable]): Handler to be invoked whenever an RPC request for this method is received.  Omit this argument to use the decorator syntax.

    Returns:
        None (when used as a decorator it returns the decorator function)

    Example:
        # As a decorator:
        @room.local_participant.register_rpc_method(&#34;greet&#34;)
        async def greet_handler(data: RpcInvocationData) -&gt; str:
            print(f&#34;Received greeting from {data.caller_identity}: {data.payload}&#34;)
            return f&#34;Hello, {data.caller_identity}!&#34;

        # As a regular method:
        async def greet_handler(data: RpcInvocationData) -&gt; str:
            print(f&#34;Received greeting from {data.caller_identity}: {data.payload}&#34;)
            return f&#34;Hello, {data.caller_identity}!&#34;

        room.local_participant.register_rpc_method(&#39;greet&#39;, greet_handler)
    &#34;&#34;&#34;

    def register(handler_func: F) -&gt; F:
        self._rpc_handlers[method_name] = handler_func
        req = proto_ffi.FfiRequest()
        req.register_rpc_method.local_participant_handle = self._ffi_handle.handle
        req.register_rpc_method.method = method_name
        FfiClient.instance.request(req)
        return handler_func

    if handler is not None:
        return register(handler)
    else:
        return register</code></pre>
</details>
<div class="desc"><p>Establishes the participant as a receiver for calls of the specified RPC method.
Can be used either as a decorator or a regular method.</p>
<p>The handler will receive one argument of type <code><a title="livekit.rtc.RpcInvocationData" href="#livekit.rtc.RpcInvocationData">RpcInvocationData</a></code> and should return a string response which will be forwarded back to the caller.</p>
<p>The handler may be synchronous or asynchronous.</p>
<p>If unable to respond within <code>response_timeout</code>, the caller will hang up and receive an error on their side.</p>
<p>You may raise errors of type <code><a title="livekit.rtc.RpcError" href="#livekit.rtc.RpcError">RpcError</a></code> in the handler, and they will be forwarded to the caller.</p>
<p>Other errors raised in your handler will be caught and forwarded to the caller as "1500 Application Error".</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the indicated RPC method.</dd>
<dt><strong><code>handler</code></strong> :&ensp;<code>Optional[Callable]</code></dt>
<dd>Handler to be invoked whenever an RPC request for this method is received.
Omit this argument to use the decorator syntax.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None (when used as a decorator it returns the decorator function)</p>
<h2 id="example">Example</h2>
<h1 id="as-a-decorator">As a decorator:</h1>
<p>@room.local_participant.register_rpc_method("greet")
async def greet_handler(data: RpcInvocationData) -&gt; str:
print(f"Received greeting from {data.caller_identity}: {data.payload}")
return f"Hello, {data.caller_identity}!"</p>
<h1 id="as-a-regular-method">As a regular method:</h1>
<p>async def greet_handler(data: RpcInvocationData) -&gt; str:
print(f"Received greeting from {data.caller_identity}: {data.payload}")
return f"Hello, {data.caller_identity}!"</p>
<p>room.local_participant.register_rpc_method('greet', greet_handler)</p></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.send_file"><code class="name flex">
<span>async def <span class="ident">send_file</span></span>(<span>self,<br>file_path: str,<br>*,<br>topic: str = '',<br>destination_identities: Optional[List[str]] = None,<br>attributes: Optional[Dict[str, str]] = None,<br>stream_id: str | None = None) ‑> <a title="livekit.rtc.data_stream.ByteStreamInfo" href="data_stream.html#livekit.rtc.data_stream.ByteStreamInfo">ByteStreamInfo</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_file(
    self,
    file_path: str,
    *,
    topic: str = &#34;&#34;,
    destination_identities: Optional[List[str]] = None,
    attributes: Optional[Dict[str, str]] = None,
    stream_id: str | None = None,
) -&gt; ByteStreamInfo:
    file_size = os.path.getsize(file_path)
    file_name = os.path.basename(file_path)
    mime_type, _ = mimetypes.guess_type(file_path)
    if mime_type is None:
        mime_type = &#34;application/octet-stream&#34;  # Fallback MIME type for unknown files

    writer: ByteStreamWriter = await self.stream_bytes(
        name=file_name,
        total_size=file_size,
        mime_type=mime_type,
        attributes=attributes,
        stream_id=stream_id,
        destination_identities=destination_identities,
        topic=topic,
    )

    async with aiofiles.open(file_path, &#34;rb&#34;) as f:
        while bytes := await f.read(STREAM_CHUNK_SIZE):
            await writer.write(bytes)
    await writer.aclose()

    return writer.info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.send_text"><code class="name flex">
<span>async def <span class="ident">send_text</span></span>(<span>self,<br>text: str,<br>*,<br>destination_identities: Optional[List[str]] = None,<br>topic: str = '',<br>attributes: Optional[Dict[str, str]] = None,<br>reply_to_id: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_text(
    self,
    text: str,
    *,
    destination_identities: Optional[List[str]] = None,
    topic: str = &#34;&#34;,
    attributes: Optional[Dict[str, str]] = None,
    reply_to_id: str | None = None,
):
    total_size = len(text.encode())
    writer = await self.stream_text(
        destination_identities=destination_identities,
        topic=topic,
        attributes=attributes,
        reply_to_id=reply_to_id,
        total_size=total_size,
    )

    await writer.write(text)
    await writer.aclose()

    return writer.info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.set_attributes"><code class="name flex">
<span>async def <span class="ident">set_attributes</span></span>(<span>self, attributes: dict[str, str]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_attributes(self, attributes: dict[str, str]) -&gt; None:
    &#34;&#34;&#34;
    Set custom attributes for the local participant.

    Note: this requires `canUpdateOwnMetadata` permission.

    Args:
        attributes (dict[str, str]): A dictionary of attributes to set.
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.set_local_attributes.local_participant_handle = self._ffi_handle.handle
    existing_attributes = {
        entry.key: entry.value for entry in req.set_local_attributes.attributes
    }
    existing_attributes.update(attributes)

    for key, value in existing_attributes.items():
        entry = req.set_local_attributes.attributes.add()
        entry.key = key
        entry.value = value

    queue = FfiClient.instance.queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        await queue.wait_for(
            lambda e: e.set_local_attributes.async_id == resp.set_local_attributes.async_id
        )
    finally:
        FfiClient.instance.queue.unsubscribe(queue)</code></pre>
</details>
<div class="desc"><p>Set custom attributes for the local participant.</p>
<p>Note: this requires <code>canUpdateOwnMetadata</code> permission.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attributes</code></strong> :&ensp;<code>dict[str, str]</code></dt>
<dd>A dictionary of attributes to set.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.set_metadata"><code class="name flex">
<span>async def <span class="ident">set_metadata</span></span>(<span>self, metadata: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_metadata(self, metadata: str) -&gt; None:
    &#34;&#34;&#34;
    Set the metadata for the local participant.

    Note: this requires `canUpdateOwnMetadata` permission.

    Args:
        metadata (str): The new metadata.
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.set_local_metadata.local_participant_handle = self._ffi_handle.handle
    req.set_local_metadata.metadata = metadata

    queue = FfiClient.instance.queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        await queue.wait_for(
            lambda e: e.set_local_metadata.async_id == resp.set_local_metadata.async_id
        )
    finally:
        FfiClient.instance.queue.unsubscribe(queue)</code></pre>
</details>
<div class="desc"><p>Set the metadata for the local participant.</p>
<p>Note: this requires <code>canUpdateOwnMetadata</code> permission.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metadata</code></strong> :&ensp;<code>str</code></dt>
<dd>The new metadata.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.set_name"><code class="name flex">
<span>async def <span class="ident">set_name</span></span>(<span>self, name: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_name(self, name: str) -&gt; None:
    &#34;&#34;&#34;
    Set the name for the local participant.

    Note: this requires `canUpdateOwnMetadata` permission.

    Args:
        name (str): The new name.
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.set_local_name.local_participant_handle = self._ffi_handle.handle
    req.set_local_name.name = name

    queue = FfiClient.instance.queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        await queue.wait_for(
            lambda e: e.set_local_name.async_id == resp.set_local_name.async_id
        )
    finally:
        FfiClient.instance.queue.unsubscribe(queue)</code></pre>
</details>
<div class="desc"><p>Set the name for the local participant.</p>
<p>Note: this requires <code>canUpdateOwnMetadata</code> permission.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The new name.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.set_track_subscription_permissions"><code class="name flex">
<span>def <span class="ident">set_track_subscription_permissions</span></span>(<span>self,<br>*,<br>allow_all_participants: bool,<br>participant_permissions: Optional[List[<a title="livekit.rtc.ParticipantTrackPermission" href="#livekit.rtc.ParticipantTrackPermission">ParticipantTrackPermission</a>]] = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_track_subscription_permissions(
    self,
    *,
    allow_all_participants: bool,
    participant_permissions: Optional[List[ParticipantTrackPermission]] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Set the track subscription permissions for the local participant.

    Args:
        allow_all_participants (bool): Whether to allow all participants to subscribe to this participant&#39;s tracks.
        participant_permissions (List[ParticipantTrackPermission]): Participant-specific track subscription permissions, ignored if `allow_all_participants` is True.
    &#34;&#34;&#34;
    if participant_permissions is None:
        participant_permissions = []

    req = proto_ffi.FfiRequest()
    req.set_track_subscription_permissions.local_participant_handle = self._ffi_handle.handle
    req.set_track_subscription_permissions.all_participants_allowed = allow_all_participants
    req.set_track_subscription_permissions.permissions.extend(participant_permissions)
    FfiClient.instance.request(req)</code></pre>
</details>
<div class="desc"><p>Set the track subscription permissions for the local participant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>allow_all_participants</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to allow all participants to subscribe to this participant's tracks.</dd>
<dt><strong><code>participant_permissions</code></strong> :&ensp;<code>List[<a title="livekit.rtc.ParticipantTrackPermission" href="#livekit.rtc.ParticipantTrackPermission">ParticipantTrackPermission</a>]</code></dt>
<dd>Participant-specific track subscription permissions, ignored if <code>allow_all_participants</code> is True.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.stream_bytes"><code class="name flex">
<span>async def <span class="ident">stream_bytes</span></span>(<span>self,<br>name: str,<br>*,<br>total_size: int | None = None,<br>mime_type: str = 'application/octet-stream',<br>attributes: Optional[Dict[str, str]] = None,<br>stream_id: str | None = None,<br>destination_identities: Optional[List[str]] = None,<br>topic: str = '') ‑> <a title="livekit.rtc.data_stream.ByteStreamWriter" href="data_stream.html#livekit.rtc.data_stream.ByteStreamWriter">ByteStreamWriter</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def stream_bytes(
    self,
    name: str,
    *,
    total_size: int | None = None,
    mime_type: str = &#34;application/octet-stream&#34;,
    attributes: Optional[Dict[str, str]] = None,
    stream_id: str | None = None,
    destination_identities: Optional[List[str]] = None,
    topic: str = &#34;&#34;,
) -&gt; ByteStreamWriter:
    &#34;&#34;&#34;
    Returns a ByteStreamWriter that allows to write individual chunks of bytes to a byte stream.
    In cases where you want to simply send a file from the file system use send_file() instead.
    &#34;&#34;&#34;
    writer = ByteStreamWriter(
        self,
        name=name,
        attributes=attributes,
        total_size=total_size,
        stream_id=stream_id,
        mime_type=mime_type,
        destination_identities=destination_identities,
        topic=topic,
    )

    await writer._send_header()

    return writer</code></pre>
</details>
<div class="desc"><p>Returns a ByteStreamWriter that allows to write individual chunks of bytes to a byte stream.
In cases where you want to simply send a file from the file system use send_file() instead.</p></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.stream_text"><code class="name flex">
<span>async def <span class="ident">stream_text</span></span>(<span>self,<br>*,<br>destination_identities: Optional[List[str]] = None,<br>topic: str = '',<br>attributes: Optional[Dict[str, str]] = None,<br>stream_id: str | None = None,<br>reply_to_id: str | None = None,<br>total_size: int | None = None,<br>sender_identity: str | None = None) ‑> <a title="livekit.rtc.data_stream.TextStreamWriter" href="data_stream.html#livekit.rtc.data_stream.TextStreamWriter">TextStreamWriter</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def stream_text(
    self,
    *,
    destination_identities: Optional[List[str]] = None,
    topic: str = &#34;&#34;,
    attributes: Optional[Dict[str, str]] = None,
    stream_id: str | None = None,
    reply_to_id: str | None = None,
    total_size: int | None = None,
    sender_identity: str | None = None,
) -&gt; TextStreamWriter:
    &#34;&#34;&#34;
    Returns a TextStreamWriter that allows to write individual chunks of text to a text stream.
    In most cases where you want to simply send a text message use send_text() instead.
    &#34;&#34;&#34;
    writer = TextStreamWriter(
        self,
        topic=topic,
        attributes=attributes,
        reply_to_id=reply_to_id,
        destination_identities=destination_identities,
        total_size=total_size,
        stream_id=stream_id,
        sender_identity=sender_identity,
    )

    await writer._send_header()

    return writer</code></pre>
</details>
<div class="desc"><p>Returns a TextStreamWriter that allows to write individual chunks of text to a text stream.
In most cases where you want to simply send a text message use send_text() instead.</p></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.unpublish_track"><code class="name flex">
<span>async def <span class="ident">unpublish_track</span></span>(<span>self, track_sid: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def unpublish_track(self, track_sid: str) -&gt; None:
    &#34;&#34;&#34;
    Unpublish a track from the room.

    Args:
        track_sid (str): The SID of the track to unpublish.

    Raises:
        UnpublishTrackError: If there is an error in unpublishing the track.
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.unpublish_track.local_participant_handle = self._ffi_handle.handle
    req.unpublish_track.track_sid = track_sid
    req.unpublish_track.stop_on_unpublish = True

    queue = self._room_queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        cb: proto_ffi.FfiEvent = await queue.wait_for(
            lambda e: e.unpublish_track.async_id == resp.unpublish_track.async_id
        )

        if cb.unpublish_track.error:
            raise UnpublishTrackError(cb.unpublish_track.error)

        publication = self._track_publications.pop(track_sid)
        publication._track = None
        queue.task_done()
    finally:
        self._room_queue.unsubscribe(queue)</code></pre>
</details>
<div class="desc"><p>Unpublish a track from the room.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>track_sid</code></strong> :&ensp;<code>str</code></dt>
<dd>The SID of the track to unpublish.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>UnpublishTrackError</code></dt>
<dd>If there is an error in unpublishing the track.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.LocalParticipant.unregister_rpc_method"><code class="name flex">
<span>def <span class="ident">unregister_rpc_method</span></span>(<span>self, method: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister_rpc_method(self, method: str) -&gt; None:
    &#34;&#34;&#34;
    Unregisters a previously registered RPC method.

    Args:
        method (str): The name of the RPC method to unregister
    &#34;&#34;&#34;
    self._rpc_handlers.pop(method, None)

    req = proto_ffi.FfiRequest()
    req.unregister_rpc_method.local_participant_handle = self._ffi_handle.handle
    req.unregister_rpc_method.method = method

    FfiClient.instance.request(req)</code></pre>
</details>
<div class="desc"><p>Unregisters a previously registered RPC method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the RPC method to unregister</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livekit.rtc.participant.Participant" href="participant.html#livekit.rtc.participant.Participant">Participant</a></b></code>:
<ul class="hlist">
<li><code><a title="livekit.rtc.participant.Participant.attributes" href="participant.html#livekit.rtc.participant.Participant.attributes">attributes</a></code></li>
<li><code><a title="livekit.rtc.participant.Participant.disconnect_reason" href="participant.html#livekit.rtc.participant.Participant.disconnect_reason">disconnect_reason</a></code></li>
<li><code><a title="livekit.rtc.participant.Participant.kind" href="participant.html#livekit.rtc.participant.Participant.kind">kind</a></code></li>
<li><code><a title="livekit.rtc.participant.Participant.track_publications" href="participant.html#livekit.rtc.participant.Participant.track_publications">track_publications</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livekit.rtc.LocalTrackPublication"><code class="flex name class">
<span>class <span class="ident">LocalTrackPublication</span></span>
<span>(</span><span>owned_info: track_pb2.OwnedTrackPublication)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocalTrackPublication(TrackPublication):
    def __init__(self, owned_info: proto_track.OwnedTrackPublication):
        super().__init__(owned_info)
        self._first_subscription: asyncio.Future[None] = asyncio.Future()

    @property
    def track(self) -&gt; Optional[LocalTrack]:
        return cast(Optional[LocalTrack], self._track)

    async def wait_for_subscription(self) -&gt; None:
        await asyncio.shield(self._first_subscription)

    def __repr__(self) -&gt; str:
        return f&#34;rtc.LocalTrackPublication(sid={self.sid}, name={self.name}, kind={self.kind}, source={self.source})&#34;</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.track_publication.TrackPublication" href="track_publication.html#livekit.rtc.track_publication.TrackPublication">TrackPublication</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.LocalTrackPublication.track"><code class="name">prop <span class="ident">track</span> : <a title="livekit.rtc.track.LocalVideoTrack" href="track.html#livekit.rtc.track.LocalVideoTrack">LocalVideoTrack</a> | <a title="livekit.rtc.track.LocalAudioTrack" href="track.html#livekit.rtc.track.LocalAudioTrack">LocalAudioTrack</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def track(self) -&gt; Optional[LocalTrack]:
    return cast(Optional[LocalTrack], self._track)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.LocalTrackPublication.wait_for_subscription"><code class="name flex">
<span>async def <span class="ident">wait_for_subscription</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_subscription(self) -&gt; None:
    await asyncio.shield(self._first_subscription)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.LocalVideoTrack"><code class="flex name class">
<span>class <span class="ident">LocalVideoTrack</span></span>
<span>(</span><span>info: track_pb2.OwnedTrack)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocalVideoTrack(Track):
    def __init__(self, info: proto_track.OwnedTrack):
        super().__init__(info)

    @staticmethod
    def create_video_track(name: str, source: &#34;VideoSource&#34;) -&gt; &#34;LocalVideoTrack&#34;:
        req = proto_ffi.FfiRequest()
        req.create_video_track.name = name
        req.create_video_track.source_handle = source._ffi_handle.handle

        resp = FfiClient.instance.request(req)
        return LocalVideoTrack(resp.create_video_track.track)

    def mute(self):
        req = proto_ffi.FfiRequest()
        req.local_track_mute.track_handle = self._ffi_handle.handle
        req.local_track_mute.mute = True
        FfiClient.instance.request(req)
        self._info.muted = True

    def unmute(self):
        req = proto_ffi.FfiRequest()
        req.local_track_mute.track_handle = self._ffi_handle.handle
        req.local_track_mute.mute = False
        FfiClient.instance.request(req)
        self._info.muted = False

    def __repr__(self) -&gt; str:
        return f&#34;rtc.LocalVideoTrack(sid={self.sid}, name={self.name})&#34;</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.track.Track" href="track.html#livekit.rtc.track.Track">Track</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="livekit.rtc.LocalVideoTrack.create_video_track"><code class="name flex">
<span>def <span class="ident">create_video_track</span></span>(<span>name: str,<br>source: <a title="livekit.rtc.VideoSource" href="#livekit.rtc.VideoSource">VideoSource</a>) ‑> <a title="livekit.rtc.LocalVideoTrack" href="#livekit.rtc.LocalVideoTrack">LocalVideoTrack</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_video_track(name: str, source: &#34;VideoSource&#34;) -&gt; &#34;LocalVideoTrack&#34;:
    req = proto_ffi.FfiRequest()
    req.create_video_track.name = name
    req.create_video_track.source_handle = source._ffi_handle.handle

    resp = FfiClient.instance.request(req)
    return LocalVideoTrack(resp.create_video_track.track)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.LocalVideoTrack.mute"><code class="name flex">
<span>def <span class="ident">mute</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mute(self):
    req = proto_ffi.FfiRequest()
    req.local_track_mute.track_handle = self._ffi_handle.handle
    req.local_track_mute.mute = True
    FfiClient.instance.request(req)
    self._info.muted = True</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.LocalVideoTrack.unmute"><code class="name flex">
<span>def <span class="ident">unmute</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unmute(self):
    req = proto_ffi.FfiRequest()
    req.local_track_mute.track_handle = self._ffi_handle.handle
    req.local_track_mute.mute = False
    FfiClient.instance.request(req)
    self._info.muted = False</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.NoiseCancellationOptions"><code class="flex name class">
<span>class <span class="ident">NoiseCancellationOptions</span></span>
<span>(</span><span>module_id: str, options: dict[str, Any])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class NoiseCancellationOptions:
    module_id: str
    options: dict[str, Any]</code></pre>
</details>
<div class="desc"><p>NoiseCancellationOptions(module_id: 'str', options: 'dict[str, Any]')</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.NoiseCancellationOptions.module_id"><code class="name">var <span class="ident">module_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.NoiseCancellationOptions.options"><code class="name">var <span class="ident">options</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.Participant"><code class="flex name class">
<span>class <span class="ident">Participant</span></span>
<span>(</span><span>owned_info: proto_participant.OwnedParticipant)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Participant(ABC):
    def __init__(self, owned_info: proto_participant.OwnedParticipant) -&gt; None:
        self._info = owned_info.info
        self._ffi_handle = FfiHandle(owned_info.handle.id)

    @property
    @abstractmethod
    def track_publications(self) -&gt; Mapping[str, TrackPublication]:
        &#34;&#34;&#34;
        A dictionary of track publications associated with the participant.
        &#34;&#34;&#34;
        ...

    @property
    def sid(self) -&gt; str:
        return self._info.sid

    @property
    def name(self) -&gt; str:
        return self._info.name

    @property
    def identity(self) -&gt; str:
        return self._info.identity

    @property
    def metadata(self) -&gt; str:
        return self._info.metadata

    @property
    def attributes(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Custom attributes associated with the participant.&#34;&#34;&#34;
        return dict(self._info.attributes)

    @property
    def kind(self) -&gt; proto_participant.ParticipantKind.ValueType:
        &#34;&#34;&#34;Participant&#39;s kind (e.g., regular participant, ingress, egress, sip, agent).&#34;&#34;&#34;
        return self._info.kind

    @property
    def disconnect_reason(
        self,
    ) -&gt; Optional[proto_participant.DisconnectReason.ValueType]:
        &#34;&#34;&#34;Reason for the participant&#39;s disconnection.

        Returns one of DisconnectReasons or None if the participant isn&#39;t disconnected. Common reasons are:
        - CLIENT_INITIATED - the client initiated the disconnect
        - DUPLICATE_IDENTITY - another participant with the same identity has joined the room
        - SERVER_SHUTDOWN - the server instance is shutting down
        - PARTICIPANT_REMOVED - RoomService.RemoveParticipant was called
        - ROOM_DELETED - RoomService.DeleteRoom was called
        - STATE_MISMATCH - the client is attempting to resume a session, but server is not aware of it
        - JOIN_FAILURE - client was unable to connect fully

        When dialing a participant via SIP, you may see the following reasons:
        - USER_UNAVAILABLE - SIP callee did not respond in time
        - USER_REJECTED - SIP callee rejected the call (busy)
        - SIP_TRUNK_FAILURE - SIP protocol failure or unexpected response
        &#34;&#34;&#34;
        if self._info.disconnect_reason == proto_participant.DisconnectReason.UNKNOWN_REASON:
            return None
        return self._info.disconnect_reason</code></pre>
</details>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="livekit.rtc.participant.LocalParticipant" href="participant.html#livekit.rtc.participant.LocalParticipant">LocalParticipant</a></li>
<li><a title="livekit.rtc.participant.RemoteParticipant" href="participant.html#livekit.rtc.participant.RemoteParticipant">RemoteParticipant</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.Participant.attributes"><code class="name">prop <span class="ident">attributes</span> : dict[str, str]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def attributes(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Custom attributes associated with the participant.&#34;&#34;&#34;
    return dict(self._info.attributes)</code></pre>
</details>
<div class="desc"><p>Custom attributes associated with the participant.</p></div>
</dd>
<dt id="livekit.rtc.Participant.disconnect_reason"><code class="name">prop <span class="ident">disconnect_reason</span> : Optional[proto_participant.DisconnectReason.ValueType]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def disconnect_reason(
    self,
) -&gt; Optional[proto_participant.DisconnectReason.ValueType]:
    &#34;&#34;&#34;Reason for the participant&#39;s disconnection.

    Returns one of DisconnectReasons or None if the participant isn&#39;t disconnected. Common reasons are:
    - CLIENT_INITIATED - the client initiated the disconnect
    - DUPLICATE_IDENTITY - another participant with the same identity has joined the room
    - SERVER_SHUTDOWN - the server instance is shutting down
    - PARTICIPANT_REMOVED - RoomService.RemoveParticipant was called
    - ROOM_DELETED - RoomService.DeleteRoom was called
    - STATE_MISMATCH - the client is attempting to resume a session, but server is not aware of it
    - JOIN_FAILURE - client was unable to connect fully

    When dialing a participant via SIP, you may see the following reasons:
    - USER_UNAVAILABLE - SIP callee did not respond in time
    - USER_REJECTED - SIP callee rejected the call (busy)
    - SIP_TRUNK_FAILURE - SIP protocol failure or unexpected response
    &#34;&#34;&#34;
    if self._info.disconnect_reason == proto_participant.DisconnectReason.UNKNOWN_REASON:
        return None
    return self._info.disconnect_reason</code></pre>
</details>
<div class="desc"><p>Reason for the participant's disconnection.</p>
<p>Returns one of DisconnectReasons or None if the participant isn't disconnected. Common reasons are:
- CLIENT_INITIATED - the client initiated the disconnect
- DUPLICATE_IDENTITY - another participant with the same identity has joined the room
- SERVER_SHUTDOWN - the server instance is shutting down
- PARTICIPANT_REMOVED - RoomService.RemoveParticipant was called
- ROOM_DELETED - RoomService.DeleteRoom was called
- STATE_MISMATCH - the client is attempting to resume a session, but server is not aware of it
- JOIN_FAILURE - client was unable to connect fully</p>
<p>When dialing a participant via SIP, you may see the following reasons:
- USER_UNAVAILABLE - SIP callee did not respond in time
- USER_REJECTED - SIP callee rejected the call (busy)
- SIP_TRUNK_FAILURE - SIP protocol failure or unexpected response</p></div>
</dd>
<dt id="livekit.rtc.Participant.identity"><code class="name">prop <span class="ident">identity</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def identity(self) -&gt; str:
    return self._info.identity</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.Participant.kind"><code class="name">prop <span class="ident">kind</span> : proto_participant.ParticipantKind.ValueType</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kind(self) -&gt; proto_participant.ParticipantKind.ValueType:
    &#34;&#34;&#34;Participant&#39;s kind (e.g., regular participant, ingress, egress, sip, agent).&#34;&#34;&#34;
    return self._info.kind</code></pre>
</details>
<div class="desc"><p>Participant's kind (e.g., regular participant, ingress, egress, sip, agent).</p></div>
</dd>
<dt id="livekit.rtc.Participant.metadata"><code class="name">prop <span class="ident">metadata</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self) -&gt; str:
    return self._info.metadata</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.Participant.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    return self._info.name</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.Participant.sid"><code class="name">prop <span class="ident">sid</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sid(self) -&gt; str:
    return self._info.sid</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.Participant.track_publications"><code class="name">prop <span class="ident">track_publications</span> : Mapping[str, <a title="livekit.rtc.TrackPublication" href="#livekit.rtc.TrackPublication">TrackPublication</a>]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def track_publications(self) -&gt; Mapping[str, TrackPublication]:
    &#34;&#34;&#34;
    A dictionary of track publications associated with the participant.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
<div class="desc"><p>A dictionary of track publications associated with the participant.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.ParticipantTrackPermission"><code class="flex name class">
<span>class <span class="ident">ParticipantTrackPermission</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>google._upb._message.Message</li>
<li>google.protobuf.message.Message</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.rtc.ParticipantTrackPermission.DESCRIPTOR"><code class="name">var <span class="ident">DESCRIPTOR</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.RemoteAudioTrack"><code class="flex name class">
<span>class <span class="ident">RemoteAudioTrack</span></span>
<span>(</span><span>info: track_pb2.OwnedTrack)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RemoteAudioTrack(Track):
    def __init__(self, info: proto_track.OwnedTrack):
        super().__init__(info)

    def __repr__(self) -&gt; str:
        return f&#34;rtc.RemoteAudioTrack(sid={self.sid}, name={self.name})&#34;</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.track.Track" href="track.html#livekit.rtc.track.Track">Track</a></li>
</ul>
</dd>
<dt id="livekit.rtc.RemoteParticipant"><code class="flex name class">
<span>class <span class="ident">RemoteParticipant</span></span>
<span>(</span><span>owned_info: proto_participant.OwnedParticipant)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RemoteParticipant(Participant):
    def __init__(self, owned_info: proto_participant.OwnedParticipant) -&gt; None:
        super().__init__(owned_info)
        self._track_publications: dict[str, RemoteTrackPublication] = {}  # type: ignore

    @property
    def track_publications(self) -&gt; Mapping[str, RemoteTrackPublication]:
        &#34;&#34;&#34;
        A dictionary of track publications associated with the participant.
        &#34;&#34;&#34;
        return self._track_publications

    def __repr__(self) -&gt; str:
        return f&#34;rtc.RemoteParticipant(sid={self.sid}, identity={self.identity}, name={self.name})&#34;</code></pre>
</details>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.participant.Participant" href="participant.html#livekit.rtc.participant.Participant">Participant</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livekit.rtc.participant.Participant" href="participant.html#livekit.rtc.participant.Participant">Participant</a></b></code>:
<ul class="hlist">
<li><code><a title="livekit.rtc.participant.Participant.attributes" href="participant.html#livekit.rtc.participant.Participant.attributes">attributes</a></code></li>
<li><code><a title="livekit.rtc.participant.Participant.disconnect_reason" href="participant.html#livekit.rtc.participant.Participant.disconnect_reason">disconnect_reason</a></code></li>
<li><code><a title="livekit.rtc.participant.Participant.kind" href="participant.html#livekit.rtc.participant.Participant.kind">kind</a></code></li>
<li><code><a title="livekit.rtc.participant.Participant.track_publications" href="participant.html#livekit.rtc.participant.Participant.track_publications">track_publications</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livekit.rtc.RemoteTrackPublication"><code class="flex name class">
<span>class <span class="ident">RemoteTrackPublication</span></span>
<span>(</span><span>owned_info: track_pb2.OwnedTrackPublication)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RemoteTrackPublication(TrackPublication):
    def __init__(self, owned_info: proto_track.OwnedTrackPublication):
        super().__init__(owned_info)
        self._subscribed = False

    @property
    def track(self) -&gt; Optional[RemoteTrack]:
        return cast(Optional[RemoteTrack], self._track)

    @property
    def subscribed(self) -&gt; bool:
        return self._subscribed

    def set_subscribed(self, subscribed: bool):
        req = proto_ffi.FfiRequest()
        req.set_subscribed.subscribe = subscribed
        req.set_subscribed.publication_handle = self._ffi_handle.handle
        FfiClient.instance.request(req)

    def __repr__(self) -&gt; str:
        return f&#34;rtc.RemoteTrackPublication(sid={self.sid}, name={self.name}, kind={self.kind}, source={self.source})&#34;</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.track_publication.TrackPublication" href="track_publication.html#livekit.rtc.track_publication.TrackPublication">TrackPublication</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.RemoteTrackPublication.subscribed"><code class="name">prop <span class="ident">subscribed</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def subscribed(self) -&gt; bool:
    return self._subscribed</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.RemoteTrackPublication.track"><code class="name">prop <span class="ident">track</span> : <a title="livekit.rtc.track.RemoteVideoTrack" href="track.html#livekit.rtc.track.RemoteVideoTrack">RemoteVideoTrack</a> | <a title="livekit.rtc.track.RemoteAudioTrack" href="track.html#livekit.rtc.track.RemoteAudioTrack">RemoteAudioTrack</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def track(self) -&gt; Optional[RemoteTrack]:
    return cast(Optional[RemoteTrack], self._track)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.RemoteTrackPublication.set_subscribed"><code class="name flex">
<span>def <span class="ident">set_subscribed</span></span>(<span>self, subscribed: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_subscribed(self, subscribed: bool):
    req = proto_ffi.FfiRequest()
    req.set_subscribed.subscribe = subscribed
    req.set_subscribed.publication_handle = self._ffi_handle.handle
    FfiClient.instance.request(req)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.RemoteVideoTrack"><code class="flex name class">
<span>class <span class="ident">RemoteVideoTrack</span></span>
<span>(</span><span>info: track_pb2.OwnedTrack)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RemoteVideoTrack(Track):
    def __init__(self, info: proto_track.OwnedTrack):
        super().__init__(info)

    def __repr__(self) -&gt; str:
        return f&#34;rtc.RemoteVideoTrack(sid={self.sid}, name={self.name})&#34;</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.track.Track" href="track.html#livekit.rtc.track.Track">Track</a></li>
</ul>
</dd>
<dt id="livekit.rtc.Room"><code class="flex name class">
<span>class <span class="ident">Room</span></span>
<span>(</span><span>loop: Optional[asyncio.AbstractEventLoop] = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Room(EventEmitter[EventTypes]):
    def __init__(
        self,
        loop: Optional[asyncio.AbstractEventLoop] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initializes a new Room instance.

        Parameters:
            loop (Optional[asyncio.AbstractEventLoop]): The event loop to use. If not provided, the default event loop is used.
        &#34;&#34;&#34;
        super().__init__()

        self._ffi_handle: Optional[FfiHandle] = None
        self._loop = loop or asyncio.get_event_loop()
        self._room_queue = BroadcastQueue[proto_ffi.FfiEvent]()
        self._info = proto_room.RoomInfo()
        self._rpc_invocation_tasks: set[asyncio.Task] = set()
        self._data_stream_tasks: set[asyncio.Task] = set()

        self._remote_participants: Dict[str, RemoteParticipant] = {}
        self._connection_state = ConnectionState.CONN_DISCONNECTED
        self._first_sid_future = asyncio.Future[str]()
        self._local_participant: LocalParticipant | None = None

        self._text_stream_readers: Dict[str, TextStreamReader] = {}
        self._byte_stream_readers: Dict[str, ByteStreamReader] = {}
        self._text_stream_handlers: Dict[str, TextStreamHandler] = {}
        self._byte_stream_handlers: Dict[str, ByteStreamHandler] = {}

    def __del__(self) -&gt; None:
        if self._ffi_handle is not None:
            FfiClient.instance.queue.unsubscribe(self._ffi_queue)

    @property
    async def sid(self) -&gt; str:
        &#34;&#34;&#34;Asynchronously retrieves the session ID (SID) of the room.

        Returns:
            str: The session ID of the room.
        &#34;&#34;&#34;
        if self._info.sid:
            return self._info.sid

        return await self._first_sid_future

    @property
    def local_participant(self) -&gt; LocalParticipant:
        &#34;&#34;&#34;Gets the local participant in the room.

        Returns:
            LocalParticipant: The local participant in the room.
        &#34;&#34;&#34;
        if self._local_participant is None:
            raise Exception(&#34;cannot access local participant before connecting&#34;)

        return self._local_participant

    @property
    def connection_state(self) -&gt; ConnectionState.ValueType:
        &#34;&#34;&#34;Gets the connection state of the room.

        Returns:
            ConnectionState: The connection state of the room.
        &#34;&#34;&#34;
        return self._connection_state

    @property
    def remote_participants(self) -&gt; Mapping[str, RemoteParticipant]:
        &#34;&#34;&#34;Gets the remote participants in the room.

        Returns:
            dict[str, RemoteParticipant]: A dictionary of remote participants indexed by their
            identity.
        &#34;&#34;&#34;
        return self._remote_participants

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Gets the name of the room.

        Returns:
            str: The name of the room.
        &#34;&#34;&#34;
        return self._info.name

    @property
    def metadata(self) -&gt; str:
        &#34;&#34;&#34;Gets the metadata associated with the room.

        Returns:
            str: The metadata of the room.
        &#34;&#34;&#34;
        return self._info.metadata

    @property
    def e2ee_manager(self) -&gt; E2EEManager:
        &#34;&#34;&#34;Gets the end-to-end encryption (E2EE) manager for the room.

        Returns:
            E2EEManager: The E2EE manager instance.
        &#34;&#34;&#34;
        return self._e2ee_manager

    def isconnected(self) -&gt; bool:
        &#34;&#34;&#34;Checks if the room is currently connected.

        Returns:
            bool: True if connected, False otherwise.
        &#34;&#34;&#34;
        return (
            self._ffi_handle is not None
            and self._connection_state != ConnectionState.CONN_DISCONNECTED
        )

    def on(self, event: EventTypes, callback: Optional[Callable] = None) -&gt; Callable:
        &#34;&#34;&#34;Registers an event handler for a specific event type.

        Parameters:
            event (EventTypes): The name of the event to listen for.
            callback (Callable): The function to call when the event occurs.

        Returns:
            Callable: The registered callback function.

        Available events:
            - **&#34;participant_connected&#34;**: Called when a new participant joins the room.
                - Arguments: `participant` (RemoteParticipant)
            - **&#34;participant_disconnected&#34;**: Called when a participant leaves the room.
                - Arguments: `participant` (RemoteParticipant)
            - **&#34;local_track_published&#34;**: Called when a local track is published.
                - Arguments: `publication` (LocalTrackPublication), `track` (Track)
            - **&#34;local_track_unpublished&#34;**: Called when a local track is unpublished.
                - Arguments: `publication` (LocalTrackPublication)
            - **&#34;local_track_subscribed&#34;**: Called when a local track is subscribed.
                - Arguments: `track` (Track)
            - **&#34;track_published&#34;**: Called when a remote participant publishes a track.
                - Arguments: `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
            - **&#34;track_unpublished&#34;**: Called when a remote participant unpublishes a track.
                - Arguments: `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
            - **&#34;track_subscribed&#34;**: Called when a track is subscribed.
                - Arguments: `track` (Track), `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
            - **&#34;track_unsubscribed&#34;**: Called when a track is unsubscribed.
                - Arguments: `track` (Track), `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
            - **&#34;track_subscription_failed&#34;**: Called when a track subscription fails.
                - Arguments: `participant` (RemoteParticipant), `track_sid` (str), `error` (str)
            - **&#34;track_muted&#34;**: Called when a track is muted.
                - Arguments: `participant` (Participant), `publication` (TrackPublication)
            - **&#34;track_unmuted&#34;**: Called when a track is unmuted.
                - Arguments: `participant` (Participant), `publication` (TrackPublication)
            - **&#34;active_speakers_changed&#34;**: Called when the list of active speakers changes.
                - Arguments: `speakers` (list[Participant])
            - **&#34;room_metadata_changed&#34;**: Called when the room&#39;s metadata is updated.
                - Arguments: `old_metadata` (str), `new_metadata` (str)
            - **&#34;participant_metadata_changed&#34;**: Called when a participant&#39;s metadata is updated.
                - Arguments: `participant` (Participant), `old_metadata` (str), `new_metadata` (str)
            - **&#34;participant_name_changed&#34;**: Called when a participant&#39;s name is changed.
                - Arguments: `participant` (Participant), `old_name` (str), `new_name` (str)
            - **&#34;participant_attributes_changed&#34;**: Called when a participant&#39;s attributes change.
                - Arguments: `changed_attributes` (dict), `participant` (Participant)
            - **&#34;connection_quality_changed&#34;**: Called when a participant&#39;s connection quality changes.
                - Arguments: `participant` (Participant), `quality` (ConnectionQuality)
            - **&#34;transcription_received&#34;**: Called when a transcription is received.
                - Arguments: `segments` (list[TranscriptionSegment]), `participant` (Participant), `publication` (TrackPublication)
            - **&#34;data_received&#34;**: Called when data is received.
                - Arguments: `data_packet` (DataPacket)
            - **&#34;sip_dtmf_received&#34;**: Called when a SIP DTMF signal is received.
                - Arguments: `sip_dtmf` (SipDTMF)
            - **&#34;e2ee_state_changed&#34;**: Called when a participant&#39;s E2EE state changes.
                - Arguments: `participant` (Participant), `state` (EncryptionState)
            - **&#34;connection_state_changed&#34;**: Called when the room&#39;s connection state changes.
                - Arguments: `connection_state` (ConnectionState)
            - **&#34;connected&#34;**: Called when the room is successfully connected.
                - Arguments: None
            - **&#34;disconnected&#34;**: Called when the room is disconnected.
                - Arguments: `reason` (DisconnectReason)
            - **&#34;reconnecting&#34;**: Called when the room is attempting to reconnect.
                - Arguments: None
            - **&#34;reconnected&#34;**: Called when the room has successfully reconnected.
                - Arguments: None

        Example:
            ```python
            def on_participant_connected(participant):
                print(f&#34;Participant connected: {participant.identity}&#34;)

            room.on(&#34;participant_connected&#34;, on_participant_connected)
            ```
        &#34;&#34;&#34;
        return super().on(event, callback)

    async def connect(self, url: str, token: str, options: RoomOptions = RoomOptions()) -&gt; None:
        &#34;&#34;&#34;Connects to a LiveKit room using the specified URL and token.

        Parameters:
            url (str): The WebSocket URL of the LiveKit server to connect to.
            token (str): The access token for authentication and authorization.
            options (RoomOptions, optional): Additional options for the room connection.

        Raises:
            ConnectError: If the connection fails.

        Example:
            ```python
            room = Room()

            # Listen for events before connecting to the room
            @room.on(&#34;participant_connected&#34;)
            def on_participant_connected(participant):
                print(f&#34;Participant connected: {participant.identity}&#34;)

            await room.connect(&#34;ws://localhost:7880&#34;, &#34;your_token&#34;)
            ```
        &#34;&#34;&#34;
        req = proto_ffi.FfiRequest()
        req.connect.url = url
        req.connect.token = token

        # options
        req.connect.options.auto_subscribe = options.auto_subscribe
        req.connect.options.dynacast = options.dynacast

        if options.e2ee:
            req.connect.options.e2ee.encryption_type = options.e2ee.encryption_type
            req.connect.options.e2ee.key_provider_options.shared_key = (
                options.e2ee.key_provider_options.shared_key  # type: ignore
            )
            req.connect.options.e2ee.key_provider_options.ratchet_salt = (
                options.e2ee.key_provider_options.ratchet_salt
            )
            req.connect.options.e2ee.key_provider_options.failure_tolerance = (
                options.e2ee.key_provider_options.failure_tolerance
            )
            req.connect.options.e2ee.key_provider_options.ratchet_window_size = (
                options.e2ee.key_provider_options.ratchet_window_size
            )

        if options.rtc_config:
            req.connect.options.rtc_config.ice_transport_type = (
                options.rtc_config.ice_transport_type
            )  # type: ignore
            req.connect.options.rtc_config.continual_gathering_policy = (
                options.rtc_config.continual_gathering_policy
            )  # type: ignore
            req.connect.options.rtc_config.ice_servers.extend(options.rtc_config.ice_servers)

        # subscribe before connecting so we don&#39;t miss any events
        self._ffi_queue = FfiClient.instance.queue.subscribe(self._loop)

        queue = FfiClient.instance.queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            cb: proto_ffi.FfiEvent = await queue.wait_for(
                lambda e: e.connect.async_id == resp.connect.async_id
            )
        finally:
            FfiClient.instance.queue.unsubscribe(queue)

        if cb.connect.error:
            FfiClient.instance.queue.unsubscribe(self._ffi_queue)
            raise ConnectError(cb.connect.error)

        self._ffi_handle = FfiHandle(cb.connect.result.room.handle.id)

        self._e2ee_manager = E2EEManager(self._ffi_handle.handle, options.e2ee)

        self._info = cb.connect.result.room.info
        self._connection_state = ConnectionState.CONN_CONNECTED

        self._local_participant = LocalParticipant(
            self._room_queue, cb.connect.result.local_participant
        )

        for pt in cb.connect.result.participants:
            rp = self._create_remote_participant(pt.participant)

            # add the initial remote participant tracks
            for owned_publication_info in pt.publications:
                publication = RemoteTrackPublication(owned_publication_info)
                rp._track_publications[publication.sid] = publication

        # start listening to room events
        self._task = self._loop.create_task(self._listen_task())

    def register_byte_stream_handler(self, topic: str, handler: ByteStreamHandler):
        existing_handler = self._byte_stream_handlers.get(topic)
        if existing_handler is None:
            self._byte_stream_handlers[topic] = handler
        else:
            raise ValueError(&#34;byte stream handler for topic &#39;%s&#39; already set&#34; % topic)

    def unregister_byte_stream_handler(self, topic: str):
        if self._byte_stream_handlers.get(topic):
            self._byte_stream_handlers.pop(topic)

    def register_text_stream_handler(self, topic: str, handler: TextStreamHandler):
        existing_handler = self._text_stream_handlers.get(topic)
        if existing_handler is None:
            self._text_stream_handlers[topic] = handler
        else:
            raise ValueError(&#34;text stream handler for topic &#39;%s&#39; already set&#34; % topic)

    def unregister_text_stream_handler(self, topic: str):
        if self._text_stream_handlers.get(topic):
            self._text_stream_handlers.pop(topic)

    async def disconnect(self) -&gt; None:
        &#34;&#34;&#34;Disconnects from the room.&#34;&#34;&#34;
        if not self.isconnected():
            return

        await self._drain_rpc_invocation_tasks()
        await self._drain_data_stream_tasks()

        req = proto_ffi.FfiRequest()
        req.disconnect.room_handle = self._ffi_handle.handle  # type: ignore
        queue = FfiClient.instance.queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            await queue.wait_for(lambda e: e.disconnect.async_id == resp.disconnect.async_id)
        finally:
            FfiClient.instance.queue.unsubscribe(queue)
        await self._task
        FfiClient.instance.queue.unsubscribe(self._ffi_queue)

    async def _listen_task(self) -&gt; None:
        # listen to incoming room events
        while True:
            event = await self._ffi_queue.get()
            if event.WhichOneof(&#34;message&#34;) == &#34;rpc_method_invocation&#34;:
                self._on_rpc_method_invocation(event.rpc_method_invocation)
            elif event.room_event.room_handle == self._ffi_handle.handle:  # type: ignore
                if event.room_event.HasField(&#34;eos&#34;):
                    break

                try:
                    self._on_room_event(event.room_event)
                except Exception:
                    logging.exception(
                        &#34;error running user callback for %s: %s&#34;,
                        event.room_event.WhichOneof(&#34;message&#34;),
                        event.room_event,
                    )

            # wait for the subscribers to process the event
            # before processing the next one
            self._room_queue.put_nowait(event)
            await self._room_queue.join()

        # Clean up any pending RPC invocation tasks
        await self._drain_rpc_invocation_tasks()
        await self._drain_data_stream_tasks()

    def _on_rpc_method_invocation(self, rpc_invocation: RpcMethodInvocationEvent):
        if self._local_participant is None:
            return

        if rpc_invocation.local_participant_handle == self._local_participant._ffi_handle.handle:
            task = self._loop.create_task(
                self._local_participant._handle_rpc_method_invocation(
                    rpc_invocation.invocation_id,
                    rpc_invocation.method,
                    rpc_invocation.request_id,
                    rpc_invocation.caller_identity,
                    rpc_invocation.payload,
                    rpc_invocation.response_timeout_ms / 1000.0,
                )
            )
            self._rpc_invocation_tasks.add(task)
            task.add_done_callback(self._rpc_invocation_tasks.discard)

    def _on_room_event(self, event: proto_room.RoomEvent):
        which = event.WhichOneof(&#34;message&#34;)
        if which == &#34;participant_connected&#34;:
            rparticipant = self._create_remote_participant(event.participant_connected.info)
            self.emit(&#34;participant_connected&#34;, rparticipant)
        elif which == &#34;participant_disconnected&#34;:
            identity = event.participant_disconnected.participant_identity
            rparticipant = self._remote_participants.pop(identity)
            rparticipant._info.disconnect_reason = event.participant_disconnected.disconnect_reason
            self.emit(&#34;participant_disconnected&#34;, rparticipant)
        elif which == &#34;local_track_published&#34;:
            sid = event.local_track_published.track_sid
            lpublication = self.local_participant.track_publications[sid]
            ltrack = lpublication.track
            self.emit(&#34;local_track_published&#34;, lpublication, ltrack)
        elif which == &#34;local_track_unpublished&#34;:
            sid = event.local_track_unpublished.publication_sid
            lpublication = self.local_participant.track_publications[sid]
            self.emit(&#34;local_track_unpublished&#34;, lpublication)
        elif which == &#34;local_track_subscribed&#34;:
            sid = event.local_track_subscribed.track_sid
            lpublication = self.local_participant.track_publications[sid]
            lpublication._first_subscription.set_result(None)
            self.emit(&#34;local_track_subscribed&#34;, lpublication.track)
        elif which == &#34;track_published&#34;:
            rparticipant = self._remote_participants[event.track_published.participant_identity]
            rpublication = RemoteTrackPublication(event.track_published.publication)
            rparticipant._track_publications[rpublication.sid] = rpublication
            self.emit(&#34;track_published&#34;, rpublication, rparticipant)
        elif which == &#34;track_unpublished&#34;:
            rparticipant = self._remote_participants[event.track_unpublished.participant_identity]
            rpublication = rparticipant._track_publications.pop(
                event.track_unpublished.publication_sid
            )
            self.emit(&#34;track_unpublished&#34;, rpublication, rparticipant)
        elif which == &#34;track_subscribed&#34;:
            owned_track_info = event.track_subscribed.track
            track_info = owned_track_info.info
            rparticipant = self._remote_participants[event.track_subscribed.participant_identity]
            rpublication = rparticipant.track_publications[track_info.sid]
            rpublication._subscribed = True
            if track_info.kind == TrackKind.KIND_VIDEO:
                remote_video_track = RemoteVideoTrack(owned_track_info)
                rpublication._track = remote_video_track
                self.emit(&#34;track_subscribed&#34;, remote_video_track, rpublication, rparticipant)
            elif track_info.kind == TrackKind.KIND_AUDIO:
                remote_audio_track = RemoteAudioTrack(owned_track_info)
                rpublication._track = remote_audio_track
                self.emit(&#34;track_subscribed&#34;, remote_audio_track, rpublication, rparticipant)
        elif which == &#34;track_unsubscribed&#34;:
            identity = event.track_unsubscribed.participant_identity
            rparticipant = self._remote_participants[identity]
            rpublication = rparticipant.track_publications[event.track_unsubscribed.track_sid]
            rtrack = rpublication.track
            rpublication._track = None
            rpublication._subscribed = False
            self.emit(&#34;track_unsubscribed&#34;, rtrack, rpublication, rparticipant)
        elif which == &#34;track_subscription_failed&#34;:
            identity = event.track_subscription_failed.participant_identity
            rparticipant = self._remote_participants[identity]
            error = event.track_subscription_failed.error
            self.emit(
                &#34;track_subscription_failed&#34;,
                rparticipant,
                event.track_subscription_failed.track_sid,
                error,
            )
        elif which == &#34;track_muted&#34;:
            identity = event.track_muted.participant_identity
            # TODO: pass participant identity
            participant = self._retrieve_participant(identity)
            assert isinstance(participant, Participant)
            publication = participant.track_publications[event.track_muted.track_sid]
            publication._info.muted = True
            if publication.track:
                publication.track._info.muted = True

            self.emit(&#34;track_muted&#34;, participant, publication)
        elif which == &#34;track_unmuted&#34;:
            identity = event.track_unmuted.participant_identity
            # TODO: pass participant identity
            participant = self._retrieve_participant(identity)
            assert isinstance(participant, Participant)
            publication = participant.track_publications[event.track_unmuted.track_sid]
            publication._info.muted = False
            if publication.track:
                publication.track._info.muted = False

            self.emit(&#34;track_unmuted&#34;, participant, publication)
        elif which == &#34;active_speakers_changed&#34;:
            speakers: list[Participant] = []
            # TODO: pass participant identity
            for identity in event.active_speakers_changed.participant_identities:
                participant = self._retrieve_participant(identity)
                assert isinstance(participant, Participant)
                speakers.append(participant)

            self.emit(&#34;active_speakers_changed&#34;, speakers)
        elif which == &#34;room_metadata_changed&#34;:
            old_metadata = self.metadata
            self._info.metadata = event.room_metadata_changed.metadata
            self.emit(&#34;room_metadata_changed&#34;, old_metadata, self.metadata)
        elif which == &#34;room_sid_changed&#34;:
            if not self._info.sid:
                self._first_sid_future.set_result(event.room_sid_changed.sid)
            self._info.sid = event.room_sid_changed.sid
            # This is an internal event, not exposed to users
        elif which == &#34;participant_metadata_changed&#34;:
            identity = event.participant_metadata_changed.participant_identity
            # TODO: pass participant identity
            participant = self._retrieve_participant(identity)
            assert isinstance(participant, Participant)
            old_metadata = participant.metadata
            participant._info.metadata = event.participant_metadata_changed.metadata
            self.emit(
                &#34;participant_metadata_changed&#34;,
                participant,
                old_metadata,
                participant.metadata,
            )
        elif which == &#34;participant_name_changed&#34;:
            identity = event.participant_name_changed.participant_identity
            participant = self._retrieve_participant(identity)
            assert isinstance(participant, Participant)
            old_name = participant.name
            participant._info.name = event.participant_name_changed.name
            self.emit(&#34;participant_name_changed&#34;, participant, old_name, participant.name)
        elif which == &#34;participant_attributes_changed&#34;:
            identity = event.participant_attributes_changed.participant_identity
            attributes = event.participant_attributes_changed.attributes
            changed_attributes = dict(
                (entry.key, entry.value)
                for entry in event.participant_attributes_changed.changed_attributes
            )
            participant = self._retrieve_participant(identity)
            assert isinstance(participant, Participant)
            participant._info.attributes.clear()
            participant._info.attributes.update((entry.key, entry.value) for entry in attributes)
            self.emit(
                &#34;participant_attributes_changed&#34;,
                changed_attributes,
                participant,
            )
        elif which == &#34;connection_quality_changed&#34;:
            identity = event.connection_quality_changed.participant_identity
            # TODO: pass participant identity
            participant = self._retrieve_participant(identity)
            self.emit(
                &#34;connection_quality_changed&#34;,
                participant,
                event.connection_quality_changed.quality,
            )
        elif which == &#34;transcription_received&#34;:
            transcription = event.transcription_received
            segments = [
                TranscriptionSegment(
                    id=s.id,
                    text=s.text,
                    final=s.final,
                    start_time=s.start_time,
                    end_time=s.end_time,
                    language=s.language,
                )
                for s in transcription.segments
            ]
            part = self._retrieve_participant(transcription.participant_identity)
            pub: TrackPublication | None = None
            if part:
                pub = part.track_publications.get(transcription.track_sid)
            self.emit(&#34;transcription_received&#34;, segments, part, pub)
        elif which == &#34;data_packet_received&#34;:
            packet = event.data_packet_received
            which_val = packet.WhichOneof(&#34;value&#34;)
            if which_val == &#34;user&#34;:
                owned_buffer_info = packet.user.data
                buffer_info = owned_buffer_info.data
                native_data = ctypes.cast(
                    buffer_info.data_ptr,
                    ctypes.POINTER(ctypes.c_byte * buffer_info.data_len),
                ).contents

                data = bytes(native_data)
                FfiHandle(owned_buffer_info.handle.id)
                rparticipant = cast(
                    RemoteParticipant,
                    self._retrieve_remote_participant(packet.participant_identity),
                )
                self.emit(
                    &#34;data_received&#34;,
                    DataPacket(
                        data=data,
                        kind=packet.kind,
                        participant=rparticipant,
                        topic=packet.user.topic,
                    ),
                )
            elif which_val == &#34;sip_dtmf&#34;:
                rparticipant = cast(
                    RemoteParticipant,
                    self._retrieve_remote_participant(packet.participant_identity),
                )
                self.emit(
                    &#34;sip_dtmf_received&#34;,
                    SipDTMF(
                        code=packet.sip_dtmf.code,
                        digit=packet.sip_dtmf.digit,
                        participant=rparticipant,
                    ),
                )
        elif which == &#34;e2ee_state_changed&#34;:
            identity = event.e2ee_state_changed.participant_identity
            e2ee_state = event.e2ee_state_changed.state
            # TODO: pass participant identity
            self.emit(&#34;e2ee_state_changed&#34;, self._retrieve_participant(identity), e2ee_state)
        elif which == &#34;connection_state_changed&#34;:
            connection_state = event.connection_state_changed.state
            self._connection_state = connection_state
            self.emit(&#34;connection_state_changed&#34;, connection_state)
        elif which == &#34;connected&#34;:
            self.emit(&#34;connected&#34;)
        elif which == &#34;disconnected&#34;:
            self.emit(&#34;disconnected&#34;, event.disconnected.reason)
        elif which == &#34;reconnecting&#34;:
            self.emit(&#34;reconnecting&#34;)
        elif which == &#34;reconnected&#34;:
            self.emit(&#34;reconnected&#34;)
        elif which == &#34;stream_header_received&#34;:
            self._handle_stream_header(
                event.stream_header_received.header,
                event.stream_header_received.participant_identity,
            )
        elif which == &#34;stream_chunk_received&#34;:
            task = asyncio.create_task(self._handle_stream_chunk(event.stream_chunk_received.chunk))
            self._data_stream_tasks.add(task)
            task.add_done_callback(self._data_stream_tasks.discard)

        elif which == &#34;stream_trailer_received&#34;:
            task = asyncio.create_task(
                self._handle_stream_trailer(event.stream_trailer_received.trailer)
            )
            self._data_stream_tasks.add(task)
            task.add_done_callback(self._data_stream_tasks.discard)

    def _handle_stream_header(
        self, header: proto_room.DataStream.Header, participant_identity: str
    ):
        stream_type = header.WhichOneof(&#34;content_header&#34;)
        if stream_type == &#34;text_header&#34;:
            text_stream_handler = self._text_stream_handlers.get(header.topic)
            if text_stream_handler is None:
                logging.info(
                    &#34;ignoring text stream with topic &#39;%s&#39;, no callback attached&#34;,
                    header.topic,
                )
                return

            text_reader = TextStreamReader(header)
            self._text_stream_readers[header.stream_id] = text_reader
            text_stream_handler(text_reader, participant_identity)
        elif stream_type == &#34;byte_header&#34;:
            byte_stream_handler = self._byte_stream_handlers.get(header.topic)
            if byte_stream_handler is None:
                logging.info(
                    &#34;ignoring byte stream with topic &#39;%s&#39;, no callback attached&#34;,
                    header.topic,
                )
                return

            byte_reader = ByteStreamReader(header)
            self._byte_stream_readers[header.stream_id] = byte_reader
            byte_stream_handler(byte_reader, participant_identity)
        else:
            logging.warning(&#34;received unknown header type, %s&#34;, stream_type)
        pass

    async def _handle_stream_chunk(self, chunk: proto_room.DataStream.Chunk):
        text_reader = self._text_stream_readers.get(chunk.stream_id)
        file_reader = self._byte_stream_readers.get(chunk.stream_id)

        if text_reader:
            await text_reader._on_chunk_update(chunk)
        elif file_reader:
            await file_reader._on_chunk_update(chunk)

    async def _handle_stream_trailer(self, trailer: proto_room.DataStream.Trailer):
        text_reader = self._text_stream_readers.get(trailer.stream_id)
        file_reader = self._byte_stream_readers.get(trailer.stream_id)

        if text_reader:
            await text_reader._on_stream_close(trailer)
            self._text_stream_readers.pop(trailer.stream_id)
        elif file_reader:
            await file_reader._on_stream_close(trailer)
            self._byte_stream_readers.pop(trailer.stream_id)

    async def _drain_rpc_invocation_tasks(self) -&gt; None:
        if self._rpc_invocation_tasks:
            for task in self._rpc_invocation_tasks:
                task.cancel()
            await asyncio.gather(*self._rpc_invocation_tasks, return_exceptions=True)

    async def _drain_data_stream_tasks(self) -&gt; None:
        if self._data_stream_tasks:
            for task in self._data_stream_tasks:
                task.cancel()
            await asyncio.gather(*self._data_stream_tasks, return_exceptions=True)

    def _retrieve_remote_participant(self, identity: str) -&gt; Optional[RemoteParticipant]:
        &#34;&#34;&#34;Retrieve a remote participant by identity&#34;&#34;&#34;
        return self._remote_participants.get(identity, None)

    def _retrieve_participant(self, identity: str) -&gt; Optional[Participant]:
        &#34;&#34;&#34;Retrieve a local or remote participant by identity&#34;&#34;&#34;
        if identity and identity == self.local_participant.identity:
            return self.local_participant

        return self._retrieve_remote_participant(identity)

    def _create_remote_participant(
        self, owned_info: proto_participant.OwnedParticipant
    ) -&gt; RemoteParticipant:
        if owned_info.info.identity in self._remote_participants:
            raise Exception(&#34;participant already exists&#34;)

        participant = RemoteParticipant(owned_info)
        self._remote_participants[participant.identity] = participant
        return participant

    def __repr__(self) -&gt; str:
        sid = &#34;unknown&#34;
        if self._first_sid_future.done():
            sid = self._first_sid_future.result()

        return f&#34;rtc.Room(sid={sid}, name={self.name}, metadata={self.metadata}, connection_state={ConnectionState.Name(self._connection_state)})&#34;</code></pre>
</details>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::</p>
<pre><code>class Mapping[KT, VT]:
    def __getitem__(self, key: KT) -&gt; VT:
        ...
    # Etc.
</code></pre>
<p>On older versions of Python, however, generic classes have to
explicitly inherit from Generic.</p>
<p>After a class has been declared to be generic, it can then be used as
follows::</p>
<pre><code>def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
    try:
        return mapping[key]
    except KeyError:
        return default
</code></pre>
<p>Initializes a new Room instance.</p>
<h2 id="parameters">Parameters</h2>
<p>loop (Optional[asyncio.AbstractEventLoop]): The event loop to use. If not provided, the default event loop is used.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.event_emitter.EventEmitter" href="event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a></li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.Room.connection_state"><code class="name">prop <span class="ident">connection_state</span> : ConnectionState.ValueType</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_state(self) -&gt; ConnectionState.ValueType:
    &#34;&#34;&#34;Gets the connection state of the room.

    Returns:
        ConnectionState: The connection state of the room.
    &#34;&#34;&#34;
    return self._connection_state</code></pre>
</details>
<div class="desc"><p>Gets the connection state of the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ConnectionState</code></dt>
<dd>The connection state of the room.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.Room.e2ee_manager"><code class="name">prop <span class="ident">e2ee_manager</span> : <a title="livekit.rtc.E2EEManager" href="#livekit.rtc.E2EEManager">E2EEManager</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def e2ee_manager(self) -&gt; E2EEManager:
    &#34;&#34;&#34;Gets the end-to-end encryption (E2EE) manager for the room.

    Returns:
        E2EEManager: The E2EE manager instance.
    &#34;&#34;&#34;
    return self._e2ee_manager</code></pre>
</details>
<div class="desc"><p>Gets the end-to-end encryption (E2EE) manager for the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="livekit.rtc.E2EEManager" href="#livekit.rtc.E2EEManager">E2EEManager</a></code></dt>
<dd>The E2EE manager instance.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.Room.local_participant"><code class="name">prop <span class="ident">local_participant</span> : <a title="livekit.rtc.LocalParticipant" href="#livekit.rtc.LocalParticipant">LocalParticipant</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def local_participant(self) -&gt; LocalParticipant:
    &#34;&#34;&#34;Gets the local participant in the room.

    Returns:
        LocalParticipant: The local participant in the room.
    &#34;&#34;&#34;
    if self._local_participant is None:
        raise Exception(&#34;cannot access local participant before connecting&#34;)

    return self._local_participant</code></pre>
</details>
<div class="desc"><p>Gets the local participant in the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="livekit.rtc.LocalParticipant" href="#livekit.rtc.LocalParticipant">LocalParticipant</a></code></dt>
<dd>The local participant in the room.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.Room.metadata"><code class="name">prop <span class="ident">metadata</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self) -&gt; str:
    &#34;&#34;&#34;Gets the metadata associated with the room.

    Returns:
        str: The metadata of the room.
    &#34;&#34;&#34;
    return self._info.metadata</code></pre>
</details>
<div class="desc"><p>Gets the metadata associated with the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The metadata of the room.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.Room.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Gets the name of the room.

    Returns:
        str: The name of the room.
    &#34;&#34;&#34;
    return self._info.name</code></pre>
</details>
<div class="desc"><p>Gets the name of the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The name of the room.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.Room.remote_participants"><code class="name">prop <span class="ident">remote_participants</span> : Mapping[str, <a title="livekit.rtc.RemoteParticipant" href="#livekit.rtc.RemoteParticipant">RemoteParticipant</a>]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def remote_participants(self) -&gt; Mapping[str, RemoteParticipant]:
    &#34;&#34;&#34;Gets the remote participants in the room.

    Returns:
        dict[str, RemoteParticipant]: A dictionary of remote participants indexed by their
        identity.
    &#34;&#34;&#34;
    return self._remote_participants</code></pre>
</details>
<div class="desc"><p>Gets the remote participants in the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, <a title="livekit.rtc.RemoteParticipant" href="#livekit.rtc.RemoteParticipant">RemoteParticipant</a>]</code></dt>
<dd>A dictionary of remote participants indexed by their</dd>
</dl>
<p>identity.</p></div>
</dd>
<dt id="livekit.rtc.Room.sid"><code class="name">prop <span class="ident">sid</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
async def sid(self) -&gt; str:
    &#34;&#34;&#34;Asynchronously retrieves the session ID (SID) of the room.

    Returns:
        str: The session ID of the room.
    &#34;&#34;&#34;
    if self._info.sid:
        return self._info.sid

    return await self._first_sid_future</code></pre>
</details>
<div class="desc"><p>Asynchronously retrieves the session ID (SID) of the room.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The session ID of the room.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.Room.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self,<br>url: str,<br>token: str,<br>options: <a title="livekit.rtc.RoomOptions" href="#livekit.rtc.RoomOptions">RoomOptions</a> = RoomOptions(auto_subscribe=True, dynacast=False, e2ee=None, rtc_config=None)) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self, url: str, token: str, options: RoomOptions = RoomOptions()) -&gt; None:
    &#34;&#34;&#34;Connects to a LiveKit room using the specified URL and token.

    Parameters:
        url (str): The WebSocket URL of the LiveKit server to connect to.
        token (str): The access token for authentication and authorization.
        options (RoomOptions, optional): Additional options for the room connection.

    Raises:
        ConnectError: If the connection fails.

    Example:
        ```python
        room = Room()

        # Listen for events before connecting to the room
        @room.on(&#34;participant_connected&#34;)
        def on_participant_connected(participant):
            print(f&#34;Participant connected: {participant.identity}&#34;)

        await room.connect(&#34;ws://localhost:7880&#34;, &#34;your_token&#34;)
        ```
    &#34;&#34;&#34;
    req = proto_ffi.FfiRequest()
    req.connect.url = url
    req.connect.token = token

    # options
    req.connect.options.auto_subscribe = options.auto_subscribe
    req.connect.options.dynacast = options.dynacast

    if options.e2ee:
        req.connect.options.e2ee.encryption_type = options.e2ee.encryption_type
        req.connect.options.e2ee.key_provider_options.shared_key = (
            options.e2ee.key_provider_options.shared_key  # type: ignore
        )
        req.connect.options.e2ee.key_provider_options.ratchet_salt = (
            options.e2ee.key_provider_options.ratchet_salt
        )
        req.connect.options.e2ee.key_provider_options.failure_tolerance = (
            options.e2ee.key_provider_options.failure_tolerance
        )
        req.connect.options.e2ee.key_provider_options.ratchet_window_size = (
            options.e2ee.key_provider_options.ratchet_window_size
        )

    if options.rtc_config:
        req.connect.options.rtc_config.ice_transport_type = (
            options.rtc_config.ice_transport_type
        )  # type: ignore
        req.connect.options.rtc_config.continual_gathering_policy = (
            options.rtc_config.continual_gathering_policy
        )  # type: ignore
        req.connect.options.rtc_config.ice_servers.extend(options.rtc_config.ice_servers)

    # subscribe before connecting so we don&#39;t miss any events
    self._ffi_queue = FfiClient.instance.queue.subscribe(self._loop)

    queue = FfiClient.instance.queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        cb: proto_ffi.FfiEvent = await queue.wait_for(
            lambda e: e.connect.async_id == resp.connect.async_id
        )
    finally:
        FfiClient.instance.queue.unsubscribe(queue)

    if cb.connect.error:
        FfiClient.instance.queue.unsubscribe(self._ffi_queue)
        raise ConnectError(cb.connect.error)

    self._ffi_handle = FfiHandle(cb.connect.result.room.handle.id)

    self._e2ee_manager = E2EEManager(self._ffi_handle.handle, options.e2ee)

    self._info = cb.connect.result.room.info
    self._connection_state = ConnectionState.CONN_CONNECTED

    self._local_participant = LocalParticipant(
        self._room_queue, cb.connect.result.local_participant
    )

    for pt in cb.connect.result.participants:
        rp = self._create_remote_participant(pt.participant)

        # add the initial remote participant tracks
        for owned_publication_info in pt.publications:
            publication = RemoteTrackPublication(owned_publication_info)
            rp._track_publications[publication.sid] = publication

    # start listening to room events
    self._task = self._loop.create_task(self._listen_task())</code></pre>
</details>
<div class="desc"><p>Connects to a LiveKit room using the specified URL and token.</p>
<h2 id="parameters">Parameters</h2>
<p>url (str): The WebSocket URL of the LiveKit server to connect to.
token (str): The access token for authentication and authorization.
options (RoomOptions, optional): Additional options for the room connection.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="livekit.rtc.ConnectError" href="#livekit.rtc.ConnectError">ConnectError</a></code></dt>
<dd>If the connection fails.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">room = Room()

# Listen for events before connecting to the room
@room.on(&quot;participant_connected&quot;)
def on_participant_connected(participant):
    print(f&quot;Participant connected: {participant.identity}&quot;)

await room.connect(&quot;ws://localhost:7880&quot;, &quot;your_token&quot;)
</code></pre></div>
</dd>
<dt id="livekit.rtc.Room.disconnect"><code class="name flex">
<span>async def <span class="ident">disconnect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disconnect(self) -&gt; None:
    &#34;&#34;&#34;Disconnects from the room.&#34;&#34;&#34;
    if not self.isconnected():
        return

    await self._drain_rpc_invocation_tasks()
    await self._drain_data_stream_tasks()

    req = proto_ffi.FfiRequest()
    req.disconnect.room_handle = self._ffi_handle.handle  # type: ignore
    queue = FfiClient.instance.queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        await queue.wait_for(lambda e: e.disconnect.async_id == resp.disconnect.async_id)
    finally:
        FfiClient.instance.queue.unsubscribe(queue)
    await self._task
    FfiClient.instance.queue.unsubscribe(self._ffi_queue)</code></pre>
</details>
<div class="desc"><p>Disconnects from the room.</p></div>
</dd>
<dt id="livekit.rtc.Room.isconnected"><code class="name flex">
<span>def <span class="ident">isconnected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isconnected(self) -&gt; bool:
    &#34;&#34;&#34;Checks if the room is currently connected.

    Returns:
        bool: True if connected, False otherwise.
    &#34;&#34;&#34;
    return (
        self._ffi_handle is not None
        and self._connection_state != ConnectionState.CONN_DISCONNECTED
    )</code></pre>
</details>
<div class="desc"><p>Checks if the room is currently connected.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if connected, False otherwise.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.Room.on"><code class="name flex">
<span>def <span class="ident">on</span></span>(<span>self, event: EventTypes, callback: Optional[Callable] = None) ‑> Callable</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on(self, event: EventTypes, callback: Optional[Callable] = None) -&gt; Callable:
    &#34;&#34;&#34;Registers an event handler for a specific event type.

    Parameters:
        event (EventTypes): The name of the event to listen for.
        callback (Callable): The function to call when the event occurs.

    Returns:
        Callable: The registered callback function.

    Available events:
        - **&#34;participant_connected&#34;**: Called when a new participant joins the room.
            - Arguments: `participant` (RemoteParticipant)
        - **&#34;participant_disconnected&#34;**: Called when a participant leaves the room.
            - Arguments: `participant` (RemoteParticipant)
        - **&#34;local_track_published&#34;**: Called when a local track is published.
            - Arguments: `publication` (LocalTrackPublication), `track` (Track)
        - **&#34;local_track_unpublished&#34;**: Called when a local track is unpublished.
            - Arguments: `publication` (LocalTrackPublication)
        - **&#34;local_track_subscribed&#34;**: Called when a local track is subscribed.
            - Arguments: `track` (Track)
        - **&#34;track_published&#34;**: Called when a remote participant publishes a track.
            - Arguments: `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
        - **&#34;track_unpublished&#34;**: Called when a remote participant unpublishes a track.
            - Arguments: `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
        - **&#34;track_subscribed&#34;**: Called when a track is subscribed.
            - Arguments: `track` (Track), `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
        - **&#34;track_unsubscribed&#34;**: Called when a track is unsubscribed.
            - Arguments: `track` (Track), `publication` (RemoteTrackPublication), `participant` (RemoteParticipant)
        - **&#34;track_subscription_failed&#34;**: Called when a track subscription fails.
            - Arguments: `participant` (RemoteParticipant), `track_sid` (str), `error` (str)
        - **&#34;track_muted&#34;**: Called when a track is muted.
            - Arguments: `participant` (Participant), `publication` (TrackPublication)
        - **&#34;track_unmuted&#34;**: Called when a track is unmuted.
            - Arguments: `participant` (Participant), `publication` (TrackPublication)
        - **&#34;active_speakers_changed&#34;**: Called when the list of active speakers changes.
            - Arguments: `speakers` (list[Participant])
        - **&#34;room_metadata_changed&#34;**: Called when the room&#39;s metadata is updated.
            - Arguments: `old_metadata` (str), `new_metadata` (str)
        - **&#34;participant_metadata_changed&#34;**: Called when a participant&#39;s metadata is updated.
            - Arguments: `participant` (Participant), `old_metadata` (str), `new_metadata` (str)
        - **&#34;participant_name_changed&#34;**: Called when a participant&#39;s name is changed.
            - Arguments: `participant` (Participant), `old_name` (str), `new_name` (str)
        - **&#34;participant_attributes_changed&#34;**: Called when a participant&#39;s attributes change.
            - Arguments: `changed_attributes` (dict), `participant` (Participant)
        - **&#34;connection_quality_changed&#34;**: Called when a participant&#39;s connection quality changes.
            - Arguments: `participant` (Participant), `quality` (ConnectionQuality)
        - **&#34;transcription_received&#34;**: Called when a transcription is received.
            - Arguments: `segments` (list[TranscriptionSegment]), `participant` (Participant), `publication` (TrackPublication)
        - **&#34;data_received&#34;**: Called when data is received.
            - Arguments: `data_packet` (DataPacket)
        - **&#34;sip_dtmf_received&#34;**: Called when a SIP DTMF signal is received.
            - Arguments: `sip_dtmf` (SipDTMF)
        - **&#34;e2ee_state_changed&#34;**: Called when a participant&#39;s E2EE state changes.
            - Arguments: `participant` (Participant), `state` (EncryptionState)
        - **&#34;connection_state_changed&#34;**: Called when the room&#39;s connection state changes.
            - Arguments: `connection_state` (ConnectionState)
        - **&#34;connected&#34;**: Called when the room is successfully connected.
            - Arguments: None
        - **&#34;disconnected&#34;**: Called when the room is disconnected.
            - Arguments: `reason` (DisconnectReason)
        - **&#34;reconnecting&#34;**: Called when the room is attempting to reconnect.
            - Arguments: None
        - **&#34;reconnected&#34;**: Called when the room has successfully reconnected.
            - Arguments: None

    Example:
        ```python
        def on_participant_connected(participant):
            print(f&#34;Participant connected: {participant.identity}&#34;)

        room.on(&#34;participant_connected&#34;, on_participant_connected)
        ```
    &#34;&#34;&#34;
    return super().on(event, callback)</code></pre>
</details>
<div class="desc"><p>Registers an event handler for a specific event type.</p>
<h2 id="parameters">Parameters</h2>
<p>event (EventTypes): The name of the event to listen for.
callback (Callable): The function to call when the event occurs.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable</code></dt>
<dd>The registered callback function.</dd>
</dl>
<p>Available events:
- <strong>"participant_connected"</strong>: Called when a new participant joins the room.
- Arguments: <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (RemoteParticipant)
- <strong>"participant_disconnected"</strong>: Called when a participant leaves the room.
- Arguments: <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (RemoteParticipant)
- <strong>"local_track_published"</strong>: Called when a local track is published.
- Arguments: <code>publication</code> (LocalTrackPublication), <code><a title="livekit.rtc.track" href="track.html">livekit.rtc.track</a></code> (Track)
- <strong>"local_track_unpublished"</strong>: Called when a local track is unpublished.
- Arguments: <code>publication</code> (LocalTrackPublication)
- <strong>"local_track_subscribed"</strong>: Called when a local track is subscribed.
- Arguments: <code><a title="livekit.rtc.track" href="track.html">livekit.rtc.track</a></code> (Track)
- <strong>"track_published"</strong>: Called when a remote participant publishes a track.
- Arguments: <code>publication</code> (RemoteTrackPublication), <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (RemoteParticipant)
- <strong>"track_unpublished"</strong>: Called when a remote participant unpublishes a track.
- Arguments: <code>publication</code> (RemoteTrackPublication), <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (RemoteParticipant)
- <strong>"track_subscribed"</strong>: Called when a track is subscribed.
- Arguments: <code><a title="livekit.rtc.track" href="track.html">livekit.rtc.track</a></code> (Track), <code>publication</code> (RemoteTrackPublication), <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (RemoteParticipant)
- <strong>"track_unsubscribed"</strong>: Called when a track is unsubscribed.
- Arguments: <code><a title="livekit.rtc.track" href="track.html">livekit.rtc.track</a></code> (Track), <code>publication</code> (RemoteTrackPublication), <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (RemoteParticipant)
- <strong>"track_subscription_failed"</strong>: Called when a track subscription fails.
- Arguments: <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (RemoteParticipant), <code>track_sid</code> (str), <code>error</code> (str)
- <strong>"track_muted"</strong>: Called when a track is muted.
- Arguments: <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (Participant), <code>publication</code> (TrackPublication)
- <strong>"track_unmuted"</strong>: Called when a track is unmuted.
- Arguments: <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (Participant), <code>publication</code> (TrackPublication)
- <strong>"active_speakers_changed"</strong>: Called when the list of active speakers changes.
- Arguments: <code>speakers</code> (list[Participant])
- <strong>"room_metadata_changed"</strong>: Called when the room's metadata is updated.
- Arguments: <code>old_metadata</code> (str), <code>new_metadata</code> (str)
- <strong>"participant_metadata_changed"</strong>: Called when a participant's metadata is updated.
- Arguments: <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (Participant), <code>old_metadata</code> (str), <code>new_metadata</code> (str)
- <strong>"participant_name_changed"</strong>: Called when a participant's name is changed.
- Arguments: <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (Participant), <code>old_name</code> (str), <code>new_name</code> (str)
- <strong>"participant_attributes_changed"</strong>: Called when a participant's attributes change.
- Arguments: <code>changed_attributes</code> (dict), <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (Participant)
- <strong>"connection_quality_changed"</strong>: Called when a participant's connection quality changes.
- Arguments: <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (Participant), <code>quality</code> (ConnectionQuality)
- <strong>"transcription_received"</strong>: Called when a transcription is received.
- Arguments: <code>segments</code> (list[TranscriptionSegment]), <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (Participant), <code>publication</code> (TrackPublication)
- <strong>"data_received"</strong>: Called when data is received.
- Arguments: <code>data_packet</code> (DataPacket)
- <strong>"sip_dtmf_received"</strong>: Called when a SIP DTMF signal is received.
- Arguments: <code>sip_dtmf</code> (SipDTMF)
- <strong>"e2ee_state_changed"</strong>: Called when a participant's E2EE state changes.
- Arguments: <code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code> (Participant), <code>state</code> (EncryptionState)
- <strong>"connection_state_changed"</strong>: Called when the room's connection state changes.
- Arguments: <code>connection_state</code> (ConnectionState)
- <strong>"connected"</strong>: Called when the room is successfully connected.
- Arguments: None
- <strong>"disconnected"</strong>: Called when the room is disconnected.
- Arguments: <code>reason</code> (DisconnectReason)
- <strong>"reconnecting"</strong>: Called when the room is attempting to reconnect.
- Arguments: None
- <strong>"reconnected"</strong>: Called when the room has successfully reconnected.
- Arguments: None</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">def on_participant_connected(participant):
    print(f&quot;Participant connected: {participant.identity}&quot;)

room.on(&quot;participant_connected&quot;, on_participant_connected)
</code></pre></div>
</dd>
<dt id="livekit.rtc.Room.register_byte_stream_handler"><code class="name flex">
<span>def <span class="ident">register_byte_stream_handler</span></span>(<span>self, topic: str, handler: ByteStreamHandler)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_byte_stream_handler(self, topic: str, handler: ByteStreamHandler):
    existing_handler = self._byte_stream_handlers.get(topic)
    if existing_handler is None:
        self._byte_stream_handlers[topic] = handler
    else:
        raise ValueError(&#34;byte stream handler for topic &#39;%s&#39; already set&#34; % topic)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.Room.register_text_stream_handler"><code class="name flex">
<span>def <span class="ident">register_text_stream_handler</span></span>(<span>self, topic: str, handler: TextStreamHandler)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_text_stream_handler(self, topic: str, handler: TextStreamHandler):
    existing_handler = self._text_stream_handlers.get(topic)
    if existing_handler is None:
        self._text_stream_handlers[topic] = handler
    else:
        raise ValueError(&#34;text stream handler for topic &#39;%s&#39; already set&#34; % topic)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.Room.unregister_byte_stream_handler"><code class="name flex">
<span>def <span class="ident">unregister_byte_stream_handler</span></span>(<span>self, topic: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister_byte_stream_handler(self, topic: str):
    if self._byte_stream_handlers.get(topic):
        self._byte_stream_handlers.pop(topic)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.Room.unregister_text_stream_handler"><code class="name flex">
<span>def <span class="ident">unregister_text_stream_handler</span></span>(<span>self, topic: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister_text_stream_handler(self, topic: str):
    if self._text_stream_handlers.get(topic):
        self._text_stream_handlers.pop(topic)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livekit.rtc.event_emitter.EventEmitter" href="event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a></b></code>:
<ul class="hlist">
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.emit" href="event_emitter.html#livekit.rtc.event_emitter.EventEmitter.emit">emit</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.off" href="event_emitter.html#livekit.rtc.event_emitter.EventEmitter.off">off</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.once" href="event_emitter.html#livekit.rtc.event_emitter.EventEmitter.once">once</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livekit.rtc.RoomOptions"><code class="flex name class">
<span>class <span class="ident">RoomOptions</span></span>
<span>(</span><span>auto_subscribe: bool = True,<br>dynacast: bool = False,<br>e2ee: <a title="livekit.rtc.E2EEOptions" href="#livekit.rtc.E2EEOptions">E2EEOptions</a> | None = None,<br>rtc_config: <a title="livekit.rtc.RtcConfiguration" href="#livekit.rtc.RtcConfiguration">RtcConfiguration</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RoomOptions:
    auto_subscribe: bool = True
    &#34;&#34;&#34;Automatically subscribe to tracks when participants join.&#34;&#34;&#34;
    dynacast: bool = False
    e2ee: E2EEOptions | None = None
    &#34;&#34;&#34;Options for end-to-end encryption.&#34;&#34;&#34;
    rtc_config: RtcConfiguration | None = None
    &#34;&#34;&#34;WebRTC-related configuration.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>RoomOptions(auto_subscribe: 'bool' = True, dynacast: 'bool' = False, e2ee: 'E2EEOptions | None' = None, rtc_config: 'RtcConfiguration | None' = None)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.RoomOptions.auto_subscribe"><code class="name">var <span class="ident">auto_subscribe</span> : bool</code></dt>
<dd>
<div class="desc"><p>Automatically subscribe to tracks when participants join.</p></div>
</dd>
<dt id="livekit.rtc.RoomOptions.dynacast"><code class="name">var <span class="ident">dynacast</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.RoomOptions.e2ee"><code class="name">var <span class="ident">e2ee</span> : <a title="livekit.rtc.e2ee.E2EEOptions" href="e2ee.html#livekit.rtc.e2ee.E2EEOptions">E2EEOptions</a> | None</code></dt>
<dd>
<div class="desc"><p>Options for end-to-end encryption.</p></div>
</dd>
<dt id="livekit.rtc.RoomOptions.rtc_config"><code class="name">var <span class="ident">rtc_config</span> : <a title="livekit.rtc.room.RtcConfiguration" href="room.html#livekit.rtc.room.RtcConfiguration">RtcConfiguration</a> | None</code></dt>
<dd>
<div class="desc"><p>WebRTC-related configuration.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.RpcError"><code class="flex name class">
<span>class <span class="ident">RpcError</span></span>
<span>(</span><span>code: int | ForwardRef('<a title="livekit.rtc.RpcError.ErrorCode" href="#livekit.rtc.RpcError.ErrorCode">RpcError.ErrorCode</a>'),<br>message: str,<br>data: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RpcError(Exception):
    &#34;&#34;&#34;
    Specialized error handling for RPC methods.

    Instances of this type, when thrown in a method handler, will have their `message`
    serialized and sent across the wire. The caller will receive an equivalent error on the other side.

    Built-in errors are included (codes 1001-1999) but developers may use the code, message, and data fields to create their own errors.
    &#34;&#34;&#34;

    class ErrorCode(IntEnum):
        APPLICATION_ERROR = 1500
        CONNECTION_TIMEOUT = 1501
        RESPONSE_TIMEOUT = 1502
        RECIPIENT_DISCONNECTED = 1503
        RESPONSE_PAYLOAD_TOO_LARGE = 1504
        SEND_FAILED = 1505

        UNSUPPORTED_METHOD = 1400
        RECIPIENT_NOT_FOUND = 1401
        REQUEST_PAYLOAD_TOO_LARGE = 1402
        UNSUPPORTED_SERVER = 1403
        UNSUPPORTED_VERSION = 1404

    ErrorMessage: ClassVar[Dict[ErrorCode, str]] = {
        ErrorCode.APPLICATION_ERROR: &#34;Application error in method handler&#34;,
        ErrorCode.CONNECTION_TIMEOUT: &#34;Connection timeout&#34;,
        ErrorCode.RESPONSE_TIMEOUT: &#34;Response timeout&#34;,
        ErrorCode.RECIPIENT_DISCONNECTED: &#34;Recipient disconnected&#34;,
        ErrorCode.RESPONSE_PAYLOAD_TOO_LARGE: &#34;Response payload too large&#34;,
        ErrorCode.SEND_FAILED: &#34;Failed to send&#34;,
        ErrorCode.UNSUPPORTED_METHOD: &#34;Method not supported at destination&#34;,
        ErrorCode.RECIPIENT_NOT_FOUND: &#34;Recipient not found&#34;,
        ErrorCode.REQUEST_PAYLOAD_TOO_LARGE: &#34;Request payload too large&#34;,
        ErrorCode.UNSUPPORTED_SERVER: &#34;RPC not supported by server&#34;,
        ErrorCode.UNSUPPORTED_VERSION: &#34;Unsupported RPC version&#34;,
    }

    def __init__(
        self,
        code: Union[int, &#34;RpcError.ErrorCode&#34;],
        message: str,
        data: Optional[str] = None,
    ):
        &#34;&#34;&#34;
        Creates an error object with the given code and message, plus an optional data payload.

        If thrown in an RPC method handler, the error will be sent back to the caller.

        Args:
            code (int): Your error code (Error codes 1001-1999 are reserved for built-in errors)
            message (str): A readable error message.
            data (Optional[str]): Optional additional data associated with the error (JSON recommended)
        &#34;&#34;&#34;
        super().__init__(message)
        self._code = code
        self._message = message
        self._data = data

    @property
    def code(self) -&gt; int:
        &#34;&#34;&#34;Error code value. Codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).&#34;&#34;&#34;
        return self._code

    @property
    def message(self) -&gt; str:
        &#34;&#34;&#34;A readable error message.&#34;&#34;&#34;
        return self._message

    @property
    def data(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Optional additional data associated with the error (JSON recommended).&#34;&#34;&#34;
        return self._data

    @classmethod
    def _from_proto(cls, proto: proto_rpc.RpcError) -&gt; &#34;RpcError&#34;:
        return cls(proto.code, proto.message, proto.data)

    def _to_proto(self) -&gt; proto_rpc.RpcError:
        return proto_rpc.RpcError(code=self.code, message=self.message, data=self.data)

    @classmethod
    def _built_in(cls, code: &#34;RpcError.ErrorCode&#34;, data: Optional[str] = None) -&gt; &#34;RpcError&#34;:
        message = cls.ErrorMessage[code]
        return cls(code, message, data)</code></pre>
</details>
<div class="desc"><p>Specialized error handling for RPC methods.</p>
<p>Instances of this type, when thrown in a method handler, will have their <code>message</code>
serialized and sent across the wire. The caller will receive an equivalent error on the other side.</p>
<p>Built-in errors are included (codes 1001-1999) but developers may use the code, message, and data fields to create their own errors.</p>
<p>Creates an error object with the given code and message, plus an optional data payload.</p>
<p>If thrown in an RPC method handler, the error will be sent back to the caller.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>code</code></strong> :&ensp;<code>int</code></dt>
<dd>Your error code (Error codes 1001-1999 are reserved for built-in errors)</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>A readable error message.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Optional additional data associated with the error (JSON recommended)</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.rtc.RpcError.ErrorCode"><code class="name">var <span class="ident">ErrorCode</span></code></dt>
<dd>
<div class="desc"><p>Enum where members are also (and must be) ints</p></div>
</dd>
<dt id="livekit.rtc.RpcError.ErrorMessage"><code class="name">var <span class="ident">ErrorMessage</span> : ClassVar[Dict[<a title="livekit.rtc.rpc.RpcError.ErrorCode" href="rpc.html#livekit.rtc.rpc.RpcError.ErrorCode">RpcError.ErrorCode</a>, str]]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.RpcError.code"><code class="name">prop <span class="ident">code</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def code(self) -&gt; int:
    &#34;&#34;&#34;Error code value. Codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).&#34;&#34;&#34;
    return self._code</code></pre>
</details>
<div class="desc"><p>Error code value. Codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).</p></div>
</dd>
<dt id="livekit.rtc.RpcError.data"><code class="name">prop <span class="ident">data</span> : str | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Optional additional data associated with the error (JSON recommended).&#34;&#34;&#34;
    return self._data</code></pre>
</details>
<div class="desc"><p>Optional additional data associated with the error (JSON recommended).</p></div>
</dd>
<dt id="livekit.rtc.RpcError.message"><code class="name">prop <span class="ident">message</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def message(self) -&gt; str:
    &#34;&#34;&#34;A readable error message.&#34;&#34;&#34;
    return self._message</code></pre>
</details>
<div class="desc"><p>A readable error message.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.RpcInvocationData"><code class="flex name class">
<span>class <span class="ident">RpcInvocationData</span></span>
<span>(</span><span>request_id: str, caller_identity: str, payload: str, response_timeout: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RpcInvocationData:
    &#34;&#34;&#34;Data passed to method handler for incoming RPC invocations

    Attributes:
        request_id (str): The unique request ID. Will match at both sides of the call, useful for debugging or logging.
        caller_identity (str): The unique participant identity of the caller.
        payload (str): The payload of the request. User-definable format, typically JSON.
        response_timeout (float): The maximum time the caller will wait for a response.
    &#34;&#34;&#34;

    request_id: str
    caller_identity: str
    payload: str
    response_timeout: float</code></pre>
</details>
<div class="desc"><p>Data passed to method handler for incoming RPC invocations</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>request_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The unique request ID. Will match at both sides of the call, useful for debugging or logging.</dd>
<dt><strong><code>caller_identity</code></strong> :&ensp;<code>str</code></dt>
<dd>The unique participant identity of the caller.</dd>
<dt><strong><code>payload</code></strong> :&ensp;<code>str</code></dt>
<dd>The payload of the request. User-definable format, typically JSON.</dd>
<dt><strong><code>response_timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>The maximum time the caller will wait for a response.</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.RpcInvocationData.caller_identity"><code class="name">var <span class="ident">caller_identity</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.RpcInvocationData.payload"><code class="name">var <span class="ident">payload</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.RpcInvocationData.request_id"><code class="name">var <span class="ident">request_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.RpcInvocationData.response_timeout"><code class="name">var <span class="ident">response_timeout</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.RtcConfiguration"><code class="flex name class">
<span>class <span class="ident">RtcConfiguration</span></span>
<span>(</span><span>ice_transport_type: proto_room.IceTransportType.ValueType = 2,<br>continual_gathering_policy: proto_room.ContinualGatheringPolicy.ValueType = 1,<br>ice_servers: list[proto_room.IceServer] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RtcConfiguration:
    ice_transport_type: proto_room.IceTransportType.ValueType = (
        proto_room.IceTransportType.TRANSPORT_ALL
    )
    &#34;&#34;&#34;Specifies the type of ICE transport to be used (e.g., all, relay, etc.).&#34;&#34;&#34;
    continual_gathering_policy: proto_room.ContinualGatheringPolicy.ValueType = (
        proto_room.ContinualGatheringPolicy.GATHER_CONTINUALLY
    )
    &#34;&#34;&#34;Policy for continual gathering of ICE candidates.&#34;&#34;&#34;
    ice_servers: list[proto_room.IceServer] = field(default_factory=list)
    &#34;&#34;&#34;List of ICE servers for STUN/TURN. When empty, it uses the default ICE servers provided by
    the SFU.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>RtcConfiguration(ice_transport_type: 'proto_room.IceTransportType.ValueType' = 2, continual_gathering_policy: 'proto_room.ContinualGatheringPolicy.ValueType' = 1, ice_servers: 'list[proto_room.IceServer]' = <factory>)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.RtcConfiguration.continual_gathering_policy"><code class="name">var <span class="ident">continual_gathering_policy</span> : int</code></dt>
<dd>
<div class="desc"><p>Policy for continual gathering of ICE candidates.</p></div>
</dd>
<dt id="livekit.rtc.RtcConfiguration.ice_servers"><code class="name">var <span class="ident">ice_servers</span> : list[room_pb2.IceServer]</code></dt>
<dd>
<div class="desc"><p>List of ICE servers for STUN/TURN. When empty, it uses the default ICE servers provided by
the SFU.</p></div>
</dd>
<dt id="livekit.rtc.RtcConfiguration.ice_transport_type"><code class="name">var <span class="ident">ice_transport_type</span> : int</code></dt>
<dd>
<div class="desc"><p>Specifies the type of ICE transport to be used (e.g., all, relay, etc.).</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.SipDTMF"><code class="flex name class">
<span>class <span class="ident">SipDTMF</span></span>
<span>(</span><span>code: int,<br>digit: str,<br>participant: <a title="livekit.rtc.RemoteParticipant" href="#livekit.rtc.RemoteParticipant">RemoteParticipant</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class SipDTMF:
    code: int
    &#34;&#34;&#34;DTMF code corresponding to the digit.&#34;&#34;&#34;
    digit: str
    &#34;&#34;&#34;DTMF digit sent.&#34;&#34;&#34;
    participant: RemoteParticipant | None = None
    &#34;&#34;&#34;Participant who sent the DTMF digit. None when sent by a server SDK.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>SipDTMF(code: 'int', digit: 'str', participant: 'RemoteParticipant | None' = None)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.SipDTMF.code"><code class="name">var <span class="ident">code</span> : int</code></dt>
<dd>
<div class="desc"><p>DTMF code corresponding to the digit.</p></div>
</dd>
<dt id="livekit.rtc.SipDTMF.digit"><code class="name">var <span class="ident">digit</span> : str</code></dt>
<dd>
<div class="desc"><p>DTMF digit sent.</p></div>
</dd>
<dt id="livekit.rtc.SipDTMF.participant"><code class="name">var <span class="ident">participant</span> : <a title="livekit.rtc.participant.RemoteParticipant" href="participant.html#livekit.rtc.participant.RemoteParticipant">RemoteParticipant</a> | None</code></dt>
<dd>
<div class="desc"><p>Participant who sent the DTMF digit. None when sent by a server SDK.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.TextStreamInfo"><code class="flex name class">
<span>class <span class="ident">TextStreamInfo</span></span>
<span>(</span><span>stream_id: str,<br>mime_type: str,<br>topic: str,<br>timestamp: int,<br>size: Optional[int],<br>attributes: Optional[Dict[str, str]],<br>attachments: List[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class TextStreamInfo(BaseStreamInfo):
    attachments: List[str]</code></pre>
</details>
<div class="desc"><p>TextStreamInfo(stream_id: 'str', mime_type: 'str', topic: 'str', timestamp: 'int', size: 'Optional[int]', attributes: 'Optional[Dict[str, str]]', attachments: 'List[str]')</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.data_stream.BaseStreamInfo" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo">BaseStreamInfo</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.TextStreamInfo.attachments"><code class="name">var <span class="ident">attachments</span> : List[str]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livekit.rtc.data_stream.BaseStreamInfo" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo">BaseStreamInfo</a></b></code>:
<ul class="hlist">
<li><code><a title="livekit.rtc.data_stream.BaseStreamInfo.attributes" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo.attributes">attributes</a></code></li>
<li><code><a title="livekit.rtc.data_stream.BaseStreamInfo.mime_type" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo.mime_type">mime_type</a></code></li>
<li><code><a title="livekit.rtc.data_stream.BaseStreamInfo.size" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo.size">size</a></code></li>
<li><code><a title="livekit.rtc.data_stream.BaseStreamInfo.stream_id" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo.stream_id">stream_id</a></code></li>
<li><code><a title="livekit.rtc.data_stream.BaseStreamInfo.timestamp" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo.timestamp">timestamp</a></code></li>
<li><code><a title="livekit.rtc.data_stream.BaseStreamInfo.topic" href="data_stream.html#livekit.rtc.data_stream.BaseStreamInfo.topic">topic</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livekit.rtc.TextStreamReader"><code class="flex name class">
<span>class <span class="ident">TextStreamReader</span></span>
<span>(</span><span>header: proto_DataStream.Header)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextStreamReader:
    def __init__(
        self,
        header: proto_DataStream.Header,
    ) -&gt; None:
        self._header = header
        self._info = TextStreamInfo(
            stream_id=header.stream_id,
            mime_type=header.mime_type,
            topic=header.topic,
            timestamp=header.timestamp,
            size=header.total_length,
            attributes=dict(header.attributes),
            attachments=list(header.text_header.attached_stream_ids),
        )
        self._queue: asyncio.Queue[proto_DataStream.Chunk | None] = asyncio.Queue()

    async def _on_chunk_update(self, chunk: proto_DataStream.Chunk):
        await self._queue.put(chunk)

    async def _on_stream_close(self, trailer: proto_DataStream.Trailer):
        self.info.attributes = self.info.attributes or {}
        self.info.attributes.update(trailer.attributes)
        await self._queue.put(None)

    def __aiter__(self) -&gt; AsyncIterator[str]:
        return self

    async def __anext__(self) -&gt; str:
        item = await self._queue.get()
        if item is None:
            raise StopAsyncIteration
        decodedStr = item.content.decode()
        return decodedStr

    @property
    def info(self) -&gt; TextStreamInfo:
        return self._info

    async def read_all(self) -&gt; str:
        final_string = &#34;&#34;
        async for chunk in self:
            final_string += chunk
        return final_string</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.TextStreamReader.info"><code class="name">prop <span class="ident">info</span> : <a title="livekit.rtc.TextStreamInfo" href="#livekit.rtc.TextStreamInfo">TextStreamInfo</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def info(self) -&gt; TextStreamInfo:
    return self._info</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.TextStreamReader.read_all"><code class="name flex">
<span>async def <span class="ident">read_all</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def read_all(self) -&gt; str:
    final_string = &#34;&#34;
    async for chunk in self:
        final_string += chunk
    return final_string</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.TextStreamWriter"><code class="flex name class">
<span>class <span class="ident">TextStreamWriter</span></span>
<span>(</span><span>local_participant: <a title="livekit.rtc.LocalParticipant" href="#livekit.rtc.LocalParticipant">LocalParticipant</a>,<br>*,<br>topic: str = '',<br>attributes: Optional[Dict[str, str]] = {},<br>stream_id: str | None = None,<br>total_size: int | None = None,<br>reply_to_id: str | None = None,<br>destination_identities: Optional[List[str]] = None,<br>sender_identity: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextStreamWriter(BaseStreamWriter):
    def __init__(
        self,
        local_participant: LocalParticipant,
        *,
        topic: str = &#34;&#34;,
        attributes: Optional[Dict[str, str]] = {},
        stream_id: str | None = None,
        total_size: int | None = None,
        reply_to_id: str | None = None,
        destination_identities: Optional[List[str]] = None,
        sender_identity: str | None = None,
    ) -&gt; None:
        super().__init__(
            local_participant,
            topic,
            attributes,
            stream_id,
            total_size,
            mime_type=&#34;text/plain&#34;,
            destination_identities=destination_identities,
            sender_identity=sender_identity,
        )
        self._header.text_header.operation_type = proto_DataStream.OperationType.CREATE
        if reply_to_id:
            self._header.text_header.reply_to_stream_id = reply_to_id
        self._info = TextStreamInfo(
            stream_id=self._header.stream_id,
            mime_type=self._header.mime_type,
            topic=self._header.topic,
            timestamp=self._header.timestamp,
            size=self._header.total_length,
            attributes=dict(self._header.attributes),
            attachments=list(self._header.text_header.attached_stream_ids),
        )
        self._write_lock = asyncio.Lock()

    async def write(self, text: str):
        async with self._write_lock:
            for chunk in split_utf8(text, STREAM_CHUNK_SIZE):
                content = chunk
                chunk_index = self._next_chunk_index
                self._next_chunk_index += 1
                chunk_msg = proto_DataStream.Chunk(
                    stream_id=self._header.stream_id,
                    chunk_index=chunk_index,
                    content=content,
                )
                await self._send_chunk(chunk_msg)

    @property
    def info(self) -&gt; TextStreamInfo:
        return self._info</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.data_stream.BaseStreamWriter" href="data_stream.html#livekit.rtc.data_stream.BaseStreamWriter">BaseStreamWriter</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.TextStreamWriter.info"><code class="name">prop <span class="ident">info</span> : <a title="livekit.rtc.TextStreamInfo" href="#livekit.rtc.TextStreamInfo">TextStreamInfo</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def info(self) -&gt; TextStreamInfo:
    return self._info</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.TextStreamWriter.write"><code class="name flex">
<span>async def <span class="ident">write</span></span>(<span>self, text: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def write(self, text: str):
    async with self._write_lock:
        for chunk in split_utf8(text, STREAM_CHUNK_SIZE):
            content = chunk
            chunk_index = self._next_chunk_index
            self._next_chunk_index += 1
            chunk_msg = proto_DataStream.Chunk(
                stream_id=self._header.stream_id,
                chunk_index=chunk_index,
                content=content,
            )
            await self._send_chunk(chunk_msg)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.Track"><code class="flex name class">
<span>class <span class="ident">Track</span></span>
<span>(</span><span>owned_info: track_pb2.OwnedTrack)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Track:
    def __init__(self, owned_info: proto_track.OwnedTrack):
        self._info = owned_info.info
        self._ffi_handle = FfiHandle(owned_info.handle.id)

    @property
    def sid(self) -&gt; str:
        return self._info.sid

    @property
    def name(self) -&gt; str:
        return self._info.name

    @property
    def kind(self) -&gt; proto_track.TrackKind.ValueType:
        return self._info.kind

    @property
    def stream_state(self) -&gt; proto_track.StreamState.ValueType:
        return self._info.stream_state

    @property
    def muted(self) -&gt; bool:
        return self._info.muted

    async def get_stats(self) -&gt; List[proto_stats.RtcStats]:
        req = proto_ffi.FfiRequest()
        req.get_stats.track_handle = self._ffi_handle.handle

        queue = FfiClient.instance.queue.subscribe()
        try:
            resp = FfiClient.instance.request(req)
            cb: proto_ffi.FfiEvent = await queue.wait_for(
                lambda e: e.get_stats.async_id == resp.get_stats.async_id
            )
        finally:
            FfiClient.instance.queue.unsubscribe(queue)

        if cb.get_stats.error:
            raise Exception(cb.get_stats.error)

        return list(cb.get_stats.stats)</code></pre>
</details>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="livekit.rtc.track.LocalAudioTrack" href="track.html#livekit.rtc.track.LocalAudioTrack">LocalAudioTrack</a></li>
<li><a title="livekit.rtc.track.LocalVideoTrack" href="track.html#livekit.rtc.track.LocalVideoTrack">LocalVideoTrack</a></li>
<li><a title="livekit.rtc.track.RemoteAudioTrack" href="track.html#livekit.rtc.track.RemoteAudioTrack">RemoteAudioTrack</a></li>
<li><a title="livekit.rtc.track.RemoteVideoTrack" href="track.html#livekit.rtc.track.RemoteVideoTrack">RemoteVideoTrack</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.Track.kind"><code class="name">prop <span class="ident">kind</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kind(self) -&gt; proto_track.TrackKind.ValueType:
    return self._info.kind</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.Track.muted"><code class="name">prop <span class="ident">muted</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def muted(self) -&gt; bool:
    return self._info.muted</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.Track.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    return self._info.name</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.Track.sid"><code class="name">prop <span class="ident">sid</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sid(self) -&gt; str:
    return self._info.sid</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.Track.stream_state"><code class="name">prop <span class="ident">stream_state</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stream_state(self) -&gt; proto_track.StreamState.ValueType:
    return self._info.stream_state</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.Track.get_stats"><code class="name flex">
<span>async def <span class="ident">get_stats</span></span>(<span>self) ‑> List[stats_pb2.RtcStats]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_stats(self) -&gt; List[proto_stats.RtcStats]:
    req = proto_ffi.FfiRequest()
    req.get_stats.track_handle = self._ffi_handle.handle

    queue = FfiClient.instance.queue.subscribe()
    try:
        resp = FfiClient.instance.request(req)
        cb: proto_ffi.FfiEvent = await queue.wait_for(
            lambda e: e.get_stats.async_id == resp.get_stats.async_id
        )
    finally:
        FfiClient.instance.queue.unsubscribe(queue)

    if cb.get_stats.error:
        raise Exception(cb.get_stats.error)

    return list(cb.get_stats.stats)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.TrackPublication"><code class="flex name class">
<span>class <span class="ident">TrackPublication</span></span>
<span>(</span><span>owned_info: track_pb2.OwnedTrackPublication)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrackPublication:
    def __init__(self, owned_info: proto_track.OwnedTrackPublication):
        self._info = owned_info.info
        self._track: Optional[Track] = None
        self._ffi_handle = FfiHandle(owned_info.handle.id)

    @property
    def track(self) -&gt; Optional[Track]:
        return self._track

    @property
    def sid(self) -&gt; str:
        return self._info.sid

    @property
    def name(self) -&gt; str:
        return self._info.name

    @property
    def kind(self) -&gt; proto_track.TrackKind.ValueType:
        return self._info.kind

    @property
    def source(self) -&gt; proto_track.TrackSource.ValueType:
        return self._info.source

    @property
    def simulcasted(self) -&gt; bool:
        return self._info.simulcasted

    @property
    def width(self) -&gt; int:
        return self._info.width

    @property
    def height(self) -&gt; int:
        return self._info.height

    @property
    def mime_type(self) -&gt; str:
        return self._info.mime_type

    @property
    def muted(self) -&gt; bool:
        return self._info.muted

    @property
    def encryption_type(self) -&gt; proto_e2ee.EncryptionType.ValueType:
        return self._info.encryption_type</code></pre>
</details>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="livekit.rtc.track_publication.LocalTrackPublication" href="track_publication.html#livekit.rtc.track_publication.LocalTrackPublication">LocalTrackPublication</a></li>
<li><a title="livekit.rtc.track_publication.RemoteTrackPublication" href="track_publication.html#livekit.rtc.track_publication.RemoteTrackPublication">RemoteTrackPublication</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.TrackPublication.encryption_type"><code class="name">prop <span class="ident">encryption_type</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def encryption_type(self) -&gt; proto_e2ee.EncryptionType.ValueType:
    return self._info.encryption_type</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.TrackPublication.height"><code class="name">prop <span class="ident">height</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self) -&gt; int:
    return self._info.height</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.TrackPublication.kind"><code class="name">prop <span class="ident">kind</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kind(self) -&gt; proto_track.TrackKind.ValueType:
    return self._info.kind</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.TrackPublication.mime_type"><code class="name">prop <span class="ident">mime_type</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mime_type(self) -&gt; str:
    return self._info.mime_type</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.TrackPublication.muted"><code class="name">prop <span class="ident">muted</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def muted(self) -&gt; bool:
    return self._info.muted</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.TrackPublication.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    return self._info.name</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.TrackPublication.sid"><code class="name">prop <span class="ident">sid</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sid(self) -&gt; str:
    return self._info.sid</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.TrackPublication.simulcasted"><code class="name">prop <span class="ident">simulcasted</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def simulcasted(self) -&gt; bool:
    return self._info.simulcasted</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.TrackPublication.source"><code class="name">prop <span class="ident">source</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def source(self) -&gt; proto_track.TrackSource.ValueType:
    return self._info.source</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.TrackPublication.track"><code class="name">prop <span class="ident">track</span> : <a title="livekit.rtc.track.Track" href="track.html#livekit.rtc.track.Track">Track</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def track(self) -&gt; Optional[Track]:
    return self._track</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.TrackPublication.width"><code class="name">prop <span class="ident">width</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self) -&gt; int:
    return self._info.width</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.TrackPublishOptions"><code class="flex name class">
<span>class <span class="ident">TrackPublishOptions</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>google._upb._message.Message</li>
<li>google.protobuf.message.Message</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.rtc.TrackPublishOptions.DESCRIPTOR"><code class="name">var <span class="ident">DESCRIPTOR</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.Transcription"><code class="flex name class">
<span>class <span class="ident">Transcription</span></span>
<span>(</span><span>participant_identity: str,<br>track_sid: str,<br>segments: List[ForwardRef('<a title="livekit.rtc.TranscriptionSegment" href="#livekit.rtc.TranscriptionSegment">TranscriptionSegment</a>')])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Transcription:
    participant_identity: str
    track_sid: str
    segments: List[&#34;TranscriptionSegment&#34;]</code></pre>
</details>
<div class="desc"><p>Transcription(participant_identity: str, track_sid: str, segments: List[ForwardRef('TranscriptionSegment')])</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.Transcription.participant_identity"><code class="name">var <span class="ident">participant_identity</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.Transcription.segments"><code class="name">var <span class="ident">segments</span> : List[<a title="livekit.rtc.transcription.TranscriptionSegment" href="transcription.html#livekit.rtc.transcription.TranscriptionSegment">TranscriptionSegment</a>]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.Transcription.track_sid"><code class="name">var <span class="ident">track_sid</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.TranscriptionSegment"><code class="flex name class">
<span>class <span class="ident">TranscriptionSegment</span></span>
<span>(</span><span>id: str, text: str, start_time: int, end_time: int, language: str, final: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class TranscriptionSegment:
    id: str
    text: str
    start_time: int
    end_time: int
    language: str
    final: bool</code></pre>
</details>
<div class="desc"><p>TranscriptionSegment(id: str, text: str, start_time: int, end_time: int, language: str, final: bool)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.TranscriptionSegment.end_time"><code class="name">var <span class="ident">end_time</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.TranscriptionSegment.final"><code class="name">var <span class="ident">final</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.TranscriptionSegment.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.TranscriptionSegment.language"><code class="name">var <span class="ident">language</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.TranscriptionSegment.start_time"><code class="name">var <span class="ident">start_time</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.TranscriptionSegment.text"><code class="name">var <span class="ident">text</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.VideoEncoding"><code class="flex name class">
<span>class <span class="ident">VideoEncoding</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>google._upb._message.Message</li>
<li>google.protobuf.message.Message</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.rtc.VideoEncoding.DESCRIPTOR"><code class="name">var <span class="ident">DESCRIPTOR</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.VideoFrame"><code class="flex name class">
<span>class <span class="ident">VideoFrame</span></span>
<span>(</span><span>width: int, height: int, type: int, data: bytes | bytearray | memoryview)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VideoFrame:
    &#34;&#34;&#34;
    Represents a video frame with associated metadata and pixel data.

    This class provides methods to access video frame properties such as width, height,
    and pixel format, as well as methods for manipulating and converting video frames.
    &#34;&#34;&#34;

    def __init__(
        self,
        width: int,
        height: int,
        type: proto_video.VideoBufferType.ValueType,
        data: Union[bytes, bytearray, memoryview],
    ) -&gt; None:
        &#34;&#34;&#34;
        Initializes a new VideoFrame instance.

        Args:
            width (int): The width of the video frame in pixels.
            height (int): The height of the video frame in pixels.
            type (proto_video.VideoBufferType.ValueType): The format type of the video frame data
                (e.g., RGBA, BGRA, RGB24, etc.).
            data (Union[bytes, bytearray, memoryview]): The raw pixel data for the video frame.
        &#34;&#34;&#34;
        self._width = width
        self._height = height
        self._type = type
        self._data = bytearray(data)

    @property
    def width(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the width of the video frame in pixels.

        Returns:
            int: The width of the video frame.
        &#34;&#34;&#34;
        return self._width

    @property
    def height(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the height of the video frame in pixels.

        Returns:
            int: The height of the video frame.
        &#34;&#34;&#34;
        return self._height

    @property
    def type(self) -&gt; proto_video.VideoBufferType.ValueType:
        &#34;&#34;&#34;
        Returns the height of the video frame in pixels.

        Returns:
            int: The height of the video frame.
        &#34;&#34;&#34;
        return self._type

    @property
    def data(self) -&gt; memoryview:
        &#34;&#34;&#34;
        Returns a memoryview of the raw pixel data for the video frame.

        Returns:
            memoryview: The raw pixel data of the video frame as a memoryview object.
        &#34;&#34;&#34;
        return memoryview(self._data)

    @staticmethod
    def _from_owned_info(owned_info: proto_video.OwnedVideoBuffer) -&gt; &#34;VideoFrame&#34;:
        info = owned_info.info
        data_len = _get_plane_length(info.type, info.width, info.height)
        cdata = (ctypes.c_uint8 * data_len).from_address(info.data_ptr)
        data = bytearray(cdata)
        frame = VideoFrame(
            width=info.width,
            height=info.height,
            type=info.type,
            data=data,
        )
        FfiHandle(owned_info.handle.id)
        return frame

    def _proto_info(self) -&gt; proto_video.VideoBufferInfo:
        info = proto_video.VideoBufferInfo()
        addr = get_address(self.data)
        info.components.extend(_get_plane_infos(addr, self.type, self.width, self.height))
        info.width = self.width
        info.height = self.height
        info.type = self.type
        info.data_ptr = addr
        info.stride = 0

        if self.type in [
            proto_video.VideoBufferType.ARGB,
            proto_video.VideoBufferType.ABGR,
            proto_video.VideoBufferType.RGBA,
            proto_video.VideoBufferType.BGRA,
        ]:
            info.stride = self.width * 4
        elif self.type == proto_video.VideoBufferType.RGB24:
            info.stride = self.width * 3

        return info

    def get_plane(self, plane_nth: int) -&gt; Optional[memoryview]:
        &#34;&#34;&#34;
        Returns the memoryview of a specific plane in the video frame, based on its index.

        Some video formats (e.g., I420, NV12) contain multiple planes (Y, U, V channels).
        This method allows access to individual planes by index.

        Args:
            plane_nth (int): The index of the plane to retrieve (starting from 0).

        Returns:
            Optional[memoryview]: A memoryview of the specified plane&#39;s data, or None if
            the index is out of bounds for the format.
        &#34;&#34;&#34;
        plane_infos = _get_plane_infos(get_address(self.data), self.type, self.width, self.height)
        if plane_nth &gt;= len(plane_infos):
            return None

        plane_info = plane_infos[plane_nth]
        cdata = (ctypes.c_uint8 * plane_info.size).from_address(plane_info.data_ptr)
        return memoryview(cdata)

    def convert(
        self, type: proto_video.VideoBufferType.ValueType, *, flip_y: bool = False
    ) -&gt; &#34;VideoFrame&#34;:
        &#34;&#34;&#34;
        Converts the current video frame to a different format type, optionally flipping
        the frame vertically.

        Args:
            type (proto_video.VideoBufferType.ValueType): The target format type to convert to
                (e.g., RGBA, I420).
            flip_y (bool, optional): If True, the frame will be flipped vertically. Defaults to False.

        Returns:
            VideoFrame: A new VideoFrame object in the specified format.

        Raises:
            Exception: If the conversion isn&#39;t supported.

        Example:
            Convert a frame from RGBA to I420 format:

            &gt;&gt;&gt; frame = VideoFrame(width=1920, height=1080, type=proto_video.VideoBufferType.RGBA, data=raw_data)
            &gt;&gt;&gt; converted_frame = frame.convert(proto_video.VideoBufferType.I420)
            &gt;&gt;&gt; print(converted_frame.type)
            VideoBufferType.I420

        Example:
            Convert a frame from BGRA to RGB24 format and flip it vertically:

            &gt;&gt;&gt; frame = VideoFrame(width=1280, height=720, type=proto_video.VideoBufferType.BGRA, data=raw_data)
            &gt;&gt;&gt; converted_frame = frame.convert(proto_video.VideoBufferType.RGB24, flip_y=True)
            &gt;&gt;&gt; print(converted_frame.type)
            VideoBufferType.RGB24
            &gt;&gt;&gt; print(converted_frame.width, converted_frame.height)
            1280 720
        &#34;&#34;&#34;
        req = proto.FfiRequest()
        req.video_convert.flip_y = flip_y
        req.video_convert.dst_type = type
        req.video_convert.buffer.CopyFrom(self._proto_info())
        resp = FfiClient.instance.request(req)
        if resp.video_convert.error:
            raise Exception(resp.video_convert.error)

        return VideoFrame._from_owned_info(resp.video_convert.buffer)

    def __repr__(self) -&gt; str:
        return f&#34;rtc.VideoFrame(width={self.width}, height={self.height}, type={proto_video.VideoBufferType.Name(self.type)})&#34;

    @classmethod
    def __get_pydantic_core_schema__(cls, *_: Any):
        from pydantic_core import core_schema
        import base64

        def validate_video_frame(value: Any) -&gt; &#34;VideoFrame&#34;:
            if isinstance(value, VideoFrame):
                return value

            if isinstance(value, tuple):
                value = value[0]

            if isinstance(value, dict):
                return VideoFrame(
                    width=value[&#34;width&#34;],
                    height=value[&#34;height&#34;],
                    type=proto_video.VideoBufferType.Value(value[&#34;type&#34;]),
                    data=base64.b64decode(value[&#34;data&#34;]),
                )

            raise TypeError(&#34;Invalid type for VideoFrame&#34;)

        return core_schema.json_or_python_schema(
            json_schema=core_schema.chain_schema(
                [
                    core_schema.model_fields_schema(
                        {
                            &#34;width&#34;: core_schema.model_field(core_schema.int_schema()),
                            &#34;height&#34;: core_schema.model_field(core_schema.int_schema()),
                            &#34;type&#34;: core_schema.model_field(core_schema.str_schema()),
                            &#34;data&#34;: core_schema.model_field(core_schema.str_schema()),
                        },
                    ),
                    core_schema.no_info_plain_validator_function(validate_video_frame),
                ]
            ),
            python_schema=core_schema.no_info_plain_validator_function(validate_video_frame),
            serialization=core_schema.plain_serializer_function_ser_schema(
                lambda instance: {
                    &#34;width&#34;: instance.width,
                    &#34;height&#34;: instance.height,
                    &#34;type&#34;: proto_video.VideoBufferType.Name(instance.type),
                    &#34;data&#34;: base64.b64encode(instance.data).decode(&#34;utf-8&#34;),
                }
            ),
        )</code></pre>
</details>
<div class="desc"><p>Represents a video frame with associated metadata and pixel data.</p>
<p>This class provides methods to access video frame properties such as width, height,
and pixel format, as well as methods for manipulating and converting video frames.</p>
<p>Initializes a new VideoFrame instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>The width of the video frame in pixels.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code></dt>
<dd>The height of the video frame in pixels.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>proto_video.VideoBufferType.ValueType</code></dt>
<dd>The format type of the video frame data
(e.g., RGBA, BGRA, RGB24, etc.).</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>Union[bytes, bytearray, memoryview]</code></dt>
<dd>The raw pixel data for the video frame.</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.VideoFrame.data"><code class="name">prop <span class="ident">data</span> : memoryview</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; memoryview:
    &#34;&#34;&#34;
    Returns a memoryview of the raw pixel data for the video frame.

    Returns:
        memoryview: The raw pixel data of the video frame as a memoryview object.
    &#34;&#34;&#34;
    return memoryview(self._data)</code></pre>
</details>
<div class="desc"><p>Returns a memoryview of the raw pixel data for the video frame.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>memoryview</code></dt>
<dd>The raw pixel data of the video frame as a memoryview object.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.VideoFrame.height"><code class="name">prop <span class="ident">height</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the height of the video frame in pixels.

    Returns:
        int: The height of the video frame.
    &#34;&#34;&#34;
    return self._height</code></pre>
</details>
<div class="desc"><p>Returns the height of the video frame in pixels.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The height of the video frame.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.VideoFrame.type"><code class="name">prop <span class="ident">type</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; proto_video.VideoBufferType.ValueType:
    &#34;&#34;&#34;
    Returns the height of the video frame in pixels.

    Returns:
        int: The height of the video frame.
    &#34;&#34;&#34;
    return self._type</code></pre>
</details>
<div class="desc"><p>Returns the height of the video frame in pixels.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The height of the video frame.</dd>
</dl></div>
</dd>
<dt id="livekit.rtc.VideoFrame.width"><code class="name">prop <span class="ident">width</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the width of the video frame in pixels.

    Returns:
        int: The width of the video frame.
    &#34;&#34;&#34;
    return self._width</code></pre>
</details>
<div class="desc"><p>Returns the width of the video frame in pixels.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The width of the video frame.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.VideoFrame.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>self, type: int, *, flip_y: bool = False) ‑> <a title="livekit.rtc.video_frame.VideoFrame" href="video_frame.html#livekit.rtc.video_frame.VideoFrame">VideoFrame</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert(
    self, type: proto_video.VideoBufferType.ValueType, *, flip_y: bool = False
) -&gt; &#34;VideoFrame&#34;:
    &#34;&#34;&#34;
    Converts the current video frame to a different format type, optionally flipping
    the frame vertically.

    Args:
        type (proto_video.VideoBufferType.ValueType): The target format type to convert to
            (e.g., RGBA, I420).
        flip_y (bool, optional): If True, the frame will be flipped vertically. Defaults to False.

    Returns:
        VideoFrame: A new VideoFrame object in the specified format.

    Raises:
        Exception: If the conversion isn&#39;t supported.

    Example:
        Convert a frame from RGBA to I420 format:

        &gt;&gt;&gt; frame = VideoFrame(width=1920, height=1080, type=proto_video.VideoBufferType.RGBA, data=raw_data)
        &gt;&gt;&gt; converted_frame = frame.convert(proto_video.VideoBufferType.I420)
        &gt;&gt;&gt; print(converted_frame.type)
        VideoBufferType.I420

    Example:
        Convert a frame from BGRA to RGB24 format and flip it vertically:

        &gt;&gt;&gt; frame = VideoFrame(width=1280, height=720, type=proto_video.VideoBufferType.BGRA, data=raw_data)
        &gt;&gt;&gt; converted_frame = frame.convert(proto_video.VideoBufferType.RGB24, flip_y=True)
        &gt;&gt;&gt; print(converted_frame.type)
        VideoBufferType.RGB24
        &gt;&gt;&gt; print(converted_frame.width, converted_frame.height)
        1280 720
    &#34;&#34;&#34;
    req = proto.FfiRequest()
    req.video_convert.flip_y = flip_y
    req.video_convert.dst_type = type
    req.video_convert.buffer.CopyFrom(self._proto_info())
    resp = FfiClient.instance.request(req)
    if resp.video_convert.error:
        raise Exception(resp.video_convert.error)

    return VideoFrame._from_owned_info(resp.video_convert.buffer)</code></pre>
</details>
<div class="desc"><p>Converts the current video frame to a different format type, optionally flipping
the frame vertically.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>proto_video.VideoBufferType.ValueType</code></dt>
<dd>The target format type to convert to
(e.g., RGBA, I420).</dd>
<dt><strong><code>flip_y</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, the frame will be flipped vertically. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="livekit.rtc.VideoFrame" href="#livekit.rtc.VideoFrame">VideoFrame</a></code></dt>
<dd>A new VideoFrame object in the specified format.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If the conversion isn't supported.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Convert a frame from RGBA to I420 format:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; frame = VideoFrame(width=1920, height=1080, type=proto_video.VideoBufferType.RGBA, data=raw_data)
&gt;&gt;&gt; converted_frame = frame.convert(proto_video.VideoBufferType.I420)
&gt;&gt;&gt; print(converted_frame.type)
VideoBufferType.I420
</code></pre>
<h2 id="example_1">Example</h2>
<p>Convert a frame from BGRA to RGB24 format and flip it vertically:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; frame = VideoFrame(width=1280, height=720, type=proto_video.VideoBufferType.BGRA, data=raw_data)
&gt;&gt;&gt; converted_frame = frame.convert(proto_video.VideoBufferType.RGB24, flip_y=True)
&gt;&gt;&gt; print(converted_frame.type)
VideoBufferType.RGB24
&gt;&gt;&gt; print(converted_frame.width, converted_frame.height)
1280 720
</code></pre></div>
</dd>
<dt id="livekit.rtc.VideoFrame.get_plane"><code class="name flex">
<span>def <span class="ident">get_plane</span></span>(<span>self, plane_nth: int) ‑> memoryview | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_plane(self, plane_nth: int) -&gt; Optional[memoryview]:
    &#34;&#34;&#34;
    Returns the memoryview of a specific plane in the video frame, based on its index.

    Some video formats (e.g., I420, NV12) contain multiple planes (Y, U, V channels).
    This method allows access to individual planes by index.

    Args:
        plane_nth (int): The index of the plane to retrieve (starting from 0).

    Returns:
        Optional[memoryview]: A memoryview of the specified plane&#39;s data, or None if
        the index is out of bounds for the format.
    &#34;&#34;&#34;
    plane_infos = _get_plane_infos(get_address(self.data), self.type, self.width, self.height)
    if plane_nth &gt;= len(plane_infos):
        return None

    plane_info = plane_infos[plane_nth]
    cdata = (ctypes.c_uint8 * plane_info.size).from_address(plane_info.data_ptr)
    return memoryview(cdata)</code></pre>
</details>
<div class="desc"><p>Returns the memoryview of a specific plane in the video frame, based on its index.</p>
<p>Some video formats (e.g., I420, NV12) contain multiple planes (Y, U, V channels).
This method allows access to individual planes by index.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plane_nth</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the plane to retrieve (starting from 0).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[memoryview]</code></dt>
<dd>A memoryview of the specified plane's data, or None if</dd>
</dl>
<p>the index is out of bounds for the format.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.VideoFrameEvent"><code class="flex name class">
<span>class <span class="ident">VideoFrameEvent</span></span>
<span>(</span><span>frame: <a title="livekit.rtc.VideoFrame" href="#livekit.rtc.VideoFrame">VideoFrame</a>,<br>timestamp_us: int,<br>rotation: proto_video_frame.VideoRotation)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class VideoFrameEvent:
    frame: VideoFrame
    timestamp_us: int
    rotation: proto_video_frame.VideoRotation</code></pre>
</details>
<div class="desc"><p>VideoFrameEvent(frame: 'VideoFrame', timestamp_us: 'int', rotation: 'proto_video_frame.VideoRotation')</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.rtc.VideoFrameEvent.frame"><code class="name">var <span class="ident">frame</span> : <a title="livekit.rtc.video_frame.VideoFrame" href="video_frame.html#livekit.rtc.video_frame.VideoFrame">VideoFrame</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.VideoFrameEvent.rotation"><code class="name">var <span class="ident">rotation</span> : <google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x104abcb90></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.rtc.VideoFrameEvent.timestamp_us"><code class="name">var <span class="ident">timestamp_us</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.VideoSource"><code class="flex name class">
<span>class <span class="ident">VideoSource</span></span>
<span>(</span><span>width: int, height: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VideoSource:
    def __init__(self, width: int, height: int) -&gt; None:
        req = proto_ffi.FfiRequest()
        req.new_video_source.type = proto_video.VideoSourceType.VIDEO_SOURCE_NATIVE
        req.new_video_source.resolution.width = width
        req.new_video_source.resolution.height = height

        resp = FfiClient.instance.request(req)
        self._info = resp.new_video_source.source
        self._ffi_handle = FfiHandle(self._info.handle.id)

    def capture_frame(
        self,
        frame: VideoFrame,
        *,
        timestamp_us: int = 0,
        rotation: proto_video.VideoRotation.ValueType = proto_video.VideoRotation.VIDEO_ROTATION_0,
    ) -&gt; None:
        req = proto_ffi.FfiRequest()
        req.capture_video_frame.source_handle = self._ffi_handle.handle
        req.capture_video_frame.buffer.CopyFrom(frame._proto_info())
        req.capture_video_frame.rotation = rotation
        req.capture_video_frame.timestamp_us = timestamp_us
        FfiClient.instance.request(req)

    async def aclose(self) -&gt; None:
        self._ffi_handle.dispose()</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.VideoSource.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self) -&gt; None:
    self._ffi_handle.dispose()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.VideoSource.capture_frame"><code class="name flex">
<span>def <span class="ident">capture_frame</span></span>(<span>self,<br>frame: <a title="livekit.rtc.video_frame.VideoFrame" href="video_frame.html#livekit.rtc.video_frame.VideoFrame">VideoFrame</a>,<br>*,<br>timestamp_us: int = 0,<br>rotation: int = 0) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capture_frame(
    self,
    frame: VideoFrame,
    *,
    timestamp_us: int = 0,
    rotation: proto_video.VideoRotation.ValueType = proto_video.VideoRotation.VIDEO_ROTATION_0,
) -&gt; None:
    req = proto_ffi.FfiRequest()
    req.capture_video_frame.source_handle = self._ffi_handle.handle
    req.capture_video_frame.buffer.CopyFrom(frame._proto_info())
    req.capture_video_frame.rotation = rotation
    req.capture_video_frame.timestamp_us = timestamp_us
    FfiClient.instance.request(req)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.rtc.VideoStream"><code class="flex name class">
<span>class <span class="ident">VideoStream</span></span>
<span>(</span><span>track: <a title="livekit.rtc.Track" href="#livekit.rtc.Track">Track</a>,<br>loop: Optional[asyncio.AbstractEventLoop] = None,<br>capacity: int = 0,<br>format: Optional[proto_video_frame.VideoBufferType.ValueType] = None,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VideoStream:
    &#34;&#34;&#34;VideoStream is a stream of video frames received from a RemoteTrack.&#34;&#34;&#34;

    def __init__(
        self,
        track: Track,
        loop: Optional[asyncio.AbstractEventLoop] = None,
        capacity: int = 0,
        format: Optional[proto_video_frame.VideoBufferType.ValueType] = None,
        **kwargs,
    ) -&gt; None:
        self._loop = loop or asyncio.get_event_loop()
        self._ffi_queue = FfiClient.instance.queue.subscribe(self._loop)
        self._queue: RingQueue[VideoFrameEvent | None] = RingQueue(capacity)
        self._track: Track | None = track
        self._format = format
        self._capacity = capacity
        self._format = format
        stream: Any = None
        if &#34;participant&#34; in kwargs:
            stream = self._create_owned_stream_from_participant(
                participant=kwargs[&#34;participant&#34;], track_source=kwargs[&#34;track_source&#34;]
            )
        else:
            stream = self._create_owned_stream()

        self._ffi_handle = FfiHandle(stream.handle.id)
        self._info = stream.info

        self._task = self._loop.create_task(self._run())
        self._task.add_done_callback(task_done_logger)

    @classmethod
    def from_participant(
        cls,
        *,
        participant: Participant,
        track_source: TrackSource.ValueType,
        loop: Optional[asyncio.AbstractEventLoop] = None,
        format: Optional[proto_video_frame.VideoBufferType.ValueType] = None,
        capacity: int = 0,
    ) -&gt; VideoStream:
        return VideoStream(
            participant=participant,
            track_source=track_source,
            loop=loop,
            capacity=capacity,
            format=format,
            track=None,  # type: ignore
        )

    @classmethod
    def from_track(
        cls,
        *,
        track: Track,
        loop: Optional[asyncio.AbstractEventLoop] = None,
        format: Optional[proto_video_frame.VideoBufferType.ValueType] = None,
        capacity: int = 0,
    ) -&gt; VideoStream:
        return VideoStream(
            track=track,
            loop=loop,
            capacity=capacity,
            format=format,
        )

    def __del__(self) -&gt; None:
        FfiClient.instance.queue.unsubscribe(self._ffi_queue)

    def _create_owned_stream(self) -&gt; Any:
        assert self._track is not None
        req = proto_ffi.FfiRequest()
        new_video_stream = req.new_video_stream
        new_video_stream.track_handle = self._track._ffi_handle.handle
        new_video_stream.type = proto_video_frame.VideoStreamType.VIDEO_STREAM_NATIVE
        if self._format is not None:
            new_video_stream.format = self._format
        new_video_stream.normalize_stride = True
        resp = FfiClient.instance.request(req)
        return resp.new_video_stream.stream

    def _create_owned_stream_from_participant(
        self, participant: Participant, track_source: TrackSource.ValueType
    ) -&gt; Any:
        req = proto_ffi.FfiRequest()
        video_stream_from_participant = req.video_stream_from_participant
        video_stream_from_participant.participant_handle = participant._ffi_handle.handle
        video_stream_from_participant.type = proto_video_frame.VideoStreamType.VIDEO_STREAM_NATIVE
        video_stream_from_participant.track_source = track_source
        video_stream_from_participant.normalize_stride = True
        if self._format is not None:
            video_stream_from_participant.format = self._format
        resp = FfiClient.instance.request(req)
        return resp.video_stream_from_participant.stream

    async def _run(self) -&gt; None:
        while True:
            event = await self._ffi_queue.wait_for(self._is_event)
            video_event = event.video_stream_event

            if video_event.HasField(&#34;frame_received&#34;):
                owned_buffer_info = video_event.frame_received.buffer
                frame = VideoFrame._from_owned_info(owned_buffer_info)

                event = VideoFrameEvent(
                    frame=frame,
                    timestamp_us=video_event.frame_received.timestamp_us,
                    rotation=video_event.frame_received.rotation,
                )

                self._queue.put(event)
            elif video_event.HasField(&#34;eos&#34;):
                break

        FfiClient.instance.queue.unsubscribe(self._ffi_queue)

    async def aclose(self) -&gt; None:
        self._ffi_handle.dispose()
        await self._task

    def _is_event(self, e: proto_ffi.FfiEvent) -&gt; bool:
        return e.video_stream_event.stream_handle == self._ffi_handle.handle

    def __aiter__(self) -&gt; AsyncIterator[VideoFrameEvent]:
        return self

    async def __anext__(self) -&gt; VideoFrameEvent:
        if self._task.done():
            raise StopAsyncIteration

        item = await self._queue.get()
        if item is None:
            raise StopAsyncIteration

        return item</code></pre>
</details>
<div class="desc"><p>VideoStream is a stream of video frames received from a RemoteTrack.</p></div>
<h3>Static methods</h3>
<dl>
<dt id="livekit.rtc.VideoStream.from_participant"><code class="name flex">
<span>def <span class="ident">from_participant</span></span>(<span>*,<br>participant: <a title="livekit.rtc.Participant" href="#livekit.rtc.Participant">Participant</a>,<br>track_source: TrackSource.ValueType,<br>loop: Optional[asyncio.AbstractEventLoop] = None,<br>format: Optional[proto_video_frame.VideoBufferType.ValueType] = None,<br>capacity: int = 0) ‑> <a title="livekit.rtc.video_stream.VideoStream" href="video_stream.html#livekit.rtc.video_stream.VideoStream">VideoStream</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="livekit.rtc.VideoStream.from_track"><code class="name flex">
<span>def <span class="ident">from_track</span></span>(<span>*,<br>track: <a title="livekit.rtc.Track" href="#livekit.rtc.Track">Track</a>,<br>loop: Optional[asyncio.AbstractEventLoop] = None,<br>format: Optional[proto_video_frame.VideoBufferType.ValueType] = None,<br>capacity: int = 0) ‑> <a title="livekit.rtc.video_stream.VideoStream" href="video_stream.html#livekit.rtc.video_stream.VideoStream">VideoStream</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.rtc.VideoStream.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self) -&gt; None:
    self._ffi_handle.dispose()
    await self._task</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="livekit" href="../index.html">livekit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="livekit.rtc.apm" href="apm.html">livekit.rtc.apm</a></code></li>
<li><code><a title="livekit.rtc.audio_filter" href="audio_filter.html">livekit.rtc.audio_filter</a></code></li>
<li><code><a title="livekit.rtc.audio_frame" href="audio_frame.html">livekit.rtc.audio_frame</a></code></li>
<li><code><a title="livekit.rtc.audio_mixer" href="audio_mixer.html">livekit.rtc.audio_mixer</a></code></li>
<li><code><a title="livekit.rtc.audio_resampler" href="audio_resampler.html">livekit.rtc.audio_resampler</a></code></li>
<li><code><a title="livekit.rtc.audio_source" href="audio_source.html">livekit.rtc.audio_source</a></code></li>
<li><code><a title="livekit.rtc.audio_stream" href="audio_stream.html">livekit.rtc.audio_stream</a></code></li>
<li><code><a title="livekit.rtc.data_stream" href="data_stream.html">livekit.rtc.data_stream</a></code></li>
<li><code><a title="livekit.rtc.e2ee" href="e2ee.html">livekit.rtc.e2ee</a></code></li>
<li><code><a title="livekit.rtc.event_emitter" href="event_emitter.html">livekit.rtc.event_emitter</a></code></li>
<li><code><a title="livekit.rtc.jupyter" href="jupyter.html">livekit.rtc.jupyter</a></code></li>
<li><code><a title="livekit.rtc.log" href="log.html">livekit.rtc.log</a></code></li>
<li><code><a title="livekit.rtc.participant" href="participant.html">livekit.rtc.participant</a></code></li>
<li><code><a title="livekit.rtc.resources" href="resources/index.html">livekit.rtc.resources</a></code></li>
<li><code><a title="livekit.rtc.room" href="room.html">livekit.rtc.room</a></code></li>
<li><code><a title="livekit.rtc.rpc" href="rpc.html">livekit.rtc.rpc</a></code></li>
<li><code><a title="livekit.rtc.synchronizer" href="synchronizer.html">livekit.rtc.synchronizer</a></code></li>
<li><code><a title="livekit.rtc.track" href="track.html">livekit.rtc.track</a></code></li>
<li><code><a title="livekit.rtc.track_publication" href="track_publication.html">livekit.rtc.track_publication</a></code></li>
<li><code><a title="livekit.rtc.transcription" href="transcription.html">livekit.rtc.transcription</a></code></li>
<li><code><a title="livekit.rtc.utils" href="utils.html">livekit.rtc.utils</a></code></li>
<li><code><a title="livekit.rtc.version" href="version.html">livekit.rtc.version</a></code></li>
<li><code><a title="livekit.rtc.video_frame" href="video_frame.html">livekit.rtc.video_frame</a></code></li>
<li><code><a title="livekit.rtc.video_source" href="video_source.html">livekit.rtc.video_source</a></code></li>
<li><code><a title="livekit.rtc.video_stream" href="video_stream.html">livekit.rtc.video_stream</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="livekit.rtc.combine_audio_frames" href="#livekit.rtc.combine_audio_frames">combine_audio_frames</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="livekit.rtc.AVSynchronizer" href="#livekit.rtc.AVSynchronizer">AVSynchronizer</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.rtc.AVSynchronizer.aclose" href="#livekit.rtc.AVSynchronizer.aclose">aclose</a></code></li>
<li><code><a title="livekit.rtc.AVSynchronizer.actual_fps" href="#livekit.rtc.AVSynchronizer.actual_fps">actual_fps</a></code></li>
<li><code><a title="livekit.rtc.AVSynchronizer.clear_queue" href="#livekit.rtc.AVSynchronizer.clear_queue">clear_queue</a></code></li>
<li><code><a title="livekit.rtc.AVSynchronizer.last_audio_time" href="#livekit.rtc.AVSynchronizer.last_audio_time">last_audio_time</a></code></li>
<li><code><a title="livekit.rtc.AVSynchronizer.last_video_time" href="#livekit.rtc.AVSynchronizer.last_video_time">last_video_time</a></code></li>
<li><code><a title="livekit.rtc.AVSynchronizer.push" href="#livekit.rtc.AVSynchronizer.push">push</a></code></li>
<li><code><a title="livekit.rtc.AVSynchronizer.reset" href="#livekit.rtc.AVSynchronizer.reset">reset</a></code></li>
<li><code><a title="livekit.rtc.AVSynchronizer.wait_for_playout" href="#livekit.rtc.AVSynchronizer.wait_for_playout">wait_for_playout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.AudioFilter" href="#livekit.rtc.AudioFilter">AudioFilter</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.rtc.AudioFrame" href="#livekit.rtc.AudioFrame">AudioFrame</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.rtc.AudioFrame.create" href="#livekit.rtc.AudioFrame.create">create</a></code></li>
<li><code><a title="livekit.rtc.AudioFrame.data" href="#livekit.rtc.AudioFrame.data">data</a></code></li>
<li><code><a title="livekit.rtc.AudioFrame.duration" href="#livekit.rtc.AudioFrame.duration">duration</a></code></li>
<li><code><a title="livekit.rtc.AudioFrame.num_channels" href="#livekit.rtc.AudioFrame.num_channels">num_channels</a></code></li>
<li><code><a title="livekit.rtc.AudioFrame.sample_rate" href="#livekit.rtc.AudioFrame.sample_rate">sample_rate</a></code></li>
<li><code><a title="livekit.rtc.AudioFrame.samples_per_channel" href="#livekit.rtc.AudioFrame.samples_per_channel">samples_per_channel</a></code></li>
<li><code><a title="livekit.rtc.AudioFrame.to_wav_bytes" href="#livekit.rtc.AudioFrame.to_wav_bytes">to_wav_bytes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.AudioFrameEvent" href="#livekit.rtc.AudioFrameEvent">AudioFrameEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.AudioFrameEvent.frame" href="#livekit.rtc.AudioFrameEvent.frame">frame</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.AudioMixer" href="#livekit.rtc.AudioMixer">AudioMixer</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.AudioMixer.aclose" href="#livekit.rtc.AudioMixer.aclose">aclose</a></code></li>
<li><code><a title="livekit.rtc.AudioMixer.add_stream" href="#livekit.rtc.AudioMixer.add_stream">add_stream</a></code></li>
<li><code><a title="livekit.rtc.AudioMixer.end_input" href="#livekit.rtc.AudioMixer.end_input">end_input</a></code></li>
<li><code><a title="livekit.rtc.AudioMixer.remove_stream" href="#livekit.rtc.AudioMixer.remove_stream">remove_stream</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.AudioProcessingModule" href="#livekit.rtc.AudioProcessingModule">AudioProcessingModule</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.AudioProcessingModule.process_reverse_stream" href="#livekit.rtc.AudioProcessingModule.process_reverse_stream">process_reverse_stream</a></code></li>
<li><code><a title="livekit.rtc.AudioProcessingModule.process_stream" href="#livekit.rtc.AudioProcessingModule.process_stream">process_stream</a></code></li>
<li><code><a title="livekit.rtc.AudioProcessingModule.set_stream_delay_ms" href="#livekit.rtc.AudioProcessingModule.set_stream_delay_ms">set_stream_delay_ms</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.AudioResampler" href="#livekit.rtc.AudioResampler">AudioResampler</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.AudioResampler.flush" href="#livekit.rtc.AudioResampler.flush">flush</a></code></li>
<li><code><a title="livekit.rtc.AudioResampler.push" href="#livekit.rtc.AudioResampler.push">push</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.AudioResamplerQuality" href="#livekit.rtc.AudioResamplerQuality">AudioResamplerQuality</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.AudioResamplerQuality.HIGH" href="#livekit.rtc.AudioResamplerQuality.HIGH">HIGH</a></code></li>
<li><code><a title="livekit.rtc.AudioResamplerQuality.LOW" href="#livekit.rtc.AudioResamplerQuality.LOW">LOW</a></code></li>
<li><code><a title="livekit.rtc.AudioResamplerQuality.MEDIUM" href="#livekit.rtc.AudioResamplerQuality.MEDIUM">MEDIUM</a></code></li>
<li><code><a title="livekit.rtc.AudioResamplerQuality.QUICK" href="#livekit.rtc.AudioResamplerQuality.QUICK">QUICK</a></code></li>
<li><code><a title="livekit.rtc.AudioResamplerQuality.VERY_HIGH" href="#livekit.rtc.AudioResamplerQuality.VERY_HIGH">VERY_HIGH</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.AudioSource" href="#livekit.rtc.AudioSource">AudioSource</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.rtc.AudioSource.aclose" href="#livekit.rtc.AudioSource.aclose">aclose</a></code></li>
<li><code><a title="livekit.rtc.AudioSource.capture_frame" href="#livekit.rtc.AudioSource.capture_frame">capture_frame</a></code></li>
<li><code><a title="livekit.rtc.AudioSource.clear_queue" href="#livekit.rtc.AudioSource.clear_queue">clear_queue</a></code></li>
<li><code><a title="livekit.rtc.AudioSource.num_channels" href="#livekit.rtc.AudioSource.num_channels">num_channels</a></code></li>
<li><code><a title="livekit.rtc.AudioSource.queued_duration" href="#livekit.rtc.AudioSource.queued_duration">queued_duration</a></code></li>
<li><code><a title="livekit.rtc.AudioSource.sample_rate" href="#livekit.rtc.AudioSource.sample_rate">sample_rate</a></code></li>
<li><code><a title="livekit.rtc.AudioSource.wait_for_playout" href="#livekit.rtc.AudioSource.wait_for_playout">wait_for_playout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.AudioStream" href="#livekit.rtc.AudioStream">AudioStream</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.AudioStream.aclose" href="#livekit.rtc.AudioStream.aclose">aclose</a></code></li>
<li><code><a title="livekit.rtc.AudioStream.from_participant" href="#livekit.rtc.AudioStream.from_participant">from_participant</a></code></li>
<li><code><a title="livekit.rtc.AudioStream.from_track" href="#livekit.rtc.AudioStream.from_track">from_track</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.ByteStreamInfo" href="#livekit.rtc.ByteStreamInfo">ByteStreamInfo</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.ByteStreamInfo.name" href="#livekit.rtc.ByteStreamInfo.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.ByteStreamReader" href="#livekit.rtc.ByteStreamReader">ByteStreamReader</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.ByteStreamReader.info" href="#livekit.rtc.ByteStreamReader.info">info</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.ByteStreamWriter" href="#livekit.rtc.ByteStreamWriter">ByteStreamWriter</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.ByteStreamWriter.info" href="#livekit.rtc.ByteStreamWriter.info">info</a></code></li>
<li><code><a title="livekit.rtc.ByteStreamWriter.write" href="#livekit.rtc.ByteStreamWriter.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.ConnectError" href="#livekit.rtc.ConnectError">ConnectError</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.rtc.DataPacket" href="#livekit.rtc.DataPacket">DataPacket</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.DataPacket.data" href="#livekit.rtc.DataPacket.data">data</a></code></li>
<li><code><a title="livekit.rtc.DataPacket.kind" href="#livekit.rtc.DataPacket.kind">kind</a></code></li>
<li><code><a title="livekit.rtc.DataPacket.participant" href="#livekit.rtc.DataPacket.participant">participant</a></code></li>
<li><code><a title="livekit.rtc.DataPacket.topic" href="#livekit.rtc.DataPacket.topic">topic</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.E2EEManager" href="#livekit.rtc.E2EEManager">E2EEManager</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.E2EEManager.enabled" href="#livekit.rtc.E2EEManager.enabled">enabled</a></code></li>
<li><code><a title="livekit.rtc.E2EEManager.frame_cryptors" href="#livekit.rtc.E2EEManager.frame_cryptors">frame_cryptors</a></code></li>
<li><code><a title="livekit.rtc.E2EEManager.key_provider" href="#livekit.rtc.E2EEManager.key_provider">key_provider</a></code></li>
<li><code><a title="livekit.rtc.E2EEManager.set_enabled" href="#livekit.rtc.E2EEManager.set_enabled">set_enabled</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.E2EEOptions" href="#livekit.rtc.E2EEOptions">E2EEOptions</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.E2EEOptions.encryption_type" href="#livekit.rtc.E2EEOptions.encryption_type">encryption_type</a></code></li>
<li><code><a title="livekit.rtc.E2EEOptions.key_provider_options" href="#livekit.rtc.E2EEOptions.key_provider_options">key_provider_options</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.EventEmitter" href="#livekit.rtc.EventEmitter">EventEmitter</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.EventEmitter.emit" href="#livekit.rtc.EventEmitter.emit">emit</a></code></li>
<li><code><a title="livekit.rtc.EventEmitter.off" href="#livekit.rtc.EventEmitter.off">off</a></code></li>
<li><code><a title="livekit.rtc.EventEmitter.on" href="#livekit.rtc.EventEmitter.on">on</a></code></li>
<li><code><a title="livekit.rtc.EventEmitter.once" href="#livekit.rtc.EventEmitter.once">once</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.FrameCryptor" href="#livekit.rtc.FrameCryptor">FrameCryptor</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.FrameCryptor.enabled" href="#livekit.rtc.FrameCryptor.enabled">enabled</a></code></li>
<li><code><a title="livekit.rtc.FrameCryptor.key_index" href="#livekit.rtc.FrameCryptor.key_index">key_index</a></code></li>
<li><code><a title="livekit.rtc.FrameCryptor.participant_identity" href="#livekit.rtc.FrameCryptor.participant_identity">participant_identity</a></code></li>
<li><code><a title="livekit.rtc.FrameCryptor.set_enabled" href="#livekit.rtc.FrameCryptor.set_enabled">set_enabled</a></code></li>
<li><code><a title="livekit.rtc.FrameCryptor.set_key_index" href="#livekit.rtc.FrameCryptor.set_key_index">set_key_index</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.IceServer" href="#livekit.rtc.IceServer">IceServer</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.IceServer.DESCRIPTOR" href="#livekit.rtc.IceServer.DESCRIPTOR">DESCRIPTOR</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.KeyProvider" href="#livekit.rtc.KeyProvider">KeyProvider</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.rtc.KeyProvider.export_key" href="#livekit.rtc.KeyProvider.export_key">export_key</a></code></li>
<li><code><a title="livekit.rtc.KeyProvider.export_shared_key" href="#livekit.rtc.KeyProvider.export_shared_key">export_shared_key</a></code></li>
<li><code><a title="livekit.rtc.KeyProvider.options" href="#livekit.rtc.KeyProvider.options">options</a></code></li>
<li><code><a title="livekit.rtc.KeyProvider.ratchet_key" href="#livekit.rtc.KeyProvider.ratchet_key">ratchet_key</a></code></li>
<li><code><a title="livekit.rtc.KeyProvider.ratchet_shared_key" href="#livekit.rtc.KeyProvider.ratchet_shared_key">ratchet_shared_key</a></code></li>
<li><code><a title="livekit.rtc.KeyProvider.set_key" href="#livekit.rtc.KeyProvider.set_key">set_key</a></code></li>
<li><code><a title="livekit.rtc.KeyProvider.set_shared_key" href="#livekit.rtc.KeyProvider.set_shared_key">set_shared_key</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.KeyProviderOptions" href="#livekit.rtc.KeyProviderOptions">KeyProviderOptions</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.KeyProviderOptions.failure_tolerance" href="#livekit.rtc.KeyProviderOptions.failure_tolerance">failure_tolerance</a></code></li>
<li><code><a title="livekit.rtc.KeyProviderOptions.ratchet_salt" href="#livekit.rtc.KeyProviderOptions.ratchet_salt">ratchet_salt</a></code></li>
<li><code><a title="livekit.rtc.KeyProviderOptions.ratchet_window_size" href="#livekit.rtc.KeyProviderOptions.ratchet_window_size">ratchet_window_size</a></code></li>
<li><code><a title="livekit.rtc.KeyProviderOptions.shared_key" href="#livekit.rtc.KeyProviderOptions.shared_key">shared_key</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.LocalAudioTrack" href="#livekit.rtc.LocalAudioTrack">LocalAudioTrack</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.LocalAudioTrack.create_audio_track" href="#livekit.rtc.LocalAudioTrack.create_audio_track">create_audio_track</a></code></li>
<li><code><a title="livekit.rtc.LocalAudioTrack.mute" href="#livekit.rtc.LocalAudioTrack.mute">mute</a></code></li>
<li><code><a title="livekit.rtc.LocalAudioTrack.unmute" href="#livekit.rtc.LocalAudioTrack.unmute">unmute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.LocalParticipant" href="#livekit.rtc.LocalParticipant">LocalParticipant</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.LocalParticipant.perform_rpc" href="#livekit.rtc.LocalParticipant.perform_rpc">perform_rpc</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.publish_data" href="#livekit.rtc.LocalParticipant.publish_data">publish_data</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.publish_dtmf" href="#livekit.rtc.LocalParticipant.publish_dtmf">publish_dtmf</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.publish_track" href="#livekit.rtc.LocalParticipant.publish_track">publish_track</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.publish_transcription" href="#livekit.rtc.LocalParticipant.publish_transcription">publish_transcription</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.register_rpc_method" href="#livekit.rtc.LocalParticipant.register_rpc_method">register_rpc_method</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.send_file" href="#livekit.rtc.LocalParticipant.send_file">send_file</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.send_text" href="#livekit.rtc.LocalParticipant.send_text">send_text</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.set_attributes" href="#livekit.rtc.LocalParticipant.set_attributes">set_attributes</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.set_metadata" href="#livekit.rtc.LocalParticipant.set_metadata">set_metadata</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.set_name" href="#livekit.rtc.LocalParticipant.set_name">set_name</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.set_track_subscription_permissions" href="#livekit.rtc.LocalParticipant.set_track_subscription_permissions">set_track_subscription_permissions</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.stream_bytes" href="#livekit.rtc.LocalParticipant.stream_bytes">stream_bytes</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.stream_text" href="#livekit.rtc.LocalParticipant.stream_text">stream_text</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.unpublish_track" href="#livekit.rtc.LocalParticipant.unpublish_track">unpublish_track</a></code></li>
<li><code><a title="livekit.rtc.LocalParticipant.unregister_rpc_method" href="#livekit.rtc.LocalParticipant.unregister_rpc_method">unregister_rpc_method</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.LocalTrackPublication" href="#livekit.rtc.LocalTrackPublication">LocalTrackPublication</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.LocalTrackPublication.track" href="#livekit.rtc.LocalTrackPublication.track">track</a></code></li>
<li><code><a title="livekit.rtc.LocalTrackPublication.wait_for_subscription" href="#livekit.rtc.LocalTrackPublication.wait_for_subscription">wait_for_subscription</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.LocalVideoTrack" href="#livekit.rtc.LocalVideoTrack">LocalVideoTrack</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.LocalVideoTrack.create_video_track" href="#livekit.rtc.LocalVideoTrack.create_video_track">create_video_track</a></code></li>
<li><code><a title="livekit.rtc.LocalVideoTrack.mute" href="#livekit.rtc.LocalVideoTrack.mute">mute</a></code></li>
<li><code><a title="livekit.rtc.LocalVideoTrack.unmute" href="#livekit.rtc.LocalVideoTrack.unmute">unmute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.NoiseCancellationOptions" href="#livekit.rtc.NoiseCancellationOptions">NoiseCancellationOptions</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.NoiseCancellationOptions.module_id" href="#livekit.rtc.NoiseCancellationOptions.module_id">module_id</a></code></li>
<li><code><a title="livekit.rtc.NoiseCancellationOptions.options" href="#livekit.rtc.NoiseCancellationOptions.options">options</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.Participant" href="#livekit.rtc.Participant">Participant</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.rtc.Participant.attributes" href="#livekit.rtc.Participant.attributes">attributes</a></code></li>
<li><code><a title="livekit.rtc.Participant.disconnect_reason" href="#livekit.rtc.Participant.disconnect_reason">disconnect_reason</a></code></li>
<li><code><a title="livekit.rtc.Participant.identity" href="#livekit.rtc.Participant.identity">identity</a></code></li>
<li><code><a title="livekit.rtc.Participant.kind" href="#livekit.rtc.Participant.kind">kind</a></code></li>
<li><code><a title="livekit.rtc.Participant.metadata" href="#livekit.rtc.Participant.metadata">metadata</a></code></li>
<li><code><a title="livekit.rtc.Participant.name" href="#livekit.rtc.Participant.name">name</a></code></li>
<li><code><a title="livekit.rtc.Participant.sid" href="#livekit.rtc.Participant.sid">sid</a></code></li>
<li><code><a title="livekit.rtc.Participant.track_publications" href="#livekit.rtc.Participant.track_publications">track_publications</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.ParticipantTrackPermission" href="#livekit.rtc.ParticipantTrackPermission">ParticipantTrackPermission</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.ParticipantTrackPermission.DESCRIPTOR" href="#livekit.rtc.ParticipantTrackPermission.DESCRIPTOR">DESCRIPTOR</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.RemoteAudioTrack" href="#livekit.rtc.RemoteAudioTrack">RemoteAudioTrack</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.rtc.RemoteParticipant" href="#livekit.rtc.RemoteParticipant">RemoteParticipant</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.rtc.RemoteTrackPublication" href="#livekit.rtc.RemoteTrackPublication">RemoteTrackPublication</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.RemoteTrackPublication.set_subscribed" href="#livekit.rtc.RemoteTrackPublication.set_subscribed">set_subscribed</a></code></li>
<li><code><a title="livekit.rtc.RemoteTrackPublication.subscribed" href="#livekit.rtc.RemoteTrackPublication.subscribed">subscribed</a></code></li>
<li><code><a title="livekit.rtc.RemoteTrackPublication.track" href="#livekit.rtc.RemoteTrackPublication.track">track</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.RemoteVideoTrack" href="#livekit.rtc.RemoteVideoTrack">RemoteVideoTrack</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.rtc.Room" href="#livekit.rtc.Room">Room</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.Room.connect" href="#livekit.rtc.Room.connect">connect</a></code></li>
<li><code><a title="livekit.rtc.Room.connection_state" href="#livekit.rtc.Room.connection_state">connection_state</a></code></li>
<li><code><a title="livekit.rtc.Room.disconnect" href="#livekit.rtc.Room.disconnect">disconnect</a></code></li>
<li><code><a title="livekit.rtc.Room.e2ee_manager" href="#livekit.rtc.Room.e2ee_manager">e2ee_manager</a></code></li>
<li><code><a title="livekit.rtc.Room.isconnected" href="#livekit.rtc.Room.isconnected">isconnected</a></code></li>
<li><code><a title="livekit.rtc.Room.local_participant" href="#livekit.rtc.Room.local_participant">local_participant</a></code></li>
<li><code><a title="livekit.rtc.Room.metadata" href="#livekit.rtc.Room.metadata">metadata</a></code></li>
<li><code><a title="livekit.rtc.Room.name" href="#livekit.rtc.Room.name">name</a></code></li>
<li><code><a title="livekit.rtc.Room.on" href="#livekit.rtc.Room.on">on</a></code></li>
<li><code><a title="livekit.rtc.Room.register_byte_stream_handler" href="#livekit.rtc.Room.register_byte_stream_handler">register_byte_stream_handler</a></code></li>
<li><code><a title="livekit.rtc.Room.register_text_stream_handler" href="#livekit.rtc.Room.register_text_stream_handler">register_text_stream_handler</a></code></li>
<li><code><a title="livekit.rtc.Room.remote_participants" href="#livekit.rtc.Room.remote_participants">remote_participants</a></code></li>
<li><code><a title="livekit.rtc.Room.sid" href="#livekit.rtc.Room.sid">sid</a></code></li>
<li><code><a title="livekit.rtc.Room.unregister_byte_stream_handler" href="#livekit.rtc.Room.unregister_byte_stream_handler">unregister_byte_stream_handler</a></code></li>
<li><code><a title="livekit.rtc.Room.unregister_text_stream_handler" href="#livekit.rtc.Room.unregister_text_stream_handler">unregister_text_stream_handler</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.RoomOptions" href="#livekit.rtc.RoomOptions">RoomOptions</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.RoomOptions.auto_subscribe" href="#livekit.rtc.RoomOptions.auto_subscribe">auto_subscribe</a></code></li>
<li><code><a title="livekit.rtc.RoomOptions.dynacast" href="#livekit.rtc.RoomOptions.dynacast">dynacast</a></code></li>
<li><code><a title="livekit.rtc.RoomOptions.e2ee" href="#livekit.rtc.RoomOptions.e2ee">e2ee</a></code></li>
<li><code><a title="livekit.rtc.RoomOptions.rtc_config" href="#livekit.rtc.RoomOptions.rtc_config">rtc_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.RpcError" href="#livekit.rtc.RpcError">RpcError</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.RpcError.ErrorCode" href="#livekit.rtc.RpcError.ErrorCode">ErrorCode</a></code></li>
<li><code><a title="livekit.rtc.RpcError.ErrorMessage" href="#livekit.rtc.RpcError.ErrorMessage">ErrorMessage</a></code></li>
<li><code><a title="livekit.rtc.RpcError.code" href="#livekit.rtc.RpcError.code">code</a></code></li>
<li><code><a title="livekit.rtc.RpcError.data" href="#livekit.rtc.RpcError.data">data</a></code></li>
<li><code><a title="livekit.rtc.RpcError.message" href="#livekit.rtc.RpcError.message">message</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.RpcInvocationData" href="#livekit.rtc.RpcInvocationData">RpcInvocationData</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.RpcInvocationData.caller_identity" href="#livekit.rtc.RpcInvocationData.caller_identity">caller_identity</a></code></li>
<li><code><a title="livekit.rtc.RpcInvocationData.payload" href="#livekit.rtc.RpcInvocationData.payload">payload</a></code></li>
<li><code><a title="livekit.rtc.RpcInvocationData.request_id" href="#livekit.rtc.RpcInvocationData.request_id">request_id</a></code></li>
<li><code><a title="livekit.rtc.RpcInvocationData.response_timeout" href="#livekit.rtc.RpcInvocationData.response_timeout">response_timeout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.RtcConfiguration" href="#livekit.rtc.RtcConfiguration">RtcConfiguration</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.RtcConfiguration.continual_gathering_policy" href="#livekit.rtc.RtcConfiguration.continual_gathering_policy">continual_gathering_policy</a></code></li>
<li><code><a title="livekit.rtc.RtcConfiguration.ice_servers" href="#livekit.rtc.RtcConfiguration.ice_servers">ice_servers</a></code></li>
<li><code><a title="livekit.rtc.RtcConfiguration.ice_transport_type" href="#livekit.rtc.RtcConfiguration.ice_transport_type">ice_transport_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.SipDTMF" href="#livekit.rtc.SipDTMF">SipDTMF</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.SipDTMF.code" href="#livekit.rtc.SipDTMF.code">code</a></code></li>
<li><code><a title="livekit.rtc.SipDTMF.digit" href="#livekit.rtc.SipDTMF.digit">digit</a></code></li>
<li><code><a title="livekit.rtc.SipDTMF.participant" href="#livekit.rtc.SipDTMF.participant">participant</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.TextStreamInfo" href="#livekit.rtc.TextStreamInfo">TextStreamInfo</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.TextStreamInfo.attachments" href="#livekit.rtc.TextStreamInfo.attachments">attachments</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.TextStreamReader" href="#livekit.rtc.TextStreamReader">TextStreamReader</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.TextStreamReader.info" href="#livekit.rtc.TextStreamReader.info">info</a></code></li>
<li><code><a title="livekit.rtc.TextStreamReader.read_all" href="#livekit.rtc.TextStreamReader.read_all">read_all</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.TextStreamWriter" href="#livekit.rtc.TextStreamWriter">TextStreamWriter</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.TextStreamWriter.info" href="#livekit.rtc.TextStreamWriter.info">info</a></code></li>
<li><code><a title="livekit.rtc.TextStreamWriter.write" href="#livekit.rtc.TextStreamWriter.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.Track" href="#livekit.rtc.Track">Track</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.rtc.Track.get_stats" href="#livekit.rtc.Track.get_stats">get_stats</a></code></li>
<li><code><a title="livekit.rtc.Track.kind" href="#livekit.rtc.Track.kind">kind</a></code></li>
<li><code><a title="livekit.rtc.Track.muted" href="#livekit.rtc.Track.muted">muted</a></code></li>
<li><code><a title="livekit.rtc.Track.name" href="#livekit.rtc.Track.name">name</a></code></li>
<li><code><a title="livekit.rtc.Track.sid" href="#livekit.rtc.Track.sid">sid</a></code></li>
<li><code><a title="livekit.rtc.Track.stream_state" href="#livekit.rtc.Track.stream_state">stream_state</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.TrackPublication" href="#livekit.rtc.TrackPublication">TrackPublication</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.rtc.TrackPublication.encryption_type" href="#livekit.rtc.TrackPublication.encryption_type">encryption_type</a></code></li>
<li><code><a title="livekit.rtc.TrackPublication.height" href="#livekit.rtc.TrackPublication.height">height</a></code></li>
<li><code><a title="livekit.rtc.TrackPublication.kind" href="#livekit.rtc.TrackPublication.kind">kind</a></code></li>
<li><code><a title="livekit.rtc.TrackPublication.mime_type" href="#livekit.rtc.TrackPublication.mime_type">mime_type</a></code></li>
<li><code><a title="livekit.rtc.TrackPublication.muted" href="#livekit.rtc.TrackPublication.muted">muted</a></code></li>
<li><code><a title="livekit.rtc.TrackPublication.name" href="#livekit.rtc.TrackPublication.name">name</a></code></li>
<li><code><a title="livekit.rtc.TrackPublication.sid" href="#livekit.rtc.TrackPublication.sid">sid</a></code></li>
<li><code><a title="livekit.rtc.TrackPublication.simulcasted" href="#livekit.rtc.TrackPublication.simulcasted">simulcasted</a></code></li>
<li><code><a title="livekit.rtc.TrackPublication.source" href="#livekit.rtc.TrackPublication.source">source</a></code></li>
<li><code><a title="livekit.rtc.TrackPublication.track" href="#livekit.rtc.TrackPublication.track">track</a></code></li>
<li><code><a title="livekit.rtc.TrackPublication.width" href="#livekit.rtc.TrackPublication.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.TrackPublishOptions" href="#livekit.rtc.TrackPublishOptions">TrackPublishOptions</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.TrackPublishOptions.DESCRIPTOR" href="#livekit.rtc.TrackPublishOptions.DESCRIPTOR">DESCRIPTOR</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.Transcription" href="#livekit.rtc.Transcription">Transcription</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.Transcription.participant_identity" href="#livekit.rtc.Transcription.participant_identity">participant_identity</a></code></li>
<li><code><a title="livekit.rtc.Transcription.segments" href="#livekit.rtc.Transcription.segments">segments</a></code></li>
<li><code><a title="livekit.rtc.Transcription.track_sid" href="#livekit.rtc.Transcription.track_sid">track_sid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.TranscriptionSegment" href="#livekit.rtc.TranscriptionSegment">TranscriptionSegment</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.rtc.TranscriptionSegment.end_time" href="#livekit.rtc.TranscriptionSegment.end_time">end_time</a></code></li>
<li><code><a title="livekit.rtc.TranscriptionSegment.final" href="#livekit.rtc.TranscriptionSegment.final">final</a></code></li>
<li><code><a title="livekit.rtc.TranscriptionSegment.id" href="#livekit.rtc.TranscriptionSegment.id">id</a></code></li>
<li><code><a title="livekit.rtc.TranscriptionSegment.language" href="#livekit.rtc.TranscriptionSegment.language">language</a></code></li>
<li><code><a title="livekit.rtc.TranscriptionSegment.start_time" href="#livekit.rtc.TranscriptionSegment.start_time">start_time</a></code></li>
<li><code><a title="livekit.rtc.TranscriptionSegment.text" href="#livekit.rtc.TranscriptionSegment.text">text</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.VideoEncoding" href="#livekit.rtc.VideoEncoding">VideoEncoding</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.VideoEncoding.DESCRIPTOR" href="#livekit.rtc.VideoEncoding.DESCRIPTOR">DESCRIPTOR</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.VideoFrame" href="#livekit.rtc.VideoFrame">VideoFrame</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.rtc.VideoFrame.convert" href="#livekit.rtc.VideoFrame.convert">convert</a></code></li>
<li><code><a title="livekit.rtc.VideoFrame.data" href="#livekit.rtc.VideoFrame.data">data</a></code></li>
<li><code><a title="livekit.rtc.VideoFrame.get_plane" href="#livekit.rtc.VideoFrame.get_plane">get_plane</a></code></li>
<li><code><a title="livekit.rtc.VideoFrame.height" href="#livekit.rtc.VideoFrame.height">height</a></code></li>
<li><code><a title="livekit.rtc.VideoFrame.type" href="#livekit.rtc.VideoFrame.type">type</a></code></li>
<li><code><a title="livekit.rtc.VideoFrame.width" href="#livekit.rtc.VideoFrame.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.VideoFrameEvent" href="#livekit.rtc.VideoFrameEvent">VideoFrameEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.VideoFrameEvent.frame" href="#livekit.rtc.VideoFrameEvent.frame">frame</a></code></li>
<li><code><a title="livekit.rtc.VideoFrameEvent.rotation" href="#livekit.rtc.VideoFrameEvent.rotation">rotation</a></code></li>
<li><code><a title="livekit.rtc.VideoFrameEvent.timestamp_us" href="#livekit.rtc.VideoFrameEvent.timestamp_us">timestamp_us</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.VideoSource" href="#livekit.rtc.VideoSource">VideoSource</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.VideoSource.aclose" href="#livekit.rtc.VideoSource.aclose">aclose</a></code></li>
<li><code><a title="livekit.rtc.VideoSource.capture_frame" href="#livekit.rtc.VideoSource.capture_frame">capture_frame</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.rtc.VideoStream" href="#livekit.rtc.VideoStream">VideoStream</a></code></h4>
<ul class="">
<li><code><a title="livekit.rtc.VideoStream.aclose" href="#livekit.rtc.VideoStream.aclose">aclose</a></code></li>
<li><code><a title="livekit.rtc.VideoStream.from_participant" href="#livekit.rtc.VideoStream.from_participant">from_participant</a></code></li>
<li><code><a title="livekit.rtc.VideoStream.from_track" href="#livekit.rtc.VideoStream.from_track">from_track</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
