<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>livekit.agents.utils API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>livekit.agents.utils</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="livekit.agents.utils.aio" href="aio/index.html">livekit.agents.utils.aio</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.utils.audio" href="audio.html">livekit.agents.utils.audio</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.utils.codecs" href="codecs/index.html">livekit.agents.utils.codecs</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.utils.connection_pool" href="connection_pool.html">livekit.agents.utils.connection_pool</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.utils.exp_filter" href="exp_filter.html">livekit.agents.utils.exp_filter</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.utils.http_context" href="http_context.html">livekit.agents.utils.http_context</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.utils.hw" href="hw/index.html">livekit.agents.utils.hw</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.utils.images" href="images/index.html">livekit.agents.utils.images</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.utils.log" href="log.html">livekit.agents.utils.log</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.utils.misc" href="misc.html">livekit.agents.utils.misc</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.utils.moving_average" href="moving_average.html">livekit.agents.utils.moving_average</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.utils.participant" href="participant.html">livekit.agents.utils.participant</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="livekit.agents.utils.combine_frames"><code class="name flex">
<span>def <span class="ident">combine_frames</span></span>(<span>buffer: AudioFrame | list[AudioFrame]) ‑> <a title="livekit.rtc.audio_frame.AudioFrame" href="../../rtc/audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_audio_frames(buffer: AudioFrame | list[AudioFrame]) -&gt; AudioFrame:
    &#34;&#34;&#34;
    Combines one or more `rtc.AudioFrame` objects into a single `rtc.AudioFrame`.

    This function concatenates the audio data from multiple frames, ensuring that
    all frames have the same sample rate and number of channels. It efficiently
    merges the data by preallocating the necessary memory and copying the frame
    data without unnecessary reallocations.

    Args:
        buffer: A single `rtc.AudioFrame` or a list of `rtc.AudioFrame`
            objects to be combined.

    Returns:
        rtc.AudioFrame: A new `rtc.AudioFrame` containing the combined audio data.

    Raises:
        ValueError: If the buffer is empty.
        ValueError: If frames have differing sample rates.
        ValueError: If frames have differing numbers of channels.

    Example:
        &gt;&gt;&gt; frame1 = rtc.AudioFrame(
        ...     data=b&#34;\x01\x02&#34;, sample_rate=48000, num_channels=2, samples_per_channel=1
        ... )
        &gt;&gt;&gt; frame2 = rtc.AudioFrame(
        ...     data=b&#34;\x03\x04&#34;, sample_rate=48000, num_channels=2, samples_per_channel=1
        ... )
        &gt;&gt;&gt; combined_frame = combine_audio_frames([frame1, frame2])
        &gt;&gt;&gt; combined_frame.data
        b&#39;\x01\x02\x03\x04&#39;
        &gt;&gt;&gt; combined_frame.sample_rate
        48000
        &gt;&gt;&gt; combined_frame.num_channels
        2
        &gt;&gt;&gt; combined_frame.samples_per_channel
        2
    &#34;&#34;&#34;
    if not isinstance(buffer, list):
        return buffer

    if not buffer:
        raise ValueError(&#34;buffer is empty&#34;)

    sample_rate = buffer[0].sample_rate
    num_channels = buffer[0].num_channels

    total_data_length = 0
    total_samples_per_channel = 0

    for frame in buffer:
        if frame.sample_rate != sample_rate:
            raise ValueError(
                f&#34;Sample rate mismatch: expected {sample_rate}, got {frame.sample_rate}&#34;
            )

        if frame.num_channels != num_channels:
            raise ValueError(
                f&#34;Channel count mismatch: expected {num_channels}, got {frame.num_channels}&#34;
            )

        total_data_length += len(frame.data)
        total_samples_per_channel += frame.samples_per_channel

    data = bytearray(total_data_length)
    offset = 0
    for frame in buffer:
        frame_data = frame.data.cast(&#34;b&#34;)
        data[offset : offset + len(frame_data)] = frame_data
        offset += len(frame_data)

    return AudioFrame(
        data=data,
        sample_rate=sample_rate,
        num_channels=num_channels,
        samples_per_channel=total_samples_per_channel,
    )</code></pre>
</details>
<div class="desc"><p>Combines one or more <code>rtc.AudioFrame</code> objects into a single <code>rtc.AudioFrame</code>.</p>
<p>This function concatenates the audio data from multiple frames, ensuring that
all frames have the same sample rate and number of channels. It efficiently
merges the data by preallocating the necessary memory and copying the frame
data without unnecessary reallocations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>buffer</code></strong></dt>
<dd>A single <code>rtc.AudioFrame</code> or a list of <code>rtc.AudioFrame</code>
objects to be combined.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>rtc.AudioFrame</code></dt>
<dd>A new <code>rtc.AudioFrame</code> containing the combined audio data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the buffer is empty.</dd>
<dt><code>ValueError</code></dt>
<dd>If frames have differing sample rates.</dd>
<dt><code>ValueError</code></dt>
<dd>If frames have differing numbers of channels.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; frame1 = rtc.AudioFrame(
...     data=b&quot;&quot;, sample_rate=48000, num_channels=2, samples_per_channel=1
... )
&gt;&gt;&gt; frame2 = rtc.AudioFrame(
...     data=b&quot;&quot;, sample_rate=48000, num_channels=2, samples_per_channel=1
... )
&gt;&gt;&gt; combined_frame = combine_audio_frames([frame1, frame2])
&gt;&gt;&gt; combined_frame.data
b''
&gt;&gt;&gt; combined_frame.sample_rate
48000
&gt;&gt;&gt; combined_frame.num_channels
2
&gt;&gt;&gt; combined_frame.samples_per_channel
2
</code></pre></div>
</dd>
<dt id="livekit.agents.utils.is_given"><code class="name flex">
<span>def <span class="ident">is_given</span></span>(<span>obj: NotGivenOr[_T]) ‑> TypeGuard[~_T]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_given(obj: NotGivenOr[_T]) -&gt; TypeGuard[_T]:
    return not isinstance(obj, NotGiven)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.utils.log_exceptions"><code class="name flex">
<span>def <span class="ident">log_exceptions</span></span>(<span>msg: str = '', logger: logging.Logger = &lt;RootLogger root (WARNING)&gt;) ‑> Callable[[~F], ~F]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_exceptions(msg: str = &#34;&#34;, logger: logging.Logger = logging.getLogger()) -&gt; Callable[[F], F]:  # noqa: B008
    def deco(fn: F) -&gt; F:
        if asyncio.iscoroutinefunction(fn):

            @functools.wraps(fn)
            async def async_fn_logs(*args: Any, **kwargs: Any) -&gt; Any:
                try:
                    return await fn(*args, **kwargs)
                except Exception:
                    err = f&#34;Error in {fn.__name__}&#34;
                    if msg:
                        err += f&#34; – {msg}&#34;
                    logger.exception(err)
                    raise

            return cast(F, async_fn_logs)

        else:

            @functools.wraps(fn)
            def fn_logs(*args: Any, **kwargs: Any) -&gt; Any:
                try:
                    return fn(*args, **kwargs)
                except Exception:
                    err = f&#34;Error in {fn.__name__}&#34;
                    if msg:
                        err += f&#34; – {msg}&#34;
                    logger.exception(err)
                    raise

            return cast(F, fn_logs)

    return deco</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.utils.merge_frames"><code class="name flex">
<span>def <span class="ident">merge_frames</span></span>(<span>buffer: AudioFrame | list[AudioFrame]) ‑> <a title="livekit.rtc.audio_frame.AudioFrame" href="../../rtc/audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_audio_frames(buffer: AudioFrame | list[AudioFrame]) -&gt; AudioFrame:
    &#34;&#34;&#34;
    Combines one or more `rtc.AudioFrame` objects into a single `rtc.AudioFrame`.

    This function concatenates the audio data from multiple frames, ensuring that
    all frames have the same sample rate and number of channels. It efficiently
    merges the data by preallocating the necessary memory and copying the frame
    data without unnecessary reallocations.

    Args:
        buffer: A single `rtc.AudioFrame` or a list of `rtc.AudioFrame`
            objects to be combined.

    Returns:
        rtc.AudioFrame: A new `rtc.AudioFrame` containing the combined audio data.

    Raises:
        ValueError: If the buffer is empty.
        ValueError: If frames have differing sample rates.
        ValueError: If frames have differing numbers of channels.

    Example:
        &gt;&gt;&gt; frame1 = rtc.AudioFrame(
        ...     data=b&#34;\x01\x02&#34;, sample_rate=48000, num_channels=2, samples_per_channel=1
        ... )
        &gt;&gt;&gt; frame2 = rtc.AudioFrame(
        ...     data=b&#34;\x03\x04&#34;, sample_rate=48000, num_channels=2, samples_per_channel=1
        ... )
        &gt;&gt;&gt; combined_frame = combine_audio_frames([frame1, frame2])
        &gt;&gt;&gt; combined_frame.data
        b&#39;\x01\x02\x03\x04&#39;
        &gt;&gt;&gt; combined_frame.sample_rate
        48000
        &gt;&gt;&gt; combined_frame.num_channels
        2
        &gt;&gt;&gt; combined_frame.samples_per_channel
        2
    &#34;&#34;&#34;
    if not isinstance(buffer, list):
        return buffer

    if not buffer:
        raise ValueError(&#34;buffer is empty&#34;)

    sample_rate = buffer[0].sample_rate
    num_channels = buffer[0].num_channels

    total_data_length = 0
    total_samples_per_channel = 0

    for frame in buffer:
        if frame.sample_rate != sample_rate:
            raise ValueError(
                f&#34;Sample rate mismatch: expected {sample_rate}, got {frame.sample_rate}&#34;
            )

        if frame.num_channels != num_channels:
            raise ValueError(
                f&#34;Channel count mismatch: expected {num_channels}, got {frame.num_channels}&#34;
            )

        total_data_length += len(frame.data)
        total_samples_per_channel += frame.samples_per_channel

    data = bytearray(total_data_length)
    offset = 0
    for frame in buffer:
        frame_data = frame.data.cast(&#34;b&#34;)
        data[offset : offset + len(frame_data)] = frame_data
        offset += len(frame_data)

    return AudioFrame(
        data=data,
        sample_rate=sample_rate,
        num_channels=num_channels,
        samples_per_channel=total_samples_per_channel,
    )</code></pre>
</details>
<div class="desc"><p>Combines one or more <code>rtc.AudioFrame</code> objects into a single <code>rtc.AudioFrame</code>.</p>
<p>This function concatenates the audio data from multiple frames, ensuring that
all frames have the same sample rate and number of channels. It efficiently
merges the data by preallocating the necessary memory and copying the frame
data without unnecessary reallocations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>buffer</code></strong></dt>
<dd>A single <code>rtc.AudioFrame</code> or a list of <code>rtc.AudioFrame</code>
objects to be combined.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>rtc.AudioFrame</code></dt>
<dd>A new <code>rtc.AudioFrame</code> containing the combined audio data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the buffer is empty.</dd>
<dt><code>ValueError</code></dt>
<dd>If frames have differing sample rates.</dd>
<dt><code>ValueError</code></dt>
<dd>If frames have differing numbers of channels.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; frame1 = rtc.AudioFrame(
...     data=b&quot;&quot;, sample_rate=48000, num_channels=2, samples_per_channel=1
... )
&gt;&gt;&gt; frame2 = rtc.AudioFrame(
...     data=b&quot;&quot;, sample_rate=48000, num_channels=2, samples_per_channel=1
... )
&gt;&gt;&gt; combined_frame = combine_audio_frames([frame1, frame2])
&gt;&gt;&gt; combined_frame.data
b''
&gt;&gt;&gt; combined_frame.sample_rate
48000
&gt;&gt;&gt; combined_frame.num_channels
2
&gt;&gt;&gt; combined_frame.samples_per_channel
2
</code></pre></div>
</dd>
<dt id="livekit.agents.utils.shortuuid"><code class="name flex">
<span>def <span class="ident">shortuuid</span></span>(<span>prefix: str = '') ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shortuuid(prefix: str = &#34;&#34;) -&gt; str:
    return prefix + str(uuid.uuid4().hex)[:12]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.utils.time_ms"><code class="name flex">
<span>def <span class="ident">time_ms</span></span>(<span>) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_ms() -&gt; int:
    return int(time.time() * 1000 + 0.5)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.utils.wait_for_participant"><code class="name flex">
<span>async def <span class="ident">wait_for_participant</span></span>(<span>room: rtc.Room,<br>*,<br>identity: str | None = None,<br>kind: list[rtc.ParticipantKind.ValueType] | rtc.ParticipantKind.ValueType | None = None) ‑> <a title="livekit.rtc.participant.RemoteParticipant" href="../../rtc/participant.html#livekit.rtc.participant.RemoteParticipant">RemoteParticipant</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_participant(
    room: rtc.Room,
    *,
    identity: str | None = None,
    kind: list[rtc.ParticipantKind.ValueType] | rtc.ParticipantKind.ValueType | None = None,
) -&gt; rtc.RemoteParticipant:
    &#34;&#34;&#34;
    Returns a participant that matches the given identity. If identity is None, the first
    participant that joins the room will be returned.
    If the participant has already joined, the function will return immediately.
    &#34;&#34;&#34;
    if not room.isconnected():
        raise RuntimeError(&#34;room is not connected&#34;)

    fut = asyncio.Future[rtc.RemoteParticipant]()

    def kind_match(p: rtc.RemoteParticipant) -&gt; bool:
        if kind is None:
            return True

        if isinstance(kind, list):
            return p.kind in kind

        return p.kind == kind

    def _on_participant_connected(p: rtc.RemoteParticipant):
        if (identity is None or p.identity == identity) and kind_match(p):
            room.off(&#34;participant_connected&#34;, _on_participant_connected)
            if not fut.done():
                fut.set_result(p)

    room.on(&#34;participant_connected&#34;, _on_participant_connected)

    for p in room.remote_participants.values():
        _on_participant_connected(p)
        if fut.done():
            break

    return await fut</code></pre>
</details>
<div class="desc"><p>Returns a participant that matches the given identity. If identity is None, the first
participant that joins the room will be returned.
If the participant has already joined, the function will return immediately.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="livekit.agents.utils.ConnectionPool"><code class="flex name class">
<span>class <span class="ident">ConnectionPool</span></span>
<span>(</span><span>*,<br>max_session_duration: float | None = None,<br>mark_refreshed_on_get: bool = False,<br>connect_cb: Callable[[], Awaitable[~T]] | None = None,<br>close_cb: Callable[[~T], Awaitable[None]] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConnectionPool(Generic[T]):
    &#34;&#34;&#34;Helper class to manage persistent connections like websockets.

    Handles connection pooling and reconnection after max duration.
    Can be used as an async context manager to automatically return connections to the pool.
    &#34;&#34;&#34;

    def __init__(
        self,
        *,
        max_session_duration: Optional[float] = None,
        mark_refreshed_on_get: bool = False,
        connect_cb: Optional[Callable[[], Awaitable[T]]] = None,
        close_cb: Optional[Callable[[T], Awaitable[None]]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the connection wrapper.

        Args:
            max_session_duration: Maximum duration in seconds before forcing reconnection
            mark_refreshed_on_get: If True, the session will be marked as fresh when get() is called. only used when max_session_duration is set.
            connect_cb: Optional async callback to create new connections
            close_cb: Optional async callback to close connections
        &#34;&#34;&#34;  # noqa: E501
        self._max_session_duration = max_session_duration
        self._mark_refreshed_on_get = mark_refreshed_on_get
        self._connect_cb = connect_cb
        self._close_cb = close_cb
        self._connections: dict[T, float] = {}  # conn -&gt; connected_at timestamp
        self._available: set[T] = set()

        # store connections to be reaped (closed) later.
        self._to_close: set[T] = set()

        self._prewarm_task: Optional[weakref.ref[asyncio.Task]] = None

    async def _connect(self) -&gt; T:
        &#34;&#34;&#34;Create a new connection.

        Returns:
            The new connection object

        Raises:
            NotImplementedError: If no connect callback was provided
        &#34;&#34;&#34;
        if self._connect_cb is None:
            raise NotImplementedError(&#34;Must provide connect_cb or implement connect()&#34;)
        connection = await self._connect_cb()
        self._connections[connection] = time.time()
        return connection

    async def _drain_to_close(self) -&gt; None:
        &#34;&#34;&#34;Drain and close all the connections queued for closing.&#34;&#34;&#34;
        for conn in list(self._to_close):
            await self._maybe_close_connection(conn)
        self._to_close.clear()

    @asynccontextmanager
    async def connection(self) -&gt; AsyncGenerator[T, None]:
        &#34;&#34;&#34;Get a connection from the pool and automatically return it when done.

        Yields:
            An active connection object
        &#34;&#34;&#34;
        conn = await self.get()
        try:
            yield conn
        except BaseException:
            self.remove(conn)
            raise
        else:
            self.put(conn)

    async def get(self) -&gt; T:
        &#34;&#34;&#34;Get an available connection or create a new one if needed.

        Returns:
            An active connection object
        &#34;&#34;&#34;
        await self._drain_to_close()

        now = time.time()

        # try to reuse an available connection that hasn&#39;t expired
        while self._available:
            conn = self._available.pop()
            if (
                self._max_session_duration is None
                or now - self._connections[conn] &lt;= self._max_session_duration
            ):
                if self._mark_refreshed_on_get:
                    self._connections[conn] = now
                return conn
            # connection expired; mark it for resetting.
            self.remove(conn)

        return await self._connect()

    def put(self, conn: T) -&gt; None:
        &#34;&#34;&#34;Mark a connection as available for reuse.

        If connection has been reset, it will not be added to the pool.

        Args:
            conn: The connection to make available
        &#34;&#34;&#34;
        if conn in self._connections:
            self._available.add(conn)

    async def _maybe_close_connection(self, conn: T) -&gt; None:
        &#34;&#34;&#34;Close a connection if close_cb is provided.

        Args:
            conn: The connection to close
        &#34;&#34;&#34;
        if self._close_cb is not None:
            await self._close_cb(conn)

    def remove(self, conn: T) -&gt; None:
        &#34;&#34;&#34;Remove a specific connection from the pool.

        Marks the connection to be closed during the next drain cycle.

        Args:
            conn: The connection to reset
        &#34;&#34;&#34;
        self._available.discard(conn)
        if conn in self._connections:
            self._to_close.add(conn)
            self._connections.pop(conn, None)

    def invalidate(self) -&gt; None:
        &#34;&#34;&#34;Clear all existing connections.

        Marks all current connections to be closed during the next drain cycle.
        &#34;&#34;&#34;
        for conn in list(self._connections.keys()):
            self._to_close.add(conn)
        self._connections.clear()
        self._available.clear()

    def prewarm(self) -&gt; None:
        &#34;&#34;&#34;Initiate prewarming of the connection pool without blocking.

        This method starts a background task that creates a new connection if none exist.
        The task automatically cleans itself up when the connection pool is closed.
        &#34;&#34;&#34;
        if self._prewarm_task is not None or self._connections:
            return

        async def _prewarm_impl():
            if not self._connections:
                conn = await self._connect()
                self._available.add(conn)

        task = asyncio.create_task(_prewarm_impl())
        self._prewarm_task = weakref.ref(task)

    async def aclose(self):
        &#34;&#34;&#34;Close all connections, draining any pending connection closures.&#34;&#34;&#34;
        if self._prewarm_task is not None:
            task = self._prewarm_task()
            if task:
                await aio.gracefully_cancel(task)

        self.invalidate()
        await self._drain_to_close()</code></pre>
</details>
<div class="desc"><p>Helper class to manage persistent connections like websockets.</p>
<p>Handles connection pooling and reconnection after max duration.
Can be used as an async context manager to automatically return connections to the pool.</p>
<p>Initialize the connection wrapper.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>max_session_duration</code></strong></dt>
<dd>Maximum duration in seconds before forcing reconnection</dd>
<dt><strong><code>mark_refreshed_on_get</code></strong></dt>
<dd>If True, the session will be marked as fresh when get() is called. only used when max_session_duration is set.</dd>
<dt><strong><code>connect_cb</code></strong></dt>
<dd>Optional async callback to create new connections</dd>
<dt><strong><code>close_cb</code></strong></dt>
<dd>Optional async callback to close connections</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.utils.ConnectionPool.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self):
    &#34;&#34;&#34;Close all connections, draining any pending connection closures.&#34;&#34;&#34;
    if self._prewarm_task is not None:
        task = self._prewarm_task()
        if task:
            await aio.gracefully_cancel(task)

    self.invalidate()
    await self._drain_to_close()</code></pre>
</details>
<div class="desc"><p>Close all connections, draining any pending connection closures.</p></div>
</dd>
<dt id="livekit.agents.utils.ConnectionPool.connection"><code class="name flex">
<span>async def <span class="ident">connection</span></span>(<span>self) ‑> AsyncGenerator[~T, None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@asynccontextmanager
async def connection(self) -&gt; AsyncGenerator[T, None]:
    &#34;&#34;&#34;Get a connection from the pool and automatically return it when done.

    Yields:
        An active connection object
    &#34;&#34;&#34;
    conn = await self.get()
    try:
        yield conn
    except BaseException:
        self.remove(conn)
        raise
    else:
        self.put(conn)</code></pre>
</details>
<div class="desc"><p>Get a connection from the pool and automatically return it when done.</p>
<h2 id="yields">Yields</h2>
<p>An active connection object</p></div>
</dd>
<dt id="livekit.agents.utils.ConnectionPool.get"><code class="name flex">
<span>async def <span class="ident">get</span></span>(<span>self) ‑> ~T</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get(self) -&gt; T:
    &#34;&#34;&#34;Get an available connection or create a new one if needed.

    Returns:
        An active connection object
    &#34;&#34;&#34;
    await self._drain_to_close()

    now = time.time()

    # try to reuse an available connection that hasn&#39;t expired
    while self._available:
        conn = self._available.pop()
        if (
            self._max_session_duration is None
            or now - self._connections[conn] &lt;= self._max_session_duration
        ):
            if self._mark_refreshed_on_get:
                self._connections[conn] = now
            return conn
        # connection expired; mark it for resetting.
        self.remove(conn)

    return await self._connect()</code></pre>
</details>
<div class="desc"><p>Get an available connection or create a new one if needed.</p>
<h2 id="returns">Returns</h2>
<p>An active connection object</p></div>
</dd>
<dt id="livekit.agents.utils.ConnectionPool.invalidate"><code class="name flex">
<span>def <span class="ident">invalidate</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invalidate(self) -&gt; None:
    &#34;&#34;&#34;Clear all existing connections.

    Marks all current connections to be closed during the next drain cycle.
    &#34;&#34;&#34;
    for conn in list(self._connections.keys()):
        self._to_close.add(conn)
    self._connections.clear()
    self._available.clear()</code></pre>
</details>
<div class="desc"><p>Clear all existing connections.</p>
<p>Marks all current connections to be closed during the next drain cycle.</p></div>
</dd>
<dt id="livekit.agents.utils.ConnectionPool.prewarm"><code class="name flex">
<span>def <span class="ident">prewarm</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prewarm(self) -&gt; None:
    &#34;&#34;&#34;Initiate prewarming of the connection pool without blocking.

    This method starts a background task that creates a new connection if none exist.
    The task automatically cleans itself up when the connection pool is closed.
    &#34;&#34;&#34;
    if self._prewarm_task is not None or self._connections:
        return

    async def _prewarm_impl():
        if not self._connections:
            conn = await self._connect()
            self._available.add(conn)

    task = asyncio.create_task(_prewarm_impl())
    self._prewarm_task = weakref.ref(task)</code></pre>
</details>
<div class="desc"><p>Initiate prewarming of the connection pool without blocking.</p>
<p>This method starts a background task that creates a new connection if none exist.
The task automatically cleans itself up when the connection pool is closed.</p></div>
</dd>
<dt id="livekit.agents.utils.ConnectionPool.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self, conn: ~T) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put(self, conn: T) -&gt; None:
    &#34;&#34;&#34;Mark a connection as available for reuse.

    If connection has been reset, it will not be added to the pool.

    Args:
        conn: The connection to make available
    &#34;&#34;&#34;
    if conn in self._connections:
        self._available.add(conn)</code></pre>
</details>
<div class="desc"><p>Mark a connection as available for reuse.</p>
<p>If connection has been reset, it will not be added to the pool.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conn</code></strong></dt>
<dd>The connection to make available</dd>
</dl></div>
</dd>
<dt id="livekit.agents.utils.ConnectionPool.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, conn: ~T) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, conn: T) -&gt; None:
    &#34;&#34;&#34;Remove a specific connection from the pool.

    Marks the connection to be closed during the next drain cycle.

    Args:
        conn: The connection to reset
    &#34;&#34;&#34;
    self._available.discard(conn)
    if conn in self._connections:
        self._to_close.add(conn)
        self._connections.pop(conn, None)</code></pre>
</details>
<div class="desc"><p>Remove a specific connection from the pool.</p>
<p>Marks the connection to be closed during the next drain cycle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conn</code></strong></dt>
<dd>The connection to reset</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.utils.EventEmitter"><code class="flex name class">
<span>class <span class="ident">EventEmitter</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventEmitter(Generic[T_contra]):
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Initialize a new instance of EventEmitter.
        &#34;&#34;&#34;
        self._events: Dict[T_contra, Set[Callable]] = dict()

    def emit(self, event: T_contra, *args) -&gt; None:
        &#34;&#34;&#34;
        Trigger all callbacks associated with the given event.

        Args:
            event (T): The event to emit.
            *args: Positional arguments to pass to the callbacks.

        Example:
            Basic usage of emit:

            ```python
            emitter = EventEmitter[str]()

            def greet(name):
                print(f&#34;Hello, {name}!&#34;)

            emitter.on(&#39;greet&#39;, greet)
            emitter.emit(&#39;greet&#39;, &#39;Alice&#39;)  # Output: Hello, Alice!
            ```
        &#34;&#34;&#34;
        if event in self._events:
            callables = self._events[event].copy()
            for callback in callables:
                try:
                    sig = inspect.signature(callback)
                    params = sig.parameters.values()

                    has_varargs = any(p.kind == p.VAR_POSITIONAL for p in params)
                    if has_varargs:
                        callback(*args)
                    else:
                        positional_params = [
                            p
                            for p in params
                            if p.kind in (p.POSITIONAL_ONLY, p.POSITIONAL_OR_KEYWORD)
                        ]
                        num_params = len(positional_params)
                        num_args = min(len(args), num_params)
                        callback_args = args[:num_args]

                        callback(*callback_args)
                except TypeError:
                    raise
                except Exception:
                    logger.exception(f&#34;failed to emit event {event}&#34;)

    def once(self, event: T_contra, callback: Optional[Callable] = None) -&gt; Callable:
        &#34;&#34;&#34;
        Register a callback to be called only once when the event is emitted.

        If a callback is provided, it registers the callback directly.
        If no callback is provided, it returns a decorator for use with function definitions.

        Args:
            event (T): The event to listen for.
            callback (Callable, optional): The callback to register. Defaults to None.

        Returns:
            Callable: The registered callback or a decorator if callback is None.

        Example:
            Using once with a direct callback:

            ```python
            emitter = EventEmitter[str]()

            def greet_once(name):
                print(f&#34;Hello once, {name}!&#34;)

            emitter.once(&#39;greet&#39;, greet_once)
            emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # Output: Hello once, Bob!
            emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # No output, callback was removed after first call
            ```

            Using once as a decorator:

            ```python
            emitter = EventEmitter[str]()

            @emitter.once(&#39;greet&#39;)
            def greet_once(name):
                print(f&#34;Hello once, {name}!&#34;)

            emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # Output: Hello once, Bob!
            emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # No output
            ```
        &#34;&#34;&#34;
        if callback is not None:

            def once_callback(*args, **kwargs):
                self.off(event, once_callback)
                callback(*args, **kwargs)

            return self.on(event, once_callback)
        else:

            def decorator(callback: Callable) -&gt; Callable:
                self.once(event, callback)
                return callback

            return decorator

    def on(self, event: T_contra, callback: Optional[Callable] = None) -&gt; Callable:
        &#34;&#34;&#34;
        Register a callback to be called whenever the event is emitted.

        If a callback is provided, it registers the callback directly.
        If no callback is provided, it returns a decorator for use with function definitions.

        Args:
            event (T): The event to listen for.
            callback (Callable, optional): The callback to register. Defaults to None.

        Returns:
            Callable: The registered callback or a decorator if callback is None.

        Example:
            Using on with a direct callback:

            ```python
            emitter = EventEmitter[str]()

            def greet(name):
                print(f&#34;Hello, {name}!&#34;)

            emitter.on(&#39;greet&#39;, greet)
            emitter.emit(&#39;greet&#39;, &#39;Charlie&#39;)  # Output: Hello, Charlie!
            ```

            Using on as a decorator:

            ```python
            emitter = EventEmitter[str]()

            @emitter.on(&#39;greet&#39;)
            def greet(name):
                print(f&#34;Hello, {name}!&#34;)

            emitter.emit(&#39;greet&#39;, &#39;Charlie&#39;)  # Output: Hello, Charlie!
            ```
        &#34;&#34;&#34;
        if callback is not None:
            if asyncio.iscoroutinefunction(callback):
                raise ValueError(
                    &#34;Cannot register an async callback with `.on()`. Use `asyncio.create_task` within your synchronous callback instead.&#34;
                )

            if event not in self._events:
                self._events[event] = set()
            self._events[event].add(callback)
            return callback
        else:

            def decorator(callback: Callable) -&gt; Callable:
                self.on(event, callback)
                return callback

            return decorator

    def off(self, event: T_contra, callback: Callable) -&gt; None:
        &#34;&#34;&#34;
        Unregister a callback from an event.

        Args:
            event (T): The event to stop listening to.
            callback (Callable): The callback to remove.

        Example:
            Removing a callback:

            ```python
            emitter = EventEmitter[str]()

            def greet(name):
                print(f&#34;Hello, {name}!&#34;)

            emitter.on(&#39;greet&#39;, greet)
            emitter.off(&#39;greet&#39;, greet)
            emitter.emit(&#39;greet&#39;, &#39;Dave&#39;)  # No output, callback was removed
            ```
        &#34;&#34;&#34;
        if event in self._events:
            self._events[event].discard(callback)</code></pre>
</details>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::</p>
<pre><code>class Mapping[KT, VT]:
    def __getitem__(self, key: KT) -&gt; VT:
        ...
    # Etc.
</code></pre>
<p>On older versions of Python, however, generic classes have to
explicitly inherit from Generic.</p>
<p>After a class has been declared to be generic, it can then be used as
follows::</p>
<pre><code>def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
    try:
        return mapping[key]
    except KeyError:
        return default
</code></pre>
<p>Initialize a new instance of EventEmitter.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="livekit.agents.ipc.proc_pool.ProcPool" href="../ipc/proc_pool.html#livekit.agents.ipc.proc_pool.ProcPool">ProcPool</a></li>
<li><a title="livekit.agents.llm.llm.LLM" href="../llm/llm.html#livekit.agents.llm.llm.LLM">LLM</a></li>
<li><a title="livekit.agents.llm.realtime.RealtimeSession" href="../llm/realtime.html#livekit.agents.llm.realtime.RealtimeSession">RealtimeSession</a></li>
<li><a title="livekit.agents.stt.stt.STT" href="../stt/stt.html#livekit.agents.stt.stt.STT">STT</a></li>
<li><a title="livekit.agents.tts.tts.TTS" href="../tts/tts.html#livekit.agents.tts.tts.TTS">TTS</a></li>
<li><a title="livekit.agents.vad.VAD" href="../vad.html#livekit.agents.vad.VAD">VAD</a></li>
<li>livekit.agents.voice.agent_session.AgentSession</li>
<li>livekit.agents.voice.avatar._queue_io.QueueAudioOutput</li>
<li>livekit.agents.voice.avatar._types.AudioReceiver</li>
<li>livekit.agents.voice.io.AudioOutput</li>
<li><a title="livekit.agents.worker.Worker" href="../worker.html#livekit.agents.worker.Worker">Worker</a></li>
<li><a title="livekit.rtc.room.Room" href="../../rtc/room.html#livekit.rtc.room.Room">Room</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.utils.EventEmitter.emit"><code class="name flex">
<span>def <span class="ident">emit</span></span>(<span>self, event: -T_contra, *args) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emit(self, event: T_contra, *args) -&gt; None:
    &#34;&#34;&#34;
    Trigger all callbacks associated with the given event.

    Args:
        event (T): The event to emit.
        *args: Positional arguments to pass to the callbacks.

    Example:
        Basic usage of emit:

        ```python
        emitter = EventEmitter[str]()

        def greet(name):
            print(f&#34;Hello, {name}!&#34;)

        emitter.on(&#39;greet&#39;, greet)
        emitter.emit(&#39;greet&#39;, &#39;Alice&#39;)  # Output: Hello, Alice!
        ```
    &#34;&#34;&#34;
    if event in self._events:
        callables = self._events[event].copy()
        for callback in callables:
            try:
                sig = inspect.signature(callback)
                params = sig.parameters.values()

                has_varargs = any(p.kind == p.VAR_POSITIONAL for p in params)
                if has_varargs:
                    callback(*args)
                else:
                    positional_params = [
                        p
                        for p in params
                        if p.kind in (p.POSITIONAL_ONLY, p.POSITIONAL_OR_KEYWORD)
                    ]
                    num_params = len(positional_params)
                    num_args = min(len(args), num_params)
                    callback_args = args[:num_args]

                    callback(*callback_args)
            except TypeError:
                raise
            except Exception:
                logger.exception(f&#34;failed to emit event {event}&#34;)</code></pre>
</details>
<div class="desc"><p>Trigger all callbacks associated with the given event.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>T</code></dt>
<dd>The event to emit.</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>Positional arguments to pass to the callbacks.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Basic usage of emit:</p>
<pre><code class="language-python">emitter = EventEmitter[str]()

def greet(name):
    print(f&quot;Hello, {name}!&quot;)

emitter.on('greet', greet)
emitter.emit('greet', 'Alice')  # Output: Hello, Alice!
</code></pre></div>
</dd>
<dt id="livekit.agents.utils.EventEmitter.off"><code class="name flex">
<span>def <span class="ident">off</span></span>(<span>self, event: -T_contra, callback: Callable) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def off(self, event: T_contra, callback: Callable) -&gt; None:
    &#34;&#34;&#34;
    Unregister a callback from an event.

    Args:
        event (T): The event to stop listening to.
        callback (Callable): The callback to remove.

    Example:
        Removing a callback:

        ```python
        emitter = EventEmitter[str]()

        def greet(name):
            print(f&#34;Hello, {name}!&#34;)

        emitter.on(&#39;greet&#39;, greet)
        emitter.off(&#39;greet&#39;, greet)
        emitter.emit(&#39;greet&#39;, &#39;Dave&#39;)  # No output, callback was removed
        ```
    &#34;&#34;&#34;
    if event in self._events:
        self._events[event].discard(callback)</code></pre>
</details>
<div class="desc"><p>Unregister a callback from an event.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>T</code></dt>
<dd>The event to stop listening to.</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>Callable</code></dt>
<dd>The callback to remove.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Removing a callback:</p>
<pre><code class="language-python">emitter = EventEmitter[str]()

def greet(name):
    print(f&quot;Hello, {name}!&quot;)

emitter.on('greet', greet)
emitter.off('greet', greet)
emitter.emit('greet', 'Dave')  # No output, callback was removed
</code></pre></div>
</dd>
<dt id="livekit.agents.utils.EventEmitter.on"><code class="name flex">
<span>def <span class="ident">on</span></span>(<span>self, event: -T_contra, callback: Callable | None = None) ‑> Callable</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on(self, event: T_contra, callback: Optional[Callable] = None) -&gt; Callable:
    &#34;&#34;&#34;
    Register a callback to be called whenever the event is emitted.

    If a callback is provided, it registers the callback directly.
    If no callback is provided, it returns a decorator for use with function definitions.

    Args:
        event (T): The event to listen for.
        callback (Callable, optional): The callback to register. Defaults to None.

    Returns:
        Callable: The registered callback or a decorator if callback is None.

    Example:
        Using on with a direct callback:

        ```python
        emitter = EventEmitter[str]()

        def greet(name):
            print(f&#34;Hello, {name}!&#34;)

        emitter.on(&#39;greet&#39;, greet)
        emitter.emit(&#39;greet&#39;, &#39;Charlie&#39;)  # Output: Hello, Charlie!
        ```

        Using on as a decorator:

        ```python
        emitter = EventEmitter[str]()

        @emitter.on(&#39;greet&#39;)
        def greet(name):
            print(f&#34;Hello, {name}!&#34;)

        emitter.emit(&#39;greet&#39;, &#39;Charlie&#39;)  # Output: Hello, Charlie!
        ```
    &#34;&#34;&#34;
    if callback is not None:
        if asyncio.iscoroutinefunction(callback):
            raise ValueError(
                &#34;Cannot register an async callback with `.on()`. Use `asyncio.create_task` within your synchronous callback instead.&#34;
            )

        if event not in self._events:
            self._events[event] = set()
        self._events[event].add(callback)
        return callback
    else:

        def decorator(callback: Callable) -&gt; Callable:
            self.on(event, callback)
            return callback

        return decorator</code></pre>
</details>
<div class="desc"><p>Register a callback to be called whenever the event is emitted.</p>
<p>If a callback is provided, it registers the callback directly.
If no callback is provided, it returns a decorator for use with function definitions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>T</code></dt>
<dd>The event to listen for.</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>The callback to register. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable</code></dt>
<dd>The registered callback or a decorator if callback is None.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Using on with a direct callback:</p>
<pre><code class="language-python">emitter = EventEmitter[str]()

def greet(name):
    print(f&quot;Hello, {name}!&quot;)

emitter.on('greet', greet)
emitter.emit('greet', 'Charlie')  # Output: Hello, Charlie!
</code></pre>
<p>Using on as a decorator:</p>
<pre><code class="language-python">emitter = EventEmitter[str]()

@emitter.on('greet')
def greet(name):
    print(f&quot;Hello, {name}!&quot;)

emitter.emit('greet', 'Charlie')  # Output: Hello, Charlie!
</code></pre></div>
</dd>
<dt id="livekit.agents.utils.EventEmitter.once"><code class="name flex">
<span>def <span class="ident">once</span></span>(<span>self, event: -T_contra, callback: Callable | None = None) ‑> Callable</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def once(self, event: T_contra, callback: Optional[Callable] = None) -&gt; Callable:
    &#34;&#34;&#34;
    Register a callback to be called only once when the event is emitted.

    If a callback is provided, it registers the callback directly.
    If no callback is provided, it returns a decorator for use with function definitions.

    Args:
        event (T): The event to listen for.
        callback (Callable, optional): The callback to register. Defaults to None.

    Returns:
        Callable: The registered callback or a decorator if callback is None.

    Example:
        Using once with a direct callback:

        ```python
        emitter = EventEmitter[str]()

        def greet_once(name):
            print(f&#34;Hello once, {name}!&#34;)

        emitter.once(&#39;greet&#39;, greet_once)
        emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # Output: Hello once, Bob!
        emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # No output, callback was removed after first call
        ```

        Using once as a decorator:

        ```python
        emitter = EventEmitter[str]()

        @emitter.once(&#39;greet&#39;)
        def greet_once(name):
            print(f&#34;Hello once, {name}!&#34;)

        emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # Output: Hello once, Bob!
        emitter.emit(&#39;greet&#39;, &#39;Bob&#39;)    # No output
        ```
    &#34;&#34;&#34;
    if callback is not None:

        def once_callback(*args, **kwargs):
            self.off(event, once_callback)
            callback(*args, **kwargs)

        return self.on(event, once_callback)
    else:

        def decorator(callback: Callable) -&gt; Callable:
            self.once(event, callback)
            return callback

        return decorator</code></pre>
</details>
<div class="desc"><p>Register a callback to be called only once when the event is emitted.</p>
<p>If a callback is provided, it registers the callback directly.
If no callback is provided, it returns a decorator for use with function definitions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>T</code></dt>
<dd>The event to listen for.</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>The callback to register. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable</code></dt>
<dd>The registered callback or a decorator if callback is None.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Using once with a direct callback:</p>
<pre><code class="language-python">emitter = EventEmitter[str]()

def greet_once(name):
    print(f&quot;Hello once, {name}!&quot;)

emitter.once('greet', greet_once)
emitter.emit('greet', 'Bob')    # Output: Hello once, Bob!
emitter.emit('greet', 'Bob')    # No output, callback was removed after first call
</code></pre>
<p>Using once as a decorator:</p>
<pre><code class="language-python">emitter = EventEmitter[str]()

@emitter.once('greet')
def greet_once(name):
    print(f&quot;Hello once, {name}!&quot;)

emitter.emit('greet', 'Bob')    # Output: Hello once, Bob!
emitter.emit('greet', 'Bob')    # No output
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.utils.ExpFilter"><code class="flex name class">
<span>class <span class="ident">ExpFilter</span></span>
<span>(</span><span>alpha: float, max_val: float = -1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExpFilter:
    def __init__(self, alpha: float, max_val: float = -1.0) -&gt; None:
        self._alpha = alpha
        self._filtered = -1.0
        self._max_val = max_val

    def reset(self, alpha: float = -1.0) -&gt; None:
        if alpha != -1.0:
            self._alpha = alpha
        self._filtered = -1.0

    def apply(self, exp: float, sample: float) -&gt; float:
        if self._filtered == -1.0:
            self._filtered = sample
        else:
            a = self._alpha**exp
            self._filtered = a * self._filtered + (1 - a) * sample

        if self._max_val != -1.0 and self._filtered &gt; self._max_val:
            self._filtered = self._max_val

        return self._filtered

    def filtered(self) -&gt; float:
        return self._filtered

    def update_base(self, alpha: float) -&gt; None:
        self._alpha = alpha</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.utils.ExpFilter.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, exp: float, sample: float) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, exp: float, sample: float) -&gt; float:
    if self._filtered == -1.0:
        self._filtered = sample
    else:
        a = self._alpha**exp
        self._filtered = a * self._filtered + (1 - a) * sample

    if self._max_val != -1.0 and self._filtered &gt; self._max_val:
        self._filtered = self._max_val

    return self._filtered</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.utils.ExpFilter.filtered"><code class="name flex">
<span>def <span class="ident">filtered</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filtered(self) -&gt; float:
    return self._filtered</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.utils.ExpFilter.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, alpha: float = -1.0) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self, alpha: float = -1.0) -&gt; None:
    if alpha != -1.0:
        self._alpha = alpha
    self._filtered = -1.0</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.utils.ExpFilter.update_base"><code class="name flex">
<span>def <span class="ident">update_base</span></span>(<span>self, alpha: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_base(self, alpha: float) -&gt; None:
    self._alpha = alpha</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.utils.MovingAverage"><code class="flex name class">
<span>class <span class="ident">MovingAverage</span></span>
<span>(</span><span>window_size: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MovingAverage:
    def __init__(self, window_size: int) -&gt; None:
        self._hist: list[float] = [0] * window_size
        self._sum: float = 0
        self._count: int = 0

    def add_sample(self, sample: float) -&gt; None:
        self._count += 1
        index = self._count % len(self._hist)
        if self._count &gt; len(self._hist):
            self._sum -= self._hist[index]
        self._sum += sample
        self._hist[index] = sample

    def get_avg(self) -&gt; float:
        if self._count == 0:
            return 0
        return self._sum / self.size()

    def reset(self):
        self._count = 0
        self._sum = 0

    def size(self) -&gt; int:
        return min(self._count, len(self._hist))</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.utils.MovingAverage.add_sample"><code class="name flex">
<span>def <span class="ident">add_sample</span></span>(<span>self, sample: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sample(self, sample: float) -&gt; None:
    self._count += 1
    index = self._count % len(self._hist)
    if self._count &gt; len(self._hist):
        self._sum -= self._hist[index]
    self._sum += sample
    self._hist[index] = sample</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.utils.MovingAverage.get_avg"><code class="name flex">
<span>def <span class="ident">get_avg</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_avg(self) -&gt; float:
    if self._count == 0:
        return 0
    return self._sum / self.size()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.utils.MovingAverage.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    self._count = 0
    self._sum = 0</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.utils.MovingAverage.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size(self) -&gt; int:
    return min(self._count, len(self._hist))</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="livekit.agents" href="../index.html">livekit.agents</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="livekit.agents.utils.aio" href="aio/index.html">livekit.agents.utils.aio</a></code></li>
<li><code><a title="livekit.agents.utils.audio" href="audio.html">livekit.agents.utils.audio</a></code></li>
<li><code><a title="livekit.agents.utils.codecs" href="codecs/index.html">livekit.agents.utils.codecs</a></code></li>
<li><code><a title="livekit.agents.utils.connection_pool" href="connection_pool.html">livekit.agents.utils.connection_pool</a></code></li>
<li><code><a title="livekit.agents.utils.exp_filter" href="exp_filter.html">livekit.agents.utils.exp_filter</a></code></li>
<li><code><a title="livekit.agents.utils.http_context" href="http_context.html">livekit.agents.utils.http_context</a></code></li>
<li><code><a title="livekit.agents.utils.hw" href="hw/index.html">livekit.agents.utils.hw</a></code></li>
<li><code><a title="livekit.agents.utils.images" href="images/index.html">livekit.agents.utils.images</a></code></li>
<li><code><a title="livekit.agents.utils.log" href="log.html">livekit.agents.utils.log</a></code></li>
<li><code><a title="livekit.agents.utils.misc" href="misc.html">livekit.agents.utils.misc</a></code></li>
<li><code><a title="livekit.agents.utils.moving_average" href="moving_average.html">livekit.agents.utils.moving_average</a></code></li>
<li><code><a title="livekit.agents.utils.participant" href="participant.html">livekit.agents.utils.participant</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="livekit.agents.utils.combine_frames" href="#livekit.agents.utils.combine_frames">combine_frames</a></code></li>
<li><code><a title="livekit.agents.utils.is_given" href="#livekit.agents.utils.is_given">is_given</a></code></li>
<li><code><a title="livekit.agents.utils.log_exceptions" href="#livekit.agents.utils.log_exceptions">log_exceptions</a></code></li>
<li><code><a title="livekit.agents.utils.merge_frames" href="#livekit.agents.utils.merge_frames">merge_frames</a></code></li>
<li><code><a title="livekit.agents.utils.shortuuid" href="#livekit.agents.utils.shortuuid">shortuuid</a></code></li>
<li><code><a title="livekit.agents.utils.time_ms" href="#livekit.agents.utils.time_ms">time_ms</a></code></li>
<li><code><a title="livekit.agents.utils.wait_for_participant" href="#livekit.agents.utils.wait_for_participant">wait_for_participant</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="livekit.agents.utils.ConnectionPool" href="#livekit.agents.utils.ConnectionPool">ConnectionPool</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.utils.ConnectionPool.aclose" href="#livekit.agents.utils.ConnectionPool.aclose">aclose</a></code></li>
<li><code><a title="livekit.agents.utils.ConnectionPool.connection" href="#livekit.agents.utils.ConnectionPool.connection">connection</a></code></li>
<li><code><a title="livekit.agents.utils.ConnectionPool.get" href="#livekit.agents.utils.ConnectionPool.get">get</a></code></li>
<li><code><a title="livekit.agents.utils.ConnectionPool.invalidate" href="#livekit.agents.utils.ConnectionPool.invalidate">invalidate</a></code></li>
<li><code><a title="livekit.agents.utils.ConnectionPool.prewarm" href="#livekit.agents.utils.ConnectionPool.prewarm">prewarm</a></code></li>
<li><code><a title="livekit.agents.utils.ConnectionPool.put" href="#livekit.agents.utils.ConnectionPool.put">put</a></code></li>
<li><code><a title="livekit.agents.utils.ConnectionPool.remove" href="#livekit.agents.utils.ConnectionPool.remove">remove</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.utils.EventEmitter" href="#livekit.agents.utils.EventEmitter">EventEmitter</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.utils.EventEmitter.emit" href="#livekit.agents.utils.EventEmitter.emit">emit</a></code></li>
<li><code><a title="livekit.agents.utils.EventEmitter.off" href="#livekit.agents.utils.EventEmitter.off">off</a></code></li>
<li><code><a title="livekit.agents.utils.EventEmitter.on" href="#livekit.agents.utils.EventEmitter.on">on</a></code></li>
<li><code><a title="livekit.agents.utils.EventEmitter.once" href="#livekit.agents.utils.EventEmitter.once">once</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.utils.ExpFilter" href="#livekit.agents.utils.ExpFilter">ExpFilter</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.utils.ExpFilter.apply" href="#livekit.agents.utils.ExpFilter.apply">apply</a></code></li>
<li><code><a title="livekit.agents.utils.ExpFilter.filtered" href="#livekit.agents.utils.ExpFilter.filtered">filtered</a></code></li>
<li><code><a title="livekit.agents.utils.ExpFilter.reset" href="#livekit.agents.utils.ExpFilter.reset">reset</a></code></li>
<li><code><a title="livekit.agents.utils.ExpFilter.update_base" href="#livekit.agents.utils.ExpFilter.update_base">update_base</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.utils.MovingAverage" href="#livekit.agents.utils.MovingAverage">MovingAverage</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.utils.MovingAverage.add_sample" href="#livekit.agents.utils.MovingAverage.add_sample">add_sample</a></code></li>
<li><code><a title="livekit.agents.utils.MovingAverage.get_avg" href="#livekit.agents.utils.MovingAverage.get_avg">get_avg</a></code></li>
<li><code><a title="livekit.agents.utils.MovingAverage.reset" href="#livekit.agents.utils.MovingAverage.reset">reset</a></code></li>
<li><code><a title="livekit.agents.utils.MovingAverage.size" href="#livekit.agents.utils.MovingAverage.size">size</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
