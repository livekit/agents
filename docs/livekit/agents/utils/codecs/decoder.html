<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>livekit.agents.utils.codecs.decoder API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>livekit.agents.utils.codecs.decoder</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="livekit.agents.utils.codecs.decoder.AudioStreamDecoder"><code class="flex name class">
<span>class <span class="ident">AudioStreamDecoder</span></span>
<span>(</span><span>*, sample_rate: int = 48000, num_channels: int = 1, format: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioStreamDecoder:
    &#34;&#34;&#34;A class that can be used to decode audio stream into PCM AudioFrames.

    Decoders are stateful, and it should not be reused across multiple streams. Each decoder
    is designed to decode a single stream.
    &#34;&#34;&#34;

    _max_workers: int = 10
    _executor: Optional[ThreadPoolExecutor] = None

    def __init__(
        self, *, sample_rate: int = 48000, num_channels: int = 1, format: Optional[str] = None
    ):
        self._sample_rate = sample_rate
        self._layout = &#34;mono&#34;
        if num_channels == 2:
            self._layout = &#34;stereo&#34;
        elif num_channels != 1:
            raise ValueError(f&#34;Invalid number of channels: {num_channels}&#34;)
        self._format = format.lower() if format else None

        self._output_ch = aio.Chan[rtc.AudioFrame]()
        self._closed = False
        self._started = False
        self._input_buf = StreamBuffer()
        self._loop = asyncio.get_event_loop()

        if self.__class__._executor is None:
            # each decoder instance will submit jobs to the shared pool
            self.__class__._executor = ThreadPoolExecutor(max_workers=self.__class__._max_workers)

    def push(self, chunk: bytes):
        self._input_buf.write(chunk)
        if not self._started:
            self._started = True
            # choose decode loop based on format
            if self._format == &#34;wav&#34;:
                target = self._decode_wav_loop
            else:
                target = self._decode_loop
            self._loop.run_in_executor(self.__class__._executor, target)

    def end_input(self):
        self._input_buf.end_input()
        if not self._started:
            # if no data was pushed, close the output channel
            self._output_ch.close()

    def _decode_loop(self):
        container: av.container.InputContainer | None = None
        resampler: av.AudioResampler | None = None
        try:
            # open container in low-latency streaming mode
            container = av.open(
                self._input_buf,
                mode=&#34;r&#34;,
                buffer_size=1024,
                options={
                    &#34;fflags&#34;: &#34;nobuffer+flush_packets&#34;,
                    &#34;probesize&#34;: &#34;32&#34;,
                    &#34;analyzeduration&#34;: &#34;0&#34;,
                    &#34;max_delay&#34;: &#34;0&#34;,
                },
            )
            # explicitly disable internal buffering flags on the FFmpeg container
            container.flags |= (
                av.container.Flags.no_buffer.value | av.container.Flags.flush_packets.value
            )
            if len(container.streams.audio) == 0:
                raise ValueError(&#34;no audio stream found&#34;)

            audio_stream = container.streams.audio[0]
            resampler = av.AudioResampler(format=&#34;s16&#34;, layout=self._layout, rate=self._sample_rate)

            for frame in container.decode(audio_stream):
                if self._closed:
                    return

                for resampled_frame in resampler.resample(frame):
                    nchannels = len(resampled_frame.layout.channels)
                    self._loop.call_soon_threadsafe(
                        self._output_ch.send_nowait,
                        rtc.AudioFrame(
                            data=resampled_frame.to_ndarray().tobytes(),
                            num_channels=nchannels,
                            sample_rate=int(resampled_frame.sample_rate),
                            samples_per_channel=int(resampled_frame.samples / nchannels),
                        ),
                    )

        except Exception:
            logger.exception(&#34;error decoding audio&#34;)
        finally:
            self._loop.call_soon_threadsafe(self._output_ch.close)
            if container:
                container.close()

    def _decode_wav_loop(self):
        &#34;&#34;&#34;Decode wav data from the buffer without ffmpeg, parse header and emit PCM frames.

        This can be much faster than using ffmpeg, as we are emitting frames as quickly as possible.
        &#34;&#34;&#34;

        try:
            from livekit.agents.utils.audio import AudioByteStream

            # parse RIFF header
            header = b&#34;&#34;
            while len(header) &lt; 12:
                chunk = self._input_buf.read(12 - len(header))
                if not chunk:
                    raise ValueError(&#34;Invalid WAV file: incomplete header&#34;)
                header += chunk
            if header[:4] != b&#34;RIFF&#34; or header[8:12] != b&#34;WAVE&#34;:
                raise ValueError(f&#34;Invalid WAV file: missing RIFF/WAVE: {header}&#34;)

            # parse fmt chunk
            while True:
                sub_header = self._input_buf.read(8)
                if len(sub_header) &lt; 8:
                    raise ValueError(&#34;Invalid WAV file: incomplete fmt chunk header&#34;)
                chunk_id, chunk_size = struct.unpack(&#34;&lt;4sI&#34;, sub_header)
                data = b&#34;&#34;
                remaining = chunk_size
                while remaining &gt; 0:
                    part = self._input_buf.read(min(1024, remaining))
                    if not part:
                        raise ValueError(&#34;Invalid WAV file: incomplete fmt chunk data&#34;)
                    data += part
                    remaining -= len(part)
                if chunk_id == b&#34;fmt &#34;:
                    audio_format, wave_channels, wave_rate, _, _, bits_per_sample = struct.unpack(
                        &#34;&lt;HHIIHH&#34;, data[:16]
                    )
                    if audio_format != 1:
                        raise ValueError(f&#34;Unsupported WAV audio format: {audio_format}&#34;)
                    break

            # parse data chunk
            while True:
                sub_header = self._input_buf.read(8)
                if len(sub_header) &lt; 8:
                    raise ValueError(&#34;Invalid WAV file: incomplete data chunk header&#34;)
                chunk_id, chunk_size = struct.unpack(&#34;&lt;4sI&#34;, sub_header)
                if chunk_id == b&#34;data&#34;:
                    break

                # skip chunk data
                to_skip = chunk_size
                while to_skip &gt; 0:
                    skipped = self._input_buf.read(min(1024, to_skip))
                    if not skipped:
                        raise ValueError(&#34;Invalid WAV file: incomplete chunk while seeking data&#34;)
                    to_skip -= len(skipped)

            # now ready to decode
            bstream = AudioByteStream(sample_rate=wave_rate, num_channels=wave_channels)
            resampler = rtc.AudioResampler(
                input_rate=wave_rate, output_rate=self._sample_rate, num_channels=wave_channels
            )

            def resample_and_push(frame: rtc.AudioFrame):
                for resampled_frame in resampler.push(frame):
                    self._loop.call_soon_threadsafe(
                        self._output_ch.send_nowait,
                        resampled_frame,
                    )

            while True:
                chunk = self._input_buf.read(1024)
                if not chunk:
                    break
                frames = bstream.push(chunk)
                for rtc_frame in frames:
                    resample_and_push(rtc_frame)

            for rtc_frame in bstream.flush():
                resample_and_push(rtc_frame)
        except Exception:
            logger.exception(&#34;error decoding wav&#34;)
        finally:
            self._loop.call_soon_threadsafe(self._output_ch.close)

    def __aiter__(self) -&gt; AsyncIterator[rtc.AudioFrame]:
        return self

    async def __anext__(self) -&gt; rtc.AudioFrame:
        return await self._output_ch.__anext__()

    async def aclose(self):
        if self._closed:
            return

        self.end_input()
        self._closed = True
        self._input_buf.close()
        # wait for decode loop to finish, only if anything&#39;s been pushed
        with contextlib.suppress(aio.ChanClosed):
            if self._started:
                await self._output_ch.recv()</code></pre>
</details>
<div class="desc"><p>A class that can be used to decode audio stream into PCM AudioFrames.</p>
<p>Decoders are stateful, and it should not be reused across multiple streams. Each decoder
is designed to decode a single stream.</p></div>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.utils.codecs.decoder.AudioStreamDecoder.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self):
    if self._closed:
        return

    self.end_input()
    self._closed = True
    self._input_buf.close()
    # wait for decode loop to finish, only if anything&#39;s been pushed
    with contextlib.suppress(aio.ChanClosed):
        if self._started:
            await self._output_ch.recv()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.utils.codecs.decoder.AudioStreamDecoder.end_input"><code class="name flex">
<span>def <span class="ident">end_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_input(self):
    self._input_buf.end_input()
    if not self._started:
        # if no data was pushed, close the output channel
        self._output_ch.close()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.utils.codecs.decoder.AudioStreamDecoder.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, chunk: bytes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, chunk: bytes):
    self._input_buf.write(chunk)
    if not self._started:
        self._started = True
        # choose decode loop based on format
        if self._format == &#34;wav&#34;:
            target = self._decode_wav_loop
        else:
            target = self._decode_loop
        self._loop.run_in_executor(self.__class__._executor, target)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.utils.codecs.decoder.StreamBuffer"><code class="flex name class">
<span>class <span class="ident">StreamBuffer</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StreamBuffer:
    &#34;&#34;&#34;
    A thread-safe buffer that behaves like an IO stream.
    Allows writing from one thread and reading from another.
    &#34;&#34;&#34;

    def __init__(self):
        self._buffer = io.BytesIO()
        self._lock = threading.Lock()
        self._data_available = threading.Condition(self._lock)
        self._eof = False

    def write(self, data: bytes):
        &#34;&#34;&#34;Write data to the buffer from a writer thread.&#34;&#34;&#34;
        with self._data_available:
            self._buffer.seek(0, io.SEEK_END)
            self._buffer.write(data)
            self._data_available.notify_all()

    def read(self, size: int = -1) -&gt; bytes:
        &#34;&#34;&#34;Read data from the buffer in a reader thread.&#34;&#34;&#34;

        if self._buffer.closed:
            return b&#34;&#34;

        with self._data_available:
            while True:
                if self._buffer.closed:
                    return b&#34;&#34;
                # always read from beginning
                self._buffer.seek(0)
                data = self._buffer.read(size)

                if data:
                    # shrink the buffer to remove already-read data
                    remaining = self._buffer.read()
                    self._buffer = io.BytesIO(remaining)
                    return data

                if self._eof:
                    return b&#34;&#34;

                self._data_available.wait()

    def end_input(self):
        &#34;&#34;&#34;Signal that no more data will be written.&#34;&#34;&#34;
        with self._data_available:
            self._eof = True
            self._data_available.notify_all()

    def close(self):
        self._buffer.close()</code></pre>
</details>
<div class="desc"><p>A thread-safe buffer that behaves like an IO stream.
Allows writing from one thread and reading from another.</p></div>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.utils.codecs.decoder.StreamBuffer.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self._buffer.close()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.utils.codecs.decoder.StreamBuffer.end_input"><code class="name flex">
<span>def <span class="ident">end_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_input(self):
    &#34;&#34;&#34;Signal that no more data will be written.&#34;&#34;&#34;
    with self._data_available:
        self._eof = True
        self._data_available.notify_all()</code></pre>
</details>
<div class="desc"><p>Signal that no more data will be written.</p></div>
</dd>
<dt id="livekit.agents.utils.codecs.decoder.StreamBuffer.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, size: int = -1) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, size: int = -1) -&gt; bytes:
    &#34;&#34;&#34;Read data from the buffer in a reader thread.&#34;&#34;&#34;

    if self._buffer.closed:
        return b&#34;&#34;

    with self._data_available:
        while True:
            if self._buffer.closed:
                return b&#34;&#34;
            # always read from beginning
            self._buffer.seek(0)
            data = self._buffer.read(size)

            if data:
                # shrink the buffer to remove already-read data
                remaining = self._buffer.read()
                self._buffer = io.BytesIO(remaining)
                return data

            if self._eof:
                return b&#34;&#34;

            self._data_available.wait()</code></pre>
</details>
<div class="desc"><p>Read data from the buffer in a reader thread.</p></div>
</dd>
<dt id="livekit.agents.utils.codecs.decoder.StreamBuffer.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data: bytes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, data: bytes):
    &#34;&#34;&#34;Write data to the buffer from a writer thread.&#34;&#34;&#34;
    with self._data_available:
        self._buffer.seek(0, io.SEEK_END)
        self._buffer.write(data)
        self._data_available.notify_all()</code></pre>
</details>
<div class="desc"><p>Write data to the buffer from a writer thread.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="livekit.agents.utils.codecs" href="index.html">livekit.agents.utils.codecs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="livekit.agents.utils.codecs.decoder.AudioStreamDecoder" href="#livekit.agents.utils.codecs.decoder.AudioStreamDecoder">AudioStreamDecoder</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.utils.codecs.decoder.AudioStreamDecoder.aclose" href="#livekit.agents.utils.codecs.decoder.AudioStreamDecoder.aclose">aclose</a></code></li>
<li><code><a title="livekit.agents.utils.codecs.decoder.AudioStreamDecoder.end_input" href="#livekit.agents.utils.codecs.decoder.AudioStreamDecoder.end_input">end_input</a></code></li>
<li><code><a title="livekit.agents.utils.codecs.decoder.AudioStreamDecoder.push" href="#livekit.agents.utils.codecs.decoder.AudioStreamDecoder.push">push</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.utils.codecs.decoder.StreamBuffer" href="#livekit.agents.utils.codecs.decoder.StreamBuffer">StreamBuffer</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.utils.codecs.decoder.StreamBuffer.close" href="#livekit.agents.utils.codecs.decoder.StreamBuffer.close">close</a></code></li>
<li><code><a title="livekit.agents.utils.codecs.decoder.StreamBuffer.end_input" href="#livekit.agents.utils.codecs.decoder.StreamBuffer.end_input">end_input</a></code></li>
<li><code><a title="livekit.agents.utils.codecs.decoder.StreamBuffer.read" href="#livekit.agents.utils.codecs.decoder.StreamBuffer.read">read</a></code></li>
<li><code><a title="livekit.agents.utils.codecs.decoder.StreamBuffer.write" href="#livekit.agents.utils.codecs.decoder.StreamBuffer.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
