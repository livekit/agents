<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>livekit.agents.job API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>livekit.agents.job</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="livekit.agents.job.get_current_job_context"><code class="name flex">
<span>def <span class="ident">get_current_job_context</span></span>(<span>) ‑> <a title="livekit.agents.job.JobContext" href="#livekit.agents.job.JobContext">JobContext</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_job_context() -&gt; JobContext:
    ctx = _JobContextVar.get(None)
    if ctx is None:
        raise RuntimeError(
            &#34;no job context found, are you running this code inside a job entrypoint?&#34;
        )

    return ctx</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.job.get_job_context"><code class="name flex">
<span>def <span class="ident">get_job_context</span></span>(<span>) ‑> <a title="livekit.agents.job.JobContext" href="#livekit.agents.job.JobContext">JobContext</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_job_context() -&gt; JobContext:
    ctx = _JobContextVar.get(None)
    if ctx is None:
        raise RuntimeError(
            &#34;no job context found, are you running this code inside a job entrypoint?&#34;
        )

    return ctx</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="livekit.agents.job.AutoSubscribe"><code class="flex name class">
<span>class <span class="ident">AutoSubscribe</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AutoSubscribe(str, Enum):
    SUBSCRIBE_ALL = &#34;subscribe_all&#34;
    SUBSCRIBE_NONE = &#34;subscribe_none&#34;
    AUDIO_ONLY = &#34;audio_only&#34;
    VIDEO_ONLY = &#34;video_only&#34;</code></pre>
</details>
<div class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to 'utf-8'.
errors defaults to 'strict'.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.job.AutoSubscribe.AUDIO_ONLY"><code class="name">var <span class="ident">AUDIO_ONLY</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.job.AutoSubscribe.SUBSCRIBE_ALL"><code class="name">var <span class="ident">SUBSCRIBE_ALL</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.job.AutoSubscribe.SUBSCRIBE_NONE"><code class="name">var <span class="ident">SUBSCRIBE_NONE</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.job.AutoSubscribe.VIDEO_ONLY"><code class="name">var <span class="ident">VIDEO_ONLY</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.job.JobAcceptArguments"><code class="flex name class">
<span>class <span class="ident">JobAcceptArguments</span></span>
<span>(</span><span>name: str, identity: str, metadata: str, attributes: dict[str, str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class JobAcceptArguments:
    name: str
    identity: str
    metadata: str
    attributes: dict[str, str] | None = None</code></pre>
</details>
<div class="desc"><p>JobAcceptArguments(name: 'str', identity: 'str', metadata: 'str', attributes: 'dict[str, str] | None' = None)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.job.JobAcceptArguments.attributes"><code class="name">var <span class="ident">attributes</span> : dict[str, str] | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.job.JobAcceptArguments.identity"><code class="name">var <span class="ident">identity</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.job.JobAcceptArguments.metadata"><code class="name">var <span class="ident">metadata</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.job.JobAcceptArguments.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.job.JobContext"><code class="flex name class">
<span>class <span class="ident">JobContext</span></span>
<span>(</span><span>*,<br>proc: <a title="livekit.agents.job.JobProcess" href="#livekit.agents.job.JobProcess">JobProcess</a>,<br>info: <a title="livekit.agents.job.RunningJobInfo" href="#livekit.agents.job.RunningJobInfo">RunningJobInfo</a>,<br>room: rtc.Room,<br>on_connect: Callable[[], None],<br>on_shutdown: Callable[[str], None],<br>inference_executor: InferenceExecutor)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JobContext:
    # private ctor
    def __init__(
        self,
        *,
        proc: JobProcess,
        info: RunningJobInfo,
        room: rtc.Room,
        on_connect: Callable[[], None],
        on_shutdown: Callable[[str], None],
        inference_executor: InferenceExecutor,
    ) -&gt; None:
        self._proc = proc
        self._info = info
        self._room = room
        self._on_connect = on_connect
        self._on_shutdown = on_shutdown
        self._shutdown_callbacks: list[Callable[[str], Coroutine[None, None, None]]] = []
        self._tracing_callbacks: list[Callable[[], Coroutine[None, None, None]]] = []
        self._participant_entrypoints: list[
            tuple[
                Callable[[JobContext, rtc.RemoteParticipant], Coroutine[None, None, None]],
                list[rtc.ParticipantKind.ValueType] | rtc.ParticipantKind.ValueType,
            ]
        ] = []
        self._participant_tasks = dict[tuple[str, Callable], asyncio.Task[None]]()
        self._pending_tasks = list[asyncio.Task]()
        self._room.on(&#34;participant_connected&#34;, self._participant_available)
        self._inf_executor = inference_executor

        self._init_log_factory()
        self._log_fields = {}

    def _init_log_factory(self) -&gt; None:
        old_factory = logging.getLogRecordFactory()

        def record_factory(*args, **kwargs) -&gt; logging.LogRecord:
            record = old_factory(*args, **kwargs)

            if self.proc.executor_type != JobExecutorType.PROCESS:
                try:
                    ctx = get_job_context()
                except RuntimeError:
                    return record
                else:
                    if ctx != self:
                        return record

            for key, value in self._log_fields.items():
                setattr(record, key, value)

            return record

        logging.setLogRecordFactory(record_factory)

    @property
    def inference_executor(self) -&gt; InferenceExecutor:
        return self._inf_executor

    @functools.cached_property
    def api(self) -&gt; api.LiveKitAPI:
        return api.LiveKitAPI(session=http_context.http_session())

    @property
    def proc(self) -&gt; JobProcess:
        &#34;&#34;&#34;Returns the process running the job. Useful for storing process-specific state.&#34;&#34;&#34;
        return self._proc

    @property
    def job(self) -&gt; agent.Job:
        &#34;&#34;&#34;Returns the current job that the worker is executing.&#34;&#34;&#34;
        return self._info.job

    @property
    def worker_id(self) -&gt; str:
        &#34;&#34;&#34;Returns the id of the worker.&#34;&#34;&#34;
        return self._info.worker_id

    @property
    def room(self) -&gt; rtc.Room:
        &#34;&#34;&#34;The Room object is the main interface that the worker should interact with.

        When the entrypoint is called, the worker has not connected to the Room yet.
        Certain properties of Room would not be available before calling JobContext.connect()
        &#34;&#34;&#34;
        return self._room

    @property
    def agent(self) -&gt; rtc.LocalParticipant:
        return self._room.local_participant

    @property
    def log_context_fields(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;
        Returns the current dictionary of log fields that will be injected into log records.

        These fields enable enriched structured logging and can include job metadata,
        worker ID, trace IDs, or other diagnostic context.

        The returned dictionary can be directly edited, or entirely replaced via assignment
        (e.g., `job_context.log_context_fields = {...}`)
        &#34;&#34;&#34;
        return self._log_fields

    @log_context_fields.setter
    def log_context_fields(self, fields: dict[str, Any]) -&gt; None:
        &#34;&#34;&#34;
        Sets the log fields to be injected into future log records.

        Args:
            fields (dict[str, Any]): A dictionary of key-value pairs representing
                structured data to attach to each log entry. Typically includes contextual
                information like job ID, trace information, or worker metadata.
        &#34;&#34;&#34;
        self._log_fields = fields

    def add_tracing_callback(
        self,
        callback: Callable[[], Coroutine[None, None, None]],
    ) -&gt; None:
        &#34;&#34;&#34;
        Add a callback to be called when the job is about to receive a new tracing request.
        &#34;&#34;&#34;
        self._tracing_callbacks.append(callback)

    def add_shutdown_callback(
        self,
        callback: Callable[[], Coroutine[None, None, None]]
        | Callable[[str], Coroutine[None, None, None]],
    ) -&gt; None:
        &#34;&#34;&#34;
        Add a callback to be called when the job is shutting down.
        Optionally the callback can take a single argument, the shutdown reason.
        &#34;&#34;&#34;
        if callback.__code__.co_argcount &gt; 0:
            self._shutdown_callbacks.append(callback)  # type: ignore
        else:

            async def wrapper(_: str) -&gt; None:
                await callback()  # type: ignore

            self._shutdown_callbacks.append(wrapper)

    async def wait_for_participant(
        self,
        *,
        identity: str | None = None,
        kind: list[rtc.ParticipantKind.ValueType]
        | rtc.ParticipantKind.ValueType = DEFAULT_PARTICIPANT_KINDS,
    ) -&gt; rtc.RemoteParticipant:
        &#34;&#34;&#34;
        Returns a participant that matches the given identity. If identity is None, the first
        participant that joins the room will be returned.
        If the participant has already joined, the function will return immediately.
        &#34;&#34;&#34;
        return await wait_for_participant(self._room, identity=identity, kind=kind)

    async def connect(
        self,
        *,
        e2ee: rtc.E2EEOptions | None = None,
        auto_subscribe: AutoSubscribe = AutoSubscribe.SUBSCRIBE_ALL,
        rtc_config: rtc.RtcConfiguration | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Connect to the room. This method should be called only once.

        Args:
            e2ee: End-to-end encryption options. If provided, the Agent will utilize end-to-end encryption. Note: clients will also need to handle E2EE.
            auto_subscribe: Whether to automatically subscribe to tracks. Default is AutoSubscribe.SUBSCRIBE_ALL.
            rtc_config: Custom RTC configuration to use when connecting to the room.
        &#34;&#34;&#34;  # noqa: E501
        room_options = rtc.RoomOptions(
            e2ee=e2ee,
            auto_subscribe=auto_subscribe == AutoSubscribe.SUBSCRIBE_ALL,
            rtc_config=rtc_config,
        )

        await self._room.connect(self._info.url, self._info.token, options=room_options)
        self._on_connect()
        for p in self._room.remote_participants.values():
            self._participant_available(p)

        _apply_auto_subscribe_opts(self._room, auto_subscribe)

    def delete_room(self) -&gt; asyncio.Future[api.DeleteRoomResponse]:
        &#34;&#34;&#34;Deletes the room and disconnects all participants.&#34;&#34;&#34;
        task = asyncio.create_task(
            self.api.room.delete_room(api.DeleteRoomRequest(room=self._room.name))
        )
        self._pending_tasks.append(task)
        task.add_done_callback(lambda _: self._pending_tasks.remove(task))
        return task

    def add_sip_participant(
        self,
        *,
        call_to: str,
        trunk_id: str,
        participant_identity: str,
        participant_name: str | NotGivenOr[str] = &#34;SIP-participant&#34;,
    ) -&gt; asyncio.Future[api.SIPParticipantInfo]:
        &#34;&#34;&#34;
        Add a SIP participant to the room.

        Args:
            call_to: The number or SIP destination to transfer the participant to.
                         This can either be a number (+12345555555) or a
                         sip host (sip:&lt;user&gt;@&lt;host&gt;)
            trunk_id: The ID of the SIP trunk to use
            participant_identity: The identity of the participant to add
            participant_name: The name of the participant to add

        Make sure you have an outbound SIP trunk created in LiveKit.
        See https://docs.livekit.io/sip/trunk-outbound/ for more information.
        &#34;&#34;&#34;
        task = asyncio.create_task(
            self.api.sip.create_sip_participant(
                api.CreateSIPParticipantRequest(
                    room_name=self._room.name,
                    participant_identity=participant_identity,
                    sip_trunk_id=trunk_id,
                    sip_call_to=call_to,
                    participant_name=participant_name,
                )
            ),
        )
        self._pending_tasks.append(task)
        task.add_done_callback(lambda _: self._pending_tasks.remove(task))
        return task

    def transfer_sip_participant(
        self,
        participant: rtc.RemoteParticipant | str,
        transfer_to: str,
        play_dialtone: bool = False,
    ) -&gt; asyncio.Future[api.SIPParticipantInfo]:
        &#34;&#34;&#34;Transfer a SIP participant to another number.

        Args:
            participant: The participant to transfer
            transfer_to: The number or SIP destination to transfer the participant to.
                         This can either be a number (+12345555555) or a
                         sip host (sip:&lt;user&gt;@&lt;host&gt;)
            play_dialtone: Whether to play a dialtone during transfer. Defaults to True.


        Returns:
            Future that completes when the transfer is complete

        Make sure you have enabled call transfer on your provider SIP trunk.
        See https://docs.livekit.io/sip/transfer-cold/ for more information.
        &#34;&#34;&#34;
        assert participant.kind == rtc.ParticipantKind.PARTICIPANT_KIND_SIP, (
            &#34;Participant must be a SIP participant&#34;
        )
        task = asyncio.create_task(
            self.api.sip.transfer_sip_participant(
                api.TransferSIPParticipantRequest(
                    room_name=self._room.name,
                    participant_identity=participant.identity,
                    transfer_to=transfer_to,
                    play_dialtone=play_dialtone,
                )
            ),
        )
        self._pending_tasks.append(task)
        task.add_done_callback(lambda _: self._pending_tasks.remove(task))
        return task

    def shutdown(self, reason: str = &#34;&#34;) -&gt; None:
        self._on_shutdown(reason)

    def add_participant_entrypoint(
        self,
        entrypoint_fnc: Callable[[JobContext, rtc.RemoteParticipant], Coroutine[None, None, None]],
        *_,
        kind: list[rtc.ParticipantKind.ValueType]
        | rtc.ParticipantKind.ValueType = DEFAULT_PARTICIPANT_KINDS,
    ):
        &#34;&#34;&#34;Adds an entrypoint function to be run when a participant joins the room. In cases where
        the participant has already joined, the entrypoint will be run immediately. Multiple unique entrypoints can be
        added and they will each be run in parallel for each participant.
        &#34;&#34;&#34;  # noqa: E501

        if entrypoint_fnc in [e for (e, _) in self._participant_entrypoints]:
            raise ValueError(&#34;entrypoints cannot be added more than once&#34;)

        self._participant_entrypoints.append((entrypoint_fnc, kind))

    def _participant_available(self, p: rtc.RemoteParticipant) -&gt; None:
        for coro, kind in self._participant_entrypoints:
            if isinstance(kind, list):
                if p.kind not in kind:
                    continue
            else:
                if p.kind != kind:
                    continue

            if (p.identity, coro) in self._participant_tasks:
                logger.warning(
                    f&#34;a participant has joined before a prior participant task matching the same identity has finished: &#39;{p.identity}&#39;&#34;  # noqa: E501
                )
            task_name = f&#34;part-entry-{p.identity}-{coro.__name__}&#34;
            task = asyncio.create_task(coro(self, p), name=task_name)
            self._participant_tasks[(p.identity, coro)] = task
            task.add_done_callback(
                lambda _, coro=coro: self._participant_tasks.pop((p.identity, coro))
            )</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.job.JobContext.agent"><code class="name">prop <span class="ident">agent</span> : rtc.LocalParticipant</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def agent(self) -&gt; rtc.LocalParticipant:
    return self._room.local_participant</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.job.JobContext.api"><code class="name">var <span class="ident">api</span> : api.LiveKitAPI</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@functools.cached_property
def api(self) -&gt; api.LiveKitAPI:
    return api.LiveKitAPI(session=http_context.http_session())</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.job.JobContext.inference_executor"><code class="name">prop <span class="ident">inference_executor</span> : InferenceExecutor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inference_executor(self) -&gt; InferenceExecutor:
    return self._inf_executor</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.job.JobContext.job"><code class="name">prop <span class="ident">job</span> : agent.Job</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def job(self) -&gt; agent.Job:
    &#34;&#34;&#34;Returns the current job that the worker is executing.&#34;&#34;&#34;
    return self._info.job</code></pre>
</details>
<div class="desc"><p>Returns the current job that the worker is executing.</p></div>
</dd>
<dt id="livekit.agents.job.JobContext.log_context_fields"><code class="name">prop <span class="ident">log_context_fields</span> : dict[str, Any]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def log_context_fields(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Returns the current dictionary of log fields that will be injected into log records.

    These fields enable enriched structured logging and can include job metadata,
    worker ID, trace IDs, or other diagnostic context.

    The returned dictionary can be directly edited, or entirely replaced via assignment
    (e.g., `job_context.log_context_fields = {...}`)
    &#34;&#34;&#34;
    return self._log_fields</code></pre>
</details>
<div class="desc"><p>Returns the current dictionary of log fields that will be injected into log records.</p>
<p>These fields enable enriched structured logging and can include job metadata,
worker ID, trace IDs, or other diagnostic context.</p>
<p>The returned dictionary can be directly edited, or entirely replaced via assignment
(e.g., <code>job_context.log_context_fields = {...}</code>)</p></div>
</dd>
<dt id="livekit.agents.job.JobContext.proc"><code class="name">prop <span class="ident">proc</span> : <a title="livekit.agents.job.JobProcess" href="#livekit.agents.job.JobProcess">JobProcess</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def proc(self) -&gt; JobProcess:
    &#34;&#34;&#34;Returns the process running the job. Useful for storing process-specific state.&#34;&#34;&#34;
    return self._proc</code></pre>
</details>
<div class="desc"><p>Returns the process running the job. Useful for storing process-specific state.</p></div>
</dd>
<dt id="livekit.agents.job.JobContext.room"><code class="name">prop <span class="ident">room</span> : rtc.Room</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def room(self) -&gt; rtc.Room:
    &#34;&#34;&#34;The Room object is the main interface that the worker should interact with.

    When the entrypoint is called, the worker has not connected to the Room yet.
    Certain properties of Room would not be available before calling JobContext.connect()
    &#34;&#34;&#34;
    return self._room</code></pre>
</details>
<div class="desc"><p>The Room object is the main interface that the worker should interact with.</p>
<p>When the entrypoint is called, the worker has not connected to the Room yet.
Certain properties of Room would not be available before calling JobContext.connect()</p></div>
</dd>
<dt id="livekit.agents.job.JobContext.worker_id"><code class="name">prop <span class="ident">worker_id</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def worker_id(self) -&gt; str:
    &#34;&#34;&#34;Returns the id of the worker.&#34;&#34;&#34;
    return self._info.worker_id</code></pre>
</details>
<div class="desc"><p>Returns the id of the worker.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.job.JobContext.add_participant_entrypoint"><code class="name flex">
<span>def <span class="ident">add_participant_entrypoint</span></span>(<span>self,<br>entrypoint_fnc: Callable[[<a title="livekit.agents.job.JobContext" href="#livekit.agents.job.JobContext">JobContext</a>, rtc.RemoteParticipant], Coroutine[None, None, None]],<br>*_,<br>kind: list[rtc.ParticipantKind.ValueType] | rtc.ParticipantKind.ValueType = [3, 0])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_participant_entrypoint(
    self,
    entrypoint_fnc: Callable[[JobContext, rtc.RemoteParticipant], Coroutine[None, None, None]],
    *_,
    kind: list[rtc.ParticipantKind.ValueType]
    | rtc.ParticipantKind.ValueType = DEFAULT_PARTICIPANT_KINDS,
):
    &#34;&#34;&#34;Adds an entrypoint function to be run when a participant joins the room. In cases where
    the participant has already joined, the entrypoint will be run immediately. Multiple unique entrypoints can be
    added and they will each be run in parallel for each participant.
    &#34;&#34;&#34;  # noqa: E501

    if entrypoint_fnc in [e for (e, _) in self._participant_entrypoints]:
        raise ValueError(&#34;entrypoints cannot be added more than once&#34;)

    self._participant_entrypoints.append((entrypoint_fnc, kind))</code></pre>
</details>
<div class="desc"><p>Adds an entrypoint function to be run when a participant joins the room. In cases where
the participant has already joined, the entrypoint will be run immediately. Multiple unique entrypoints can be
added and they will each be run in parallel for each participant.</p></div>
</dd>
<dt id="livekit.agents.job.JobContext.add_shutdown_callback"><code class="name flex">
<span>def <span class="ident">add_shutdown_callback</span></span>(<span>self,<br>callback: Callable[[], Coroutine[None, None, None]] | Callable[[str], Coroutine[None, None, None]]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_shutdown_callback(
    self,
    callback: Callable[[], Coroutine[None, None, None]]
    | Callable[[str], Coroutine[None, None, None]],
) -&gt; None:
    &#34;&#34;&#34;
    Add a callback to be called when the job is shutting down.
    Optionally the callback can take a single argument, the shutdown reason.
    &#34;&#34;&#34;
    if callback.__code__.co_argcount &gt; 0:
        self._shutdown_callbacks.append(callback)  # type: ignore
    else:

        async def wrapper(_: str) -&gt; None:
            await callback()  # type: ignore

        self._shutdown_callbacks.append(wrapper)</code></pre>
</details>
<div class="desc"><p>Add a callback to be called when the job is shutting down.
Optionally the callback can take a single argument, the shutdown reason.</p></div>
</dd>
<dt id="livekit.agents.job.JobContext.add_sip_participant"><code class="name flex">
<span>def <span class="ident">add_sip_participant</span></span>(<span>self,<br>*,<br>call_to: str,<br>trunk_id: str,<br>participant_identity: str,<br>participant_name: str | NotGivenOr[str] = 'SIP-participant') ‑> _asyncio.Future[sip.SIPParticipantInfo]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sip_participant(
    self,
    *,
    call_to: str,
    trunk_id: str,
    participant_identity: str,
    participant_name: str | NotGivenOr[str] = &#34;SIP-participant&#34;,
) -&gt; asyncio.Future[api.SIPParticipantInfo]:
    &#34;&#34;&#34;
    Add a SIP participant to the room.

    Args:
        call_to: The number or SIP destination to transfer the participant to.
                     This can either be a number (+12345555555) or a
                     sip host (sip:&lt;user&gt;@&lt;host&gt;)
        trunk_id: The ID of the SIP trunk to use
        participant_identity: The identity of the participant to add
        participant_name: The name of the participant to add

    Make sure you have an outbound SIP trunk created in LiveKit.
    See https://docs.livekit.io/sip/trunk-outbound/ for more information.
    &#34;&#34;&#34;
    task = asyncio.create_task(
        self.api.sip.create_sip_participant(
            api.CreateSIPParticipantRequest(
                room_name=self._room.name,
                participant_identity=participant_identity,
                sip_trunk_id=trunk_id,
                sip_call_to=call_to,
                participant_name=participant_name,
            )
        ),
    )
    self._pending_tasks.append(task)
    task.add_done_callback(lambda _: self._pending_tasks.remove(task))
    return task</code></pre>
</details>
<div class="desc"><p>Add a SIP participant to the room.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>call_to</code></strong></dt>
<dd>The number or SIP destination to transfer the participant to.
This can either be a number (+12345555555) or a
sip host (sip:<user>@<host>)</dd>
<dt><strong><code>trunk_id</code></strong></dt>
<dd>The ID of the SIP trunk to use</dd>
<dt><strong><code>participant_identity</code></strong></dt>
<dd>The identity of the participant to add</dd>
<dt><strong><code>participant_name</code></strong></dt>
<dd>The name of the participant to add</dd>
</dl>
<p>Make sure you have an outbound SIP trunk created in LiveKit.
See <a href="https://docs.livekit.io/sip/trunk-outbound/">https://docs.livekit.io/sip/trunk-outbound/</a> for more information.</p></div>
</dd>
<dt id="livekit.agents.job.JobContext.add_tracing_callback"><code class="name flex">
<span>def <span class="ident">add_tracing_callback</span></span>(<span>self, callback: Callable[[], Coroutine[None, None, None]]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_tracing_callback(
    self,
    callback: Callable[[], Coroutine[None, None, None]],
) -&gt; None:
    &#34;&#34;&#34;
    Add a callback to be called when the job is about to receive a new tracing request.
    &#34;&#34;&#34;
    self._tracing_callbacks.append(callback)</code></pre>
</details>
<div class="desc"><p>Add a callback to be called when the job is about to receive a new tracing request.</p></div>
</dd>
<dt id="livekit.agents.job.JobContext.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self,<br>*,<br>e2ee: rtc.E2EEOptions | None = None,<br>auto_subscribe: <a title="livekit.agents.job.AutoSubscribe" href="#livekit.agents.job.AutoSubscribe">AutoSubscribe</a> = AutoSubscribe.SUBSCRIBE_ALL,<br>rtc_config: rtc.RtcConfiguration | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(
    self,
    *,
    e2ee: rtc.E2EEOptions | None = None,
    auto_subscribe: AutoSubscribe = AutoSubscribe.SUBSCRIBE_ALL,
    rtc_config: rtc.RtcConfiguration | None = None,
) -&gt; None:
    &#34;&#34;&#34;Connect to the room. This method should be called only once.

    Args:
        e2ee: End-to-end encryption options. If provided, the Agent will utilize end-to-end encryption. Note: clients will also need to handle E2EE.
        auto_subscribe: Whether to automatically subscribe to tracks. Default is AutoSubscribe.SUBSCRIBE_ALL.
        rtc_config: Custom RTC configuration to use when connecting to the room.
    &#34;&#34;&#34;  # noqa: E501
    room_options = rtc.RoomOptions(
        e2ee=e2ee,
        auto_subscribe=auto_subscribe == AutoSubscribe.SUBSCRIBE_ALL,
        rtc_config=rtc_config,
    )

    await self._room.connect(self._info.url, self._info.token, options=room_options)
    self._on_connect()
    for p in self._room.remote_participants.values():
        self._participant_available(p)

    _apply_auto_subscribe_opts(self._room, auto_subscribe)</code></pre>
</details>
<div class="desc"><p>Connect to the room. This method should be called only once.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>e2ee</code></strong></dt>
<dd>End-to-end encryption options. If provided, the Agent will utilize end-to-end encryption. Note: clients will also need to handle E2EE.</dd>
<dt><strong><code>auto_subscribe</code></strong></dt>
<dd>Whether to automatically subscribe to tracks. Default is AutoSubscribe.SUBSCRIBE_ALL.</dd>
<dt><strong><code>rtc_config</code></strong></dt>
<dd>Custom RTC configuration to use when connecting to the room.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.job.JobContext.delete_room"><code class="name flex">
<span>def <span class="ident">delete_room</span></span>(<span>self) ‑> _asyncio.Future[room.DeleteRoomResponse]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_room(self) -&gt; asyncio.Future[api.DeleteRoomResponse]:
    &#34;&#34;&#34;Deletes the room and disconnects all participants.&#34;&#34;&#34;
    task = asyncio.create_task(
        self.api.room.delete_room(api.DeleteRoomRequest(room=self._room.name))
    )
    self._pending_tasks.append(task)
    task.add_done_callback(lambda _: self._pending_tasks.remove(task))
    return task</code></pre>
</details>
<div class="desc"><p>Deletes the room and disconnects all participants.</p></div>
</dd>
<dt id="livekit.agents.job.JobContext.shutdown"><code class="name flex">
<span>def <span class="ident">shutdown</span></span>(<span>self, reason: str = '') ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown(self, reason: str = &#34;&#34;) -&gt; None:
    self._on_shutdown(reason)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.job.JobContext.transfer_sip_participant"><code class="name flex">
<span>def <span class="ident">transfer_sip_participant</span></span>(<span>self,<br>participant: rtc.RemoteParticipant | str,<br>transfer_to: str,<br>play_dialtone: bool = False) ‑> _asyncio.Future[sip.SIPParticipantInfo]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer_sip_participant(
    self,
    participant: rtc.RemoteParticipant | str,
    transfer_to: str,
    play_dialtone: bool = False,
) -&gt; asyncio.Future[api.SIPParticipantInfo]:
    &#34;&#34;&#34;Transfer a SIP participant to another number.

    Args:
        participant: The participant to transfer
        transfer_to: The number or SIP destination to transfer the participant to.
                     This can either be a number (+12345555555) or a
                     sip host (sip:&lt;user&gt;@&lt;host&gt;)
        play_dialtone: Whether to play a dialtone during transfer. Defaults to True.


    Returns:
        Future that completes when the transfer is complete

    Make sure you have enabled call transfer on your provider SIP trunk.
    See https://docs.livekit.io/sip/transfer-cold/ for more information.
    &#34;&#34;&#34;
    assert participant.kind == rtc.ParticipantKind.PARTICIPANT_KIND_SIP, (
        &#34;Participant must be a SIP participant&#34;
    )
    task = asyncio.create_task(
        self.api.sip.transfer_sip_participant(
            api.TransferSIPParticipantRequest(
                room_name=self._room.name,
                participant_identity=participant.identity,
                transfer_to=transfer_to,
                play_dialtone=play_dialtone,
            )
        ),
    )
    self._pending_tasks.append(task)
    task.add_done_callback(lambda _: self._pending_tasks.remove(task))
    return task</code></pre>
</details>
<div class="desc"><p>Transfer a SIP participant to another number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>participant</code></strong></dt>
<dd>The participant to transfer</dd>
<dt><strong><code>transfer_to</code></strong></dt>
<dd>The number or SIP destination to transfer the participant to.
This can either be a number (+12345555555) or a
sip host (sip:<user>@<host>)</dd>
<dt><strong><code>play_dialtone</code></strong></dt>
<dd>Whether to play a dialtone during transfer. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Future that completes when the transfer is complete
Make sure you have enabled call transfer on your provider SIP trunk.
See <a href="https://docs.livekit.io/sip/transfer-cold/">https://docs.livekit.io/sip/transfer-cold/</a> for more information.</p></div>
</dd>
<dt id="livekit.agents.job.JobContext.wait_for_participant"><code class="name flex">
<span>async def <span class="ident">wait_for_participant</span></span>(<span>self,<br>*,<br>identity: str | None = None,<br>kind: list[rtc.ParticipantKind.ValueType] | rtc.ParticipantKind.ValueType = [3, 0]) ‑> <a title="livekit.rtc.participant.RemoteParticipant" href="../rtc/participant.html#livekit.rtc.participant.RemoteParticipant">RemoteParticipant</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_participant(
    self,
    *,
    identity: str | None = None,
    kind: list[rtc.ParticipantKind.ValueType]
    | rtc.ParticipantKind.ValueType = DEFAULT_PARTICIPANT_KINDS,
) -&gt; rtc.RemoteParticipant:
    &#34;&#34;&#34;
    Returns a participant that matches the given identity. If identity is None, the first
    participant that joins the room will be returned.
    If the participant has already joined, the function will return immediately.
    &#34;&#34;&#34;
    return await wait_for_participant(self._room, identity=identity, kind=kind)</code></pre>
</details>
<div class="desc"><p>Returns a participant that matches the given identity. If identity is None, the first
participant that joins the room will be returned.
If the participant has already joined, the function will return immediately.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.job.JobExecutorType"><code class="flex name class">
<span>class <span class="ident">JobExecutorType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@unique
class JobExecutorType(Enum):
    PROCESS = &#34;process&#34;
    THREAD = &#34;thread&#34;</code></pre>
</details>
<div class="desc"><p>Create a collection of name/value pairs.</p>
<p>Example enumeration:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     BLUE = 2
...     GREEN = 3
</code></pre>
<p>Access them by:</p>
<ul>
<li>attribute access:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color.RED
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>value lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color(1)
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>name lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color['RED']
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<p>Enumerations can be iterated over, and know how many members they have:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len(Color)
3
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</code></pre>
<p>Methods can be added to enumerations, and members can have their own
attributes &ndash; see the documentation for details.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.job.JobExecutorType.PROCESS"><code class="name">var <span class="ident">PROCESS</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.job.JobExecutorType.THREAD"><code class="name">var <span class="ident">THREAD</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.job.JobProcess"><code class="flex name class">
<span>class <span class="ident">JobProcess</span></span>
<span>(</span><span>*,<br>executor_type: <a title="livekit.agents.job.JobExecutorType" href="#livekit.agents.job.JobExecutorType">JobExecutorType</a>,<br>user_arguments: Any | None,<br>http_proxy: str | None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JobProcess:
    def __init__(
        self,
        *,
        executor_type: JobExecutorType,
        user_arguments: Any | None,
        http_proxy: str | None,
    ) -&gt; None:
        self._executor_type = executor_type
        self._mp_proc = mp.current_process()
        self._userdata: dict[str, Any] = {}
        self._user_arguments = user_arguments
        self._http_proxy: str | None = http_proxy

    @property
    def executor_type(self) -&gt; JobExecutorType:
        return self._executor_type

    @property
    def pid(self) -&gt; int | None:
        return self._mp_proc.pid

    @property
    def userdata(self) -&gt; dict:
        return self._userdata

    @property
    def user_arguments(self) -&gt; Any | None:
        return self._user_arguments

    @property
    def http_proxy(self) -&gt; str | None:
        return self._http_proxy</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.job.JobProcess.executor_type"><code class="name">prop <span class="ident">executor_type</span> : <a title="livekit.agents.job.JobExecutorType" href="#livekit.agents.job.JobExecutorType">JobExecutorType</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def executor_type(self) -&gt; JobExecutorType:
    return self._executor_type</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.job.JobProcess.http_proxy"><code class="name">prop <span class="ident">http_proxy</span> : str | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def http_proxy(self) -&gt; str | None:
    return self._http_proxy</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.job.JobProcess.pid"><code class="name">prop <span class="ident">pid</span> : int | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pid(self) -&gt; int | None:
    return self._mp_proc.pid</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.job.JobProcess.user_arguments"><code class="name">prop <span class="ident">user_arguments</span> : Any | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def user_arguments(self) -&gt; Any | None:
    return self._user_arguments</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.job.JobProcess.userdata"><code class="name">prop <span class="ident">userdata</span> : dict</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def userdata(self) -&gt; dict:
    return self._userdata</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.job.JobRequest"><code class="flex name class">
<span>class <span class="ident">JobRequest</span></span>
<span>(</span><span>*,<br>job: agent.Job,<br>on_reject: Callable[[], Coroutine[None, None, None]],<br>on_accept: Callable[[<a title="livekit.agents.job.JobAcceptArguments" href="#livekit.agents.job.JobAcceptArguments">JobAcceptArguments</a>], Coroutine[None, None, None]])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JobRequest:
    def __init__(
        self,
        *,
        job: agent.Job,
        on_reject: Callable[[], Coroutine[None, None, None]],
        on_accept: Callable[[JobAcceptArguments], Coroutine[None, None, None]],
    ) -&gt; None:
        self._job = job
        self._lock = asyncio.Lock()
        self._on_reject = on_reject
        self._on_accept = on_accept

    @property
    def id(self) -&gt; str:
        return self._job.id

    @property
    def job(self) -&gt; agent.Job:
        return self._job

    @property
    def room(self) -&gt; models.Room:
        return self._job.room

    @property
    def publisher(self) -&gt; models.ParticipantInfo | None:
        return self._job.participant

    @property
    def agent_name(self) -&gt; str:
        return self._job.agent_name

    async def reject(self) -&gt; None:
        &#34;&#34;&#34;Reject the job request. The job may be assigned to another worker&#34;&#34;&#34;
        await self._on_reject()

    async def accept(
        self,
        *,
        name: str = &#34;&#34;,
        identity: str = &#34;&#34;,
        metadata: str = &#34;&#34;,
        attributes: dict[str, str] | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Accept the job request, and start the job if the LiveKit SFU assigns the job to our worker.&#34;&#34;&#34;  # noqa: E501
        if not identity:
            identity = &#34;agent-&#34; + self.id

        accept_arguments = JobAcceptArguments(
            name=name,
            identity=identity,
            metadata=metadata,
            attributes=attributes,
        )

        await self._on_accept(accept_arguments)</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.job.JobRequest.agent_name"><code class="name">prop <span class="ident">agent_name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def agent_name(self) -&gt; str:
    return self._job.agent_name</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.job.JobRequest.id"><code class="name">prop <span class="ident">id</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self) -&gt; str:
    return self._job.id</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.job.JobRequest.job"><code class="name">prop <span class="ident">job</span> : agent.Job</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def job(self) -&gt; agent.Job:
    return self._job</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.job.JobRequest.publisher"><code class="name">prop <span class="ident">publisher</span> : models.ParticipantInfo | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def publisher(self) -&gt; models.ParticipantInfo | None:
    return self._job.participant</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.job.JobRequest.room"><code class="name">prop <span class="ident">room</span> : models.Room</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def room(self) -&gt; models.Room:
    return self._job.room</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.job.JobRequest.accept"><code class="name flex">
<span>async def <span class="ident">accept</span></span>(<span>self,<br>*,<br>name: str = '',<br>identity: str = '',<br>metadata: str = '',<br>attributes: dict[str, str] | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def accept(
    self,
    *,
    name: str = &#34;&#34;,
    identity: str = &#34;&#34;,
    metadata: str = &#34;&#34;,
    attributes: dict[str, str] | None = None,
) -&gt; None:
    &#34;&#34;&#34;Accept the job request, and start the job if the LiveKit SFU assigns the job to our worker.&#34;&#34;&#34;  # noqa: E501
    if not identity:
        identity = &#34;agent-&#34; + self.id

    accept_arguments = JobAcceptArguments(
        name=name,
        identity=identity,
        metadata=metadata,
        attributes=attributes,
    )

    await self._on_accept(accept_arguments)</code></pre>
</details>
<div class="desc"><p>Accept the job request, and start the job if the LiveKit SFU assigns the job to our worker.</p></div>
</dd>
<dt id="livekit.agents.job.JobRequest.reject"><code class="name flex">
<span>async def <span class="ident">reject</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def reject(self) -&gt; None:
    &#34;&#34;&#34;Reject the job request. The job may be assigned to another worker&#34;&#34;&#34;
    await self._on_reject()</code></pre>
</details>
<div class="desc"><p>Reject the job request. The job may be assigned to another worker</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.job.RunningJobInfo"><code class="flex name class">
<span>class <span class="ident">RunningJobInfo</span></span>
<span>(</span><span>accept_arguments: <a title="livekit.agents.job.JobAcceptArguments" href="#livekit.agents.job.JobAcceptArguments">JobAcceptArguments</a>,<br>job: agent.Job,<br>url: str,<br>token: str,<br>worker_id: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RunningJobInfo:
    accept_arguments: JobAcceptArguments
    job: agent.Job
    url: str
    token: str
    worker_id: str</code></pre>
</details>
<div class="desc"><p>RunningJobInfo(accept_arguments: 'JobAcceptArguments', job: 'agent.Job', url: 'str', token: 'str', worker_id: 'str')</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.job.RunningJobInfo.accept_arguments"><code class="name">var <span class="ident">accept_arguments</span> : <a title="livekit.agents.job.JobAcceptArguments" href="#livekit.agents.job.JobAcceptArguments">JobAcceptArguments</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.job.RunningJobInfo.job"><code class="name">var <span class="ident">job</span> : agent.Job</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.job.RunningJobInfo.token"><code class="name">var <span class="ident">token</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.job.RunningJobInfo.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.job.RunningJobInfo.worker_id"><code class="name">var <span class="ident">worker_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="livekit.agents" href="index.html">livekit.agents</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="livekit.agents.job.get_current_job_context" href="#livekit.agents.job.get_current_job_context">get_current_job_context</a></code></li>
<li><code><a title="livekit.agents.job.get_job_context" href="#livekit.agents.job.get_job_context">get_job_context</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="livekit.agents.job.AutoSubscribe" href="#livekit.agents.job.AutoSubscribe">AutoSubscribe</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.job.AutoSubscribe.AUDIO_ONLY" href="#livekit.agents.job.AutoSubscribe.AUDIO_ONLY">AUDIO_ONLY</a></code></li>
<li><code><a title="livekit.agents.job.AutoSubscribe.SUBSCRIBE_ALL" href="#livekit.agents.job.AutoSubscribe.SUBSCRIBE_ALL">SUBSCRIBE_ALL</a></code></li>
<li><code><a title="livekit.agents.job.AutoSubscribe.SUBSCRIBE_NONE" href="#livekit.agents.job.AutoSubscribe.SUBSCRIBE_NONE">SUBSCRIBE_NONE</a></code></li>
<li><code><a title="livekit.agents.job.AutoSubscribe.VIDEO_ONLY" href="#livekit.agents.job.AutoSubscribe.VIDEO_ONLY">VIDEO_ONLY</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.job.JobAcceptArguments" href="#livekit.agents.job.JobAcceptArguments">JobAcceptArguments</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.job.JobAcceptArguments.attributes" href="#livekit.agents.job.JobAcceptArguments.attributes">attributes</a></code></li>
<li><code><a title="livekit.agents.job.JobAcceptArguments.identity" href="#livekit.agents.job.JobAcceptArguments.identity">identity</a></code></li>
<li><code><a title="livekit.agents.job.JobAcceptArguments.metadata" href="#livekit.agents.job.JobAcceptArguments.metadata">metadata</a></code></li>
<li><code><a title="livekit.agents.job.JobAcceptArguments.name" href="#livekit.agents.job.JobAcceptArguments.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.job.JobContext" href="#livekit.agents.job.JobContext">JobContext</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.job.JobContext.add_participant_entrypoint" href="#livekit.agents.job.JobContext.add_participant_entrypoint">add_participant_entrypoint</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.add_shutdown_callback" href="#livekit.agents.job.JobContext.add_shutdown_callback">add_shutdown_callback</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.add_sip_participant" href="#livekit.agents.job.JobContext.add_sip_participant">add_sip_participant</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.add_tracing_callback" href="#livekit.agents.job.JobContext.add_tracing_callback">add_tracing_callback</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.agent" href="#livekit.agents.job.JobContext.agent">agent</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.api" href="#livekit.agents.job.JobContext.api">api</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.connect" href="#livekit.agents.job.JobContext.connect">connect</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.delete_room" href="#livekit.agents.job.JobContext.delete_room">delete_room</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.inference_executor" href="#livekit.agents.job.JobContext.inference_executor">inference_executor</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.job" href="#livekit.agents.job.JobContext.job">job</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.log_context_fields" href="#livekit.agents.job.JobContext.log_context_fields">log_context_fields</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.proc" href="#livekit.agents.job.JobContext.proc">proc</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.room" href="#livekit.agents.job.JobContext.room">room</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.shutdown" href="#livekit.agents.job.JobContext.shutdown">shutdown</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.transfer_sip_participant" href="#livekit.agents.job.JobContext.transfer_sip_participant">transfer_sip_participant</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.wait_for_participant" href="#livekit.agents.job.JobContext.wait_for_participant">wait_for_participant</a></code></li>
<li><code><a title="livekit.agents.job.JobContext.worker_id" href="#livekit.agents.job.JobContext.worker_id">worker_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.job.JobExecutorType" href="#livekit.agents.job.JobExecutorType">JobExecutorType</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.job.JobExecutorType.PROCESS" href="#livekit.agents.job.JobExecutorType.PROCESS">PROCESS</a></code></li>
<li><code><a title="livekit.agents.job.JobExecutorType.THREAD" href="#livekit.agents.job.JobExecutorType.THREAD">THREAD</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.job.JobProcess" href="#livekit.agents.job.JobProcess">JobProcess</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.job.JobProcess.executor_type" href="#livekit.agents.job.JobProcess.executor_type">executor_type</a></code></li>
<li><code><a title="livekit.agents.job.JobProcess.http_proxy" href="#livekit.agents.job.JobProcess.http_proxy">http_proxy</a></code></li>
<li><code><a title="livekit.agents.job.JobProcess.pid" href="#livekit.agents.job.JobProcess.pid">pid</a></code></li>
<li><code><a title="livekit.agents.job.JobProcess.user_arguments" href="#livekit.agents.job.JobProcess.user_arguments">user_arguments</a></code></li>
<li><code><a title="livekit.agents.job.JobProcess.userdata" href="#livekit.agents.job.JobProcess.userdata">userdata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.job.JobRequest" href="#livekit.agents.job.JobRequest">JobRequest</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.job.JobRequest.accept" href="#livekit.agents.job.JobRequest.accept">accept</a></code></li>
<li><code><a title="livekit.agents.job.JobRequest.agent_name" href="#livekit.agents.job.JobRequest.agent_name">agent_name</a></code></li>
<li><code><a title="livekit.agents.job.JobRequest.id" href="#livekit.agents.job.JobRequest.id">id</a></code></li>
<li><code><a title="livekit.agents.job.JobRequest.job" href="#livekit.agents.job.JobRequest.job">job</a></code></li>
<li><code><a title="livekit.agents.job.JobRequest.publisher" href="#livekit.agents.job.JobRequest.publisher">publisher</a></code></li>
<li><code><a title="livekit.agents.job.JobRequest.reject" href="#livekit.agents.job.JobRequest.reject">reject</a></code></li>
<li><code><a title="livekit.agents.job.JobRequest.room" href="#livekit.agents.job.JobRequest.room">room</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.job.RunningJobInfo" href="#livekit.agents.job.RunningJobInfo">RunningJobInfo</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.job.RunningJobInfo.accept_arguments" href="#livekit.agents.job.RunningJobInfo.accept_arguments">accept_arguments</a></code></li>
<li><code><a title="livekit.agents.job.RunningJobInfo.job" href="#livekit.agents.job.RunningJobInfo.job">job</a></code></li>
<li><code><a title="livekit.agents.job.RunningJobInfo.token" href="#livekit.agents.job.RunningJobInfo.token">token</a></code></li>
<li><code><a title="livekit.agents.job.RunningJobInfo.url" href="#livekit.agents.job.RunningJobInfo.url">url</a></code></li>
<li><code><a title="livekit.agents.job.RunningJobInfo.worker_id" href="#livekit.agents.job.RunningJobInfo.worker_id">worker_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
