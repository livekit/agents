<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>livekit.agents API documentation</title>
<meta name="description" content="LiveKit Agents for Python …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>livekit.agents</code></h1>
</header>
<section id="section-intro">
<p>LiveKit Agents for Python</p>
<p>See <a href="https://docs.livekit.io/agents/">https://docs.livekit.io/agents/</a> for quickstarts, documentation, and examples.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="livekit.agents.cli" href="cli/index.html">livekit.agents.cli</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.debug" href="debug/index.html">livekit.agents.debug</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.http_server" href="http_server.html">livekit.agents.http_server</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.inference_runner" href="inference_runner.html">livekit.agents.inference_runner</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.ipc" href="ipc/index.html">livekit.agents.ipc</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.job" href="job.html">livekit.agents.job</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.jupyter" href="jupyter.html">livekit.agents.jupyter</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.llm" href="llm/index.html">livekit.agents.llm</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.log" href="log.html">livekit.agents.log</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.metrics" href="metrics/index.html">livekit.agents.metrics</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.plugin" href="plugin.html">livekit.agents.plugin</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.resources" href="resources/index.html">livekit.agents.resources</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.stt" href="stt/index.html">livekit.agents.stt</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.tokenize" href="tokenize/index.html">livekit.agents.tokenize</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.tts" href="tts/index.html">livekit.agents.tts</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.types" href="types.html">livekit.agents.types</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.utils" href="utils/index.html">livekit.agents.utils</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.vad" href="vad.html">livekit.agents.vad</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.version" href="version.html">livekit.agents.version</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.voice" href="voice/index.html">livekit.agents.voice</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.worker" href="worker.html">livekit.agents.worker</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="livekit.agents.function_tool"><code class="name flex">
<span>def <span class="ident">function_tool</span></span>(<span>f: F | Raw_F | None = None,<br>*,<br>name: str | None = None,<br>description: str | None = None,<br>raw_schema: RawFunctionDescription | dict | None = None) ‑> <a title="livekit.agents.llm.tool_context.FunctionTool" href="llm/tool_context.html#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.tool_context.RawFunctionTool" href="llm/tool_context.html#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a> | Callable[[~F | ~Raw_F], <a title="livekit.agents.llm.tool_context.FunctionTool" href="llm/tool_context.html#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.tool_context.RawFunctionTool" href="llm/tool_context.html#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_tool(
    f: F | Raw_F | None = None,
    *,
    name: str | None = None,
    description: str | None = None,
    raw_schema: RawFunctionDescription | dict | None = None,
) -&gt; FunctionTool | RawFunctionTool | Callable[[F | Raw_F], FunctionTool | RawFunctionTool]:
    def deco(func: F | Raw_F) -&gt; RawFunctionTool | FunctionTool:
        if raw_schema is not None:
            if not raw_schema.get(&#34;name&#34;) or not raw_schema.get(&#34;parameters&#34;):
                raise ValueError(&#34;raw function description must contain a name and parameters key&#34;)

            info = _RawFunctionToolInfo(raw_schema={**raw_schema}, name=raw_schema[&#34;name&#34;])
            setattr(func, &#34;__livekit_raw_tool_info&#34;, info)
            return cast(RawFunctionTool, func)
        else:
            from docstring_parser import parse_from_object

            docstring = parse_from_object(func)
            info = _FunctionToolInfo(
                name=name or func.__name__,
                description=description or docstring.description,
            )
            setattr(func, &#34;__livekit_tool_info&#34;, info)
            return cast(FunctionTool, func)

    if f is not None:
        return deco(f)

    return deco</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.get_job_context"><code class="name flex">
<span>def <span class="ident">get_job_context</span></span>(<span>) ‑> <a title="livekit.agents.job.JobContext" href="job.html#livekit.agents.job.JobContext">JobContext</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_job_context() -&gt; JobContext:
    ctx = _JobContextVar.get(None)
    if ctx is None:
        raise RuntimeError(
            &#34;no job context found, are you running this code inside a job entrypoint?&#34;
        )

    return ctx</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="livekit.agents.APIConnectOptions"><code class="flex name class">
<span>class <span class="ident">APIConnectOptions</span></span>
<span>(</span><span>max_retry: int = 3, retry_interval: float = 2.0, timeout: float = 10.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class APIConnectOptions:
    max_retry: int = 3
    &#34;&#34;&#34;
    Maximum number of retries to connect to the API.
    &#34;&#34;&#34;

    retry_interval: float = 2.0
    &#34;&#34;&#34;
    Interval between retries to connect to the API in seconds.
    &#34;&#34;&#34;

    timeout: float = 10.0
    &#34;&#34;&#34;
    Timeout for connecting to the API in seconds.
    &#34;&#34;&#34;

    def __post_init__(self):
        if self.max_retry &lt; 0:
            raise ValueError(&#34;max_retry must be greater than or equal to 0&#34;)

        if self.retry_interval &lt; 0:
            raise ValueError(&#34;retry_interval must be greater than or equal to 0&#34;)

        if self.timeout &lt; 0:
            raise ValueError(&#34;timeout must be greater than or equal to 0&#34;)

    def _interval_for_retry(self, num_retries: int) -&gt; float:
        &#34;&#34;&#34;
        Return the interval for the given number of retries.

        The first retry is immediate, and then uses specified retry_interval
        &#34;&#34;&#34;
        if num_retries == 0:
            return 0.1
        return self.retry_interval</code></pre>
</details>
<div class="desc"><p>APIConnectOptions(max_retry: int = 3, retry_interval: float = 2.0, timeout: float = 10.0)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.APIConnectOptions.max_retry"><code class="name">var <span class="ident">max_retry</span> : int</code></dt>
<dd>
<div class="desc"><p>Maximum number of retries to connect to the API.</p></div>
</dd>
<dt id="livekit.agents.APIConnectOptions.retry_interval"><code class="name">var <span class="ident">retry_interval</span> : float</code></dt>
<dd>
<div class="desc"><p>Interval between retries to connect to the API in seconds.</p></div>
</dd>
<dt id="livekit.agents.APIConnectOptions.timeout"><code class="name">var <span class="ident">timeout</span> : float</code></dt>
<dd>
<div class="desc"><p>Timeout for connecting to the API in seconds.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.APIConnectionError"><code class="flex name class">
<span>class <span class="ident">APIConnectionError</span></span>
<span>(</span><span>message: str = 'Connection error.', *, retryable: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class APIConnectionError(APIError):
    &#34;&#34;&#34;Raised when an API request failed due to a connection error.&#34;&#34;&#34;

    def __init__(self, message: str = &#34;Connection error.&#34;, *, retryable: bool = True) -&gt; None:
        super().__init__(message, body=None, retryable=retryable)</code></pre>
</details>
<div class="desc"><p>Raised when an API request failed due to a connection error.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>livekit.agents._exceptions.APIError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>livekit.agents._exceptions.APITimeoutError</li>
</ul>
</dd>
<dt id="livekit.agents.APIError"><code class="flex name class">
<span>class <span class="ident">APIError</span></span>
<span>(</span><span>message: str, *, body: object | None, retryable: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class APIError(Exception):
    &#34;&#34;&#34;Raised when an API request failed.
    This is used on our TTS/STT/LLM plugins.&#34;&#34;&#34;

    message: str
    &#34;&#34;&#34;
    The error message returned by the API.
    &#34;&#34;&#34;

    body: object | None
    &#34;&#34;&#34;The API response body, if available.


    If the API returned a valid json, the body will contains
    the decodede result.
    &#34;&#34;&#34;

    retryable: bool = False
    &#34;&#34;&#34;Whether the error can be retried.&#34;&#34;&#34;

    def __init__(self, message: str, *, body: object | None, retryable: bool = True) -&gt; None:
        super().__init__(message)

        self.message = message
        self.body = body
        self.retryable = retryable</code></pre>
</details>
<div class="desc"><p>Raised when an API request failed.
This is used on our TTS/STT/LLM plugins.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>livekit.agents._exceptions.APIConnectionError</li>
<li>livekit.agents._exceptions.APIStatusError</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.APIError.body"><code class="name">var <span class="ident">body</span> : object | None</code></dt>
<dd>
<div class="desc"><p>The API response body, if available.</p>
<p>If the API returned a valid json, the body will contains
the decodede result.</p></div>
</dd>
<dt id="livekit.agents.APIError.message"><code class="name">var <span class="ident">message</span> : str</code></dt>
<dd>
<div class="desc"><p>The error message returned by the API.</p></div>
</dd>
<dt id="livekit.agents.APIError.retryable"><code class="name">var <span class="ident">retryable</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether the error can be retried.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.APIStatusError"><code class="flex name class">
<span>class <span class="ident">APIStatusError</span></span>
<span>(</span><span>message: str,<br>*,<br>status_code: int = -1,<br>request_id: str | None = None,<br>body: object | None = None,<br>retryable: bool | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class APIStatusError(APIError):
    &#34;&#34;&#34;Raised when an API response has a status code of 4xx or 5xx.&#34;&#34;&#34;

    status_code: int
    &#34;&#34;&#34;The status code of the API response.&#34;&#34;&#34;

    request_id: str | None
    &#34;&#34;&#34;The request ID of the API response, if available.&#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        *,
        status_code: int = -1,
        request_id: str | None = None,
        body: object | None = None,
        retryable: bool | None = None,
    ) -&gt; None:
        if retryable is None:
            retryable = True
            # 4xx errors are not retryable
            if status_code &gt;= 400 and status_code &lt; 500:
                retryable = False

        super().__init__(message, body=body, retryable=retryable)

        self.status_code = status_code
        self.request_id = request_id

    def __str__(self):
        return (
            f&#34;{self.message} &#34;
            f&#34;(status_code={self.status_code}, request_id={self.request_id}, body={self.body})&#34;
        )</code></pre>
</details>
<div class="desc"><p>Raised when an API response has a status code of 4xx or 5xx.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>livekit.agents._exceptions.APIError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.APIStatusError.request_id"><code class="name">var <span class="ident">request_id</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The request ID of the API response, if available.</p></div>
</dd>
<dt id="livekit.agents.APIStatusError.status_code"><code class="name">var <span class="ident">status_code</span> : int</code></dt>
<dd>
<div class="desc"><p>The status code of the API response.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.APITimeoutError"><code class="flex name class">
<span>class <span class="ident">APITimeoutError</span></span>
<span>(</span><span>message: str = 'Request timed out.', *, retryable: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class APITimeoutError(APIConnectionError):
    &#34;&#34;&#34;Raised when an API request timed out.&#34;&#34;&#34;

    def __init__(self, message: str = &#34;Request timed out.&#34;, *, retryable: bool = True) -&gt; None:
        super().__init__(message, retryable=retryable)</code></pre>
</details>
<div class="desc"><p>Raised when an API request timed out.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>livekit.agents._exceptions.APIConnectionError</li>
<li>livekit.agents._exceptions.APIError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="livekit.agents.Agent"><code class="flex name class">
<span>class <span class="ident">Agent</span></span>
<span>(</span><span>*,<br>instructions: str,<br>chat_ctx: NotGivenOr[<a title="livekit.agents.llm.ChatContext" href="llm/index.html#livekit.agents.llm.ChatContext">ChatContext</a> | None] = NOT_GIVEN,<br>tools: list[<a title="livekit.agents.llm.FunctionTool" href="llm/index.html#livekit.agents.llm.FunctionTool">FunctionTool</a>] | None = None,<br>turn_detection: NotGivenOr[TurnDetectionMode | None] = NOT_GIVEN,<br>stt: NotGivenOr[<a title="livekit.agents.stt.STT" href="stt/index.html#livekit.agents.stt.STT">STT</a> | None] = NOT_GIVEN,<br>vad: NotGivenOr[<a title="livekit.agents.vad.VAD" href="vad.html#livekit.agents.vad.VAD">VAD</a> | None] = NOT_GIVEN,<br>llm: NotGivenOr[<a title="livekit.agents.llm.LLM" href="llm/index.html#livekit.agents.llm.LLM">LLM</a> | <a title="livekit.agents.llm.RealtimeModel" href="llm/index.html#livekit.agents.llm.RealtimeModel">RealtimeModel</a> | None] = NOT_GIVEN,<br>tts: NotGivenOr[<a title="livekit.agents.tts.TTS" href="tts/index.html#livekit.agents.tts.TTS">TTS</a> | None] = NOT_GIVEN,<br>allow_interruptions: NotGivenOr[bool] = NOT_GIVEN)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Agent:
    def __init__(
        self,
        *,
        instructions: str,
        chat_ctx: NotGivenOr[llm.ChatContext | None] = NOT_GIVEN,
        tools: list[llm.FunctionTool] | None = None,
        turn_detection: NotGivenOr[TurnDetectionMode | None] = NOT_GIVEN,
        stt: NotGivenOr[stt.STT | None] = NOT_GIVEN,
        vad: NotGivenOr[vad.VAD | None] = NOT_GIVEN,
        llm: NotGivenOr[llm.LLM | llm.RealtimeModel | None] = NOT_GIVEN,
        tts: NotGivenOr[tts.TTS | None] = NOT_GIVEN,
        allow_interruptions: NotGivenOr[bool] = NOT_GIVEN,
    ) -&gt; None:
        tools = tools or []
        self._instructions = instructions
        self._tools = tools.copy() + find_function_tools(self)
        self._chat_ctx = chat_ctx.copy(tools=self._tools) if chat_ctx else ChatContext.empty()
        self._turn_detection = turn_detection
        self._stt = stt
        self._llm = llm
        self._tts = tts
        self._vad = vad
        self._allow_interruptions = allow_interruptions
        self._activity: AgentActivity | None = None

    @property
    def instructions(self) -&gt; str:
        &#34;&#34;&#34;
        Returns:
            str: The core instructions that guide the agent&#39;s behavior.
        &#34;&#34;&#34;
        return self._instructions

    @property
    def tools(self) -&gt; list[llm.FunctionTool]:
        &#34;&#34;&#34;
        Returns:
            list[llm.FunctionTool]: A list of function tools available to the agent.
        &#34;&#34;&#34;
        return self._tools.copy()

    @property
    def chat_ctx(self) -&gt; llm.ChatContext:
        &#34;&#34;&#34;
        Provides a read-only view of the agent&#39;s current chat context.

        Returns:
            llm.ChatContext: A read-only version of the agent&#39;s conversation history.

        See Also:
            update_chat_ctx: Method to update the internal chat context.
        &#34;&#34;&#34;
        return _ReadOnlyChatContext(self._chat_ctx.items)

    async def update_instructions(self, instructions: str) -&gt; None:
        &#34;&#34;&#34;
        Updates the agent&#39;s instructions.

        If the agent is running in realtime mode, this method also updates
        the instructions for the ongoing realtime session.

        Args:
            instructions (str):
                The new instructions to set for the agent.

        Raises:
            llm.RealtimeError: If updating the realtime session instructions fails.
        &#34;&#34;&#34;
        if self._activity is None:
            self._instructions = instructions
            return

        await self._activity.update_instructions(instructions)

    async def update_tools(self, tools: list[llm.FunctionTool]) -&gt; None:
        &#34;&#34;&#34;
        Updates the agent&#39;s available function tools.

        If the agent is running in realtime mode, this method also updates
        the tools for the ongoing realtime session.

        Args:
            tools (list[llm.FunctionTool]):
                The new list of function tools available to the agent.

        Raises:
            llm.RealtimeError: If updating the realtime session tools fails.
        &#34;&#34;&#34;
        if self._activity is None:
            self._tools = list(set(tools))
            self._chat_ctx = self._chat_ctx.copy(tools=self._tools)
            return

        await self._activity.update_tools(tools)

    async def update_chat_ctx(self, chat_ctx: llm.ChatContext) -&gt; None:
        &#34;&#34;&#34;
        Updates the agent&#39;s chat context.

        If the agent is running in realtime mode, this method also updates
        the chat context for the ongoing realtime session.

        Args:
            chat_ctx (llm.ChatContext):
                The new or updated chat context for the agent.

        Raises:
            llm.RealtimeError: If updating the realtime session chat context fails.
        &#34;&#34;&#34;
        if self._activity is None:
            self._chat_ctx = chat_ctx.copy(tools=self._tools)
            return

        await self._activity.update_chat_ctx(chat_ctx)

    @property
    def turn_detection(self) -&gt; NotGivenOr[TurnDetectionMode | None]:
        &#34;&#34;&#34;
        Retrieves the turn detection mode for identifying conversational turns.

        If this property was not set at Agent creation, but an ``AgentSession`` provides a turn detection,
        the session&#39;s turn detection mode will be used at runtime instead.

        Returns:
            NotGivenOr[TurnDetectionMode | None]: An optional turn detection mode for managing conversation flow.
        &#34;&#34;&#34;  # noqa: E501
        return self._turn_detection

    @property
    def stt(self) -&gt; NotGivenOr[stt.STT | None]:
        &#34;&#34;&#34;
        Retrieves the Speech-To-Text component for the agent.

        If this property was not set at Agent creation, but an ``AgentSession`` provides an STT component,
        the session&#39;s STT will be used at runtime instead.

        Returns:
            NotGivenOr[stt.STT | None]: An optional STT component.
        &#34;&#34;&#34;  # noqa: E501
        return self._stt

    @property
    def llm(self) -&gt; NotGivenOr[llm.LLM | llm.RealtimeModel | None]:
        &#34;&#34;&#34;
        Retrieves the Language Model or RealtimeModel used for text generation.

        If this property was not set at Agent creation, but an ``AgentSession`` provides an LLM or RealtimeModel,
        the session&#39;s model will be used at runtime instead.

        Returns:
            NotGivenOr[llm.LLM | llm.RealtimeModel | None]: The language model for text generation.
        &#34;&#34;&#34;  # noqa: E501
        return self._llm

    @property
    def tts(self) -&gt; NotGivenOr[tts.TTS | None]:
        &#34;&#34;&#34;
        Retrieves the Text-To-Speech component for the agent.

        If this property was not set at Agent creation, but an ``AgentSession`` provides a TTS component,
        the session&#39;s TTS will be used at runtime instead.

        Returns:
            NotGivenOr[tts.TTS | None]: An optional TTS component for generating audio output.
        &#34;&#34;&#34;  # noqa: E501
        return self._tts

    @property
    def vad(self) -&gt; NotGivenOr[vad.VAD | None]:
        &#34;&#34;&#34;
        Retrieves the Voice Activity Detection component for the agent.

        If this property was not set at Agent creation, but an ``AgentSession`` provides a VAD component,
        the session&#39;s VAD will be used at runtime instead.

        Returns:
            NotGivenOr[vad.VAD | None]: An optional VAD component for detecting voice activity.
        &#34;&#34;&#34;  # noqa: E501
        return self._vad

    @property
    def allow_interruptions(self) -&gt; NotGivenOr[bool]:
        &#34;&#34;&#34;
        Indicates whether interruptions (e.g., stopping TTS playback) are allowed.

        If this property was not set at Agent creation, but an ``AgentSession`` provides a value for
        allowing interruptions, the session&#39;s value will be used at runtime instead.

        Returns:
            NotGivenOr[bool]: Whether interruptions are permitted.
        &#34;&#34;&#34;
        return self._allow_interruptions

    @property
    def realtime_llm_session(self) -&gt; llm.RealtimeSession:
        &#34;&#34;&#34;
        Retrieve the realtime LLM session associated with the current agent.

        Raises:
            RuntimeError: If the agent is not running or the realtime LLM session is not available
        &#34;&#34;&#34;
        if (rt_session := self._get_activity_or_raise().realtime_llm_session) is None:
            raise RuntimeError(&#34;no realtime LLM session&#34;)

        return rt_session

    @property
    def session(self) -&gt; AgentSession:
        &#34;&#34;&#34;
        Retrieve the VoiceAgent associated with the current agent.

        Raises:
            RuntimeError: If the agent is not running
        &#34;&#34;&#34;
        return self._get_activity_or_raise().session

    # -- Pipeline nodes --
    # They can all be overriden by subclasses, by default they use the STT/LLM/TTS specified in the
    # constructor of the VoiceAgent

    async def on_enter(self) -&gt; None:
        &#34;&#34;&#34;Called when the task is entered&#34;&#34;&#34;
        pass

    async def on_exit(self) -&gt; None:
        &#34;&#34;&#34;Called when the task is exited&#34;&#34;&#34;
        pass

    async def on_user_turn_completed(
        self, turn_ctx: llm.ChatContext, new_message: llm.ChatMessage
    ) -&gt; None:
        &#34;&#34;&#34;Called when the user has finished speaking, and the LLM is about to respond

        This is a good opportunity to update the chat context or edit the new message before it is
        sent to the LLM.
        &#34;&#34;&#34;
        pass

    def stt_node(
        self, audio: AsyncIterable[rtc.AudioFrame], model_settings: ModelSettings
    ) -&gt; (
        AsyncIterable[stt.SpeechEvent | str]
        | Coroutine[Any, Any, AsyncIterable[stt.SpeechEvent | str]]
        | Coroutine[Any, Any, None]
    ):
        &#34;&#34;&#34;
        A node in the processing pipeline that transcribes audio frames into speech events.

        By default, this node uses a Speech-To-Text (STT) capability from the current agent.
        If the STT implementation does not support streaming natively, a VAD (Voice Activity
        Detection) mechanism is required to wrap the STT.

        You can override this node with your own implementation for more flexibility (e.g.,
        custom pre-processing of audio, additional buffering, or alternative STT strategies).

        Args:
            audio (AsyncIterable[rtc.AudioFrame]): An asynchronous stream of audio frames.
            model_settings (ModelSettings): Configuration and parameters for model execution.

        Yields:
            stt.SpeechEvent: An event containing transcribed text or other STT-related data.
        &#34;&#34;&#34;
        return Agent.default.stt_node(self, audio, model_settings)

    def llm_node(
        self,
        chat_ctx: llm.ChatContext,
        tools: list[FunctionTool],
        model_settings: ModelSettings,
    ) -&gt; (
        AsyncIterable[llm.ChatChunk | str]
        | Coroutine[Any, Any, AsyncIterable[llm.ChatChunk | str]]
        | Coroutine[Any, Any, str]
        | Coroutine[Any, Any, llm.ChatChunk]
        | Coroutine[Any, Any, None]
    ):
        &#34;&#34;&#34;
        A node in the processing pipeline that processes text generation with an LLM.

        By default, this node uses the agent&#39;s LLM to process the provided context. It may yield
        plain text (as `str`) for straightforward text generation, or `llm.ChatChunk` objects that
        can include text and optional tool calls. `ChatChunk` is helpful for capturing more complex
        outputs such as function calls, usage statistics, or other metadata.

        You can override this node to customize how the LLM is used or how tool invocations
        and responses are handled.

        Args:
            chat_ctx (llm.ChatContext): The context for the LLM (the conversation history).
            tools (list[FunctionTool]): A list of callable tools that the LLM may invoke.
            model_settings (ModelSettings): Configuration and parameters for model execution.

        Yields/Returns:
            str: Plain text output from the LLM.
            llm.ChatChunk: An object that can contain both text and optional tool calls.
        &#34;&#34;&#34;
        return Agent.default.llm_node(self, chat_ctx, tools, model_settings)

    def transcription_node(
        self, text: AsyncIterable[str], model_settings: ModelSettings
    ) -&gt; AsyncIterable[str] | Coroutine[Any, Any, AsyncIterable[str]] | Coroutine[Any, Any, None]:
        &#34;&#34;&#34;
        A node in the processing pipeline that finalizes transcriptions from text segments.

        This node can be used to adjust or post-process text coming from an LLM (or any other
        source) into a final transcribed form. For instance, you might clean up formatting, fix
        punctuation, or perform any other text transformations here.

        You can override this node to customize post-processing logic according to your needs.

        Args:
            text (AsyncIterable[str]): An asynchronous stream of text segments.
            model_settings (ModelSettings): Configuration and parameters for model execution.

        Yields:
            str: Finalized or post-processed text segments.
        &#34;&#34;&#34;
        return Agent.default.transcription_node(self, text, model_settings)

    def tts_node(
        self, text: AsyncIterable[str], model_settings: ModelSettings
    ) -&gt; (
        AsyncGenerator[rtc.AudioFrame, None]
        | Coroutine[Any, Any, AsyncIterable[rtc.AudioFrame]]
        | Coroutine[Any, Any, None]
    ):
        &#34;&#34;&#34;
        A node in the processing pipeline that synthesizes audio from text segments.

        By default, this node converts incoming text into audio frames using the Text-To-Speech
        from the agent.
        If the TTS implementation does not support streaming natively, it uses a sentence tokenizer
        to split text for incremental synthesis.

        You can override this node to provide different text chunking behavior, a custom TTS engine,
        or any other specialized processing.

        Args:
            text (AsyncIterable[str]): An asynchronous stream of text segments to be synthesized.
            model_settings (ModelSettings): Configuration and parameters for model execution.

        Yields:
            rtc.AudioFrame: Audio frames synthesized from the provided text.
        &#34;&#34;&#34;
        return Agent.default.tts_node(self, text, model_settings)

    def realtime_audio_output_node(
        self, audio: AsyncIterable[rtc.AudioFrame], model_settings: ModelSettings
    ) -&gt; (
        AsyncIterable[rtc.AudioFrame]
        | Coroutine[Any, Any, AsyncIterable[rtc.AudioFrame]]
        | Coroutine[Any, Any, None]
    ):
        &#34;&#34;&#34;A node processing the audio from the realtime LLM session before it is played out.&#34;&#34;&#34;
        return Agent.default.realtime_audio_output_node(self, audio, model_settings)

    def _get_activity_or_raise(self) -&gt; AgentActivity:
        &#34;&#34;&#34;Get the current activity context for this task (internal)&#34;&#34;&#34;
        if self._activity is None:
            raise RuntimeError(&#34;no activity context found, this task is not running&#34;)

        return self._activity

    class default:
        @staticmethod
        async def stt_node(
            agent: Agent, audio: AsyncIterable[rtc.AudioFrame], model_settings: ModelSettings
        ) -&gt; AsyncGenerator[stt.SpeechEvent, None]:
            &#34;&#34;&#34;Default implementation for `Agent.stt_node`&#34;&#34;&#34;
            activity = agent._get_activity_or_raise()
            assert activity.stt is not None, &#34;stt_node called but no STT node is available&#34;

            wrapped_stt = activity.stt

            if not activity.stt.capabilities.streaming:
                if not activity.vad:
                    raise RuntimeError(
                        f&#34;The STT ({activity.stt.label}) does not support streaming, add a VAD to the AgentTask/VoiceAgent to enable streaming&#34;  # noqa: E501
                        &#34;Or manually wrap your STT in a stt.StreamAdapter&#34;
                    )

                wrapped_stt = stt.StreamAdapter(stt=wrapped_stt, vad=activity.vad)

            async with wrapped_stt.stream() as stream:

                @utils.log_exceptions(logger=logger)
                async def _forward_input():
                    async for frame in audio:
                        stream.push_frame(frame)

                forward_task = asyncio.create_task(_forward_input())
                try:
                    async for event in stream:
                        yield event
                finally:
                    await utils.aio.cancel_and_wait(forward_task)

        @staticmethod
        async def llm_node(
            agent: Agent,
            chat_ctx: llm.ChatContext,
            tools: list[FunctionTool],
            model_settings: ModelSettings,
        ) -&gt; AsyncGenerator[llm.ChatChunk | str, None]:
            &#34;&#34;&#34;Default implementation for `Agent.llm_node`&#34;&#34;&#34;
            activity = agent._get_activity_or_raise()
            assert activity.llm is not None, &#34;llm_node called but no LLM node is available&#34;
            assert isinstance(activity.llm, llm.LLM), (
                &#34;llm_node should only be used with LLM (non-multimodal/realtime APIs) nodes&#34;
            )

            tool_choice = model_settings.tool_choice if model_settings else NOT_GIVEN
            activity_llm = activity.llm

            async with activity_llm.chat(
                chat_ctx=chat_ctx, tools=tools, tool_choice=tool_choice
            ) as stream:
                async for chunk in stream:
                    yield chunk

        @staticmethod
        async def tts_node(
            agent: Agent, text: AsyncIterable[str], model_settings: ModelSettings
        ) -&gt; AsyncGenerator[rtc.AudioFrame, None]:
            &#34;&#34;&#34;Default implementation for `Agent.tts_node`&#34;&#34;&#34;
            activity = agent._get_activity_or_raise()
            assert activity.tts is not None, &#34;tts_node called but no TTS node is available&#34;

            wrapped_tts = activity.tts

            if not activity.tts.capabilities.streaming:
                wrapped_tts = tts.StreamAdapter(
                    tts=wrapped_tts, sentence_tokenizer=tokenize.basic.SentenceTokenizer()
                )

            async with wrapped_tts.stream() as stream:

                async def _forward_input():
                    async for chunk in text:
                        stream.push_text(chunk)

                    stream.end_input()

                forward_task = asyncio.create_task(_forward_input())
                try:
                    async for ev in stream:
                        yield ev.frame
                finally:
                    await utils.aio.cancel_and_wait(forward_task)

        @staticmethod
        async def transcription_node(
            agent: Agent, text: AsyncIterable[str], model_settings: ModelSettings
        ) -&gt; AsyncGenerator[str, None]:
            &#34;&#34;&#34;Default implementation for `Agent.transcription_node`&#34;&#34;&#34;
            async for delta in text:
                yield delta

        @staticmethod
        async def realtime_audio_output_node(
            agent: Agent, audio: AsyncIterable[rtc.AudioFrame], model_settings: ModelSettings
        ) -&gt; AsyncGenerator[rtc.AudioFrame, None]:
            &#34;&#34;&#34;Default implementation for `Agent.realtime_audio_output_node`&#34;&#34;&#34;
            activity = agent._get_activity_or_raise()
            assert activity.realtime_llm_session is not None, (
                &#34;realtime_audio_output_node called but no realtime LLM session is available&#34;
            )

            async for frame in audio:
                yield frame</code></pre>
</details>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li>livekit.agents.voice.agent.InlineTask</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.Agent.default"><code class="name">var <span class="ident">default</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.Agent.allow_interruptions"><code class="name">prop <span class="ident">allow_interruptions</span> : NotGivenOr[bool]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def allow_interruptions(self) -&gt; NotGivenOr[bool]:
    &#34;&#34;&#34;
    Indicates whether interruptions (e.g., stopping TTS playback) are allowed.

    If this property was not set at Agent creation, but an ``AgentSession`` provides a value for
    allowing interruptions, the session&#39;s value will be used at runtime instead.

    Returns:
        NotGivenOr[bool]: Whether interruptions are permitted.
    &#34;&#34;&#34;
    return self._allow_interruptions</code></pre>
</details>
<div class="desc"><p>Indicates whether interruptions (e.g., stopping TTS playback) are allowed.</p>
<p>If this property was not set at Agent creation, but an <code><a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a></code> provides a value for
allowing interruptions, the session's value will be used at runtime instead.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NotGivenOr[bool]</code></dt>
<dd>Whether interruptions are permitted.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.chat_ctx"><code class="name">prop <span class="ident">chat_ctx</span> : <a title="livekit.agents.llm.ChatContext" href="llm/index.html#livekit.agents.llm.ChatContext">ChatContext</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def chat_ctx(self) -&gt; llm.ChatContext:
    &#34;&#34;&#34;
    Provides a read-only view of the agent&#39;s current chat context.

    Returns:
        llm.ChatContext: A read-only version of the agent&#39;s conversation history.

    See Also:
        update_chat_ctx: Method to update the internal chat context.
    &#34;&#34;&#34;
    return _ReadOnlyChatContext(self._chat_ctx.items)</code></pre>
</details>
<div class="desc"><p>Provides a read-only view of the agent's current chat context.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="livekit.agents.llm.ChatContext" href="llm/index.html#livekit.agents.llm.ChatContext">ChatContext</a></code></dt>
<dd>A read-only version of the agent's conversation history.</dd>
</dl>
<p>See Also:
update_chat_ctx: Method to update the internal chat context.</p></div>
</dd>
<dt id="livekit.agents.Agent.instructions"><code class="name">prop <span class="ident">instructions</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def instructions(self) -&gt; str:
    &#34;&#34;&#34;
    Returns:
        str: The core instructions that guide the agent&#39;s behavior.
    &#34;&#34;&#34;
    return self._instructions</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The core instructions that guide the agent's behavior.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.llm"><code class="name">prop <span class="ident">llm</span> : NotGivenOr[<a title="livekit.agents.llm.LLM" href="llm/index.html#livekit.agents.llm.LLM">LLM</a> | <a title="livekit.agents.llm.RealtimeModel" href="llm/index.html#livekit.agents.llm.RealtimeModel">RealtimeModel</a> | None]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def llm(self) -&gt; NotGivenOr[llm.LLM | llm.RealtimeModel | None]:
    &#34;&#34;&#34;
    Retrieves the Language Model or RealtimeModel used for text generation.

    If this property was not set at Agent creation, but an ``AgentSession`` provides an LLM or RealtimeModel,
    the session&#39;s model will be used at runtime instead.

    Returns:
        NotGivenOr[llm.LLM | llm.RealtimeModel | None]: The language model for text generation.
    &#34;&#34;&#34;  # noqa: E501
    return self._llm</code></pre>
</details>
<div class="desc"><p>Retrieves the Language Model or RealtimeModel used for text generation.</p>
<p>If this property was not set at Agent creation, but an <code><a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a></code> provides an LLM or RealtimeModel,
the session's model will be used at runtime instead.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NotGivenOr[llm.LLM | llm.RealtimeModel | None]</code></dt>
<dd>The language model for text generation.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.realtime_llm_session"><code class="name">prop <span class="ident">realtime_llm_session</span> : <a title="livekit.agents.llm.RealtimeSession" href="llm/index.html#livekit.agents.llm.RealtimeSession">RealtimeSession</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def realtime_llm_session(self) -&gt; llm.RealtimeSession:
    &#34;&#34;&#34;
    Retrieve the realtime LLM session associated with the current agent.

    Raises:
        RuntimeError: If the agent is not running or the realtime LLM session is not available
    &#34;&#34;&#34;
    if (rt_session := self._get_activity_or_raise().realtime_llm_session) is None:
        raise RuntimeError(&#34;no realtime LLM session&#34;)

    return rt_session</code></pre>
</details>
<div class="desc"><p>Retrieve the realtime LLM session associated with the current agent.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If the agent is not running or the realtime LLM session is not available</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.session"><code class="name">prop <span class="ident">session</span> : <a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def session(self) -&gt; AgentSession:
    &#34;&#34;&#34;
    Retrieve the VoiceAgent associated with the current agent.

    Raises:
        RuntimeError: If the agent is not running
    &#34;&#34;&#34;
    return self._get_activity_or_raise().session</code></pre>
</details>
<div class="desc"><p>Retrieve the VoiceAgent associated with the current agent.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If the agent is not running</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.stt"><code class="name">prop <span class="ident">stt</span> : NotGivenOr[<a title="livekit.agents.stt.STT" href="stt/index.html#livekit.agents.stt.STT">STT</a> | None]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stt(self) -&gt; NotGivenOr[stt.STT | None]:
    &#34;&#34;&#34;
    Retrieves the Speech-To-Text component for the agent.

    If this property was not set at Agent creation, but an ``AgentSession`` provides an STT component,
    the session&#39;s STT will be used at runtime instead.

    Returns:
        NotGivenOr[stt.STT | None]: An optional STT component.
    &#34;&#34;&#34;  # noqa: E501
    return self._stt</code></pre>
</details>
<div class="desc"><p>Retrieves the Speech-To-Text component for the agent.</p>
<p>If this property was not set at Agent creation, but an <code><a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a></code> provides an STT component,
the session's STT will be used at runtime instead.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NotGivenOr[stt.STT | None]</code></dt>
<dd>An optional STT component.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.tools"><code class="name">prop <span class="ident">tools</span> : list[<a title="livekit.agents.llm.FunctionTool" href="llm/index.html#livekit.agents.llm.FunctionTool">FunctionTool</a>]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tools(self) -&gt; list[llm.FunctionTool]:
    &#34;&#34;&#34;
    Returns:
        list[llm.FunctionTool]: A list of function tools available to the agent.
    &#34;&#34;&#34;
    return self._tools.copy()</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="livekit.agents.llm.FunctionTool" href="llm/index.html#livekit.agents.llm.FunctionTool">FunctionTool</a>]</code></dt>
<dd>A list of function tools available to the agent.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.tts"><code class="name">prop <span class="ident">tts</span> : NotGivenOr[<a title="livekit.agents.tts.TTS" href="tts/index.html#livekit.agents.tts.TTS">TTS</a> | None]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tts(self) -&gt; NotGivenOr[tts.TTS | None]:
    &#34;&#34;&#34;
    Retrieves the Text-To-Speech component for the agent.

    If this property was not set at Agent creation, but an ``AgentSession`` provides a TTS component,
    the session&#39;s TTS will be used at runtime instead.

    Returns:
        NotGivenOr[tts.TTS | None]: An optional TTS component for generating audio output.
    &#34;&#34;&#34;  # noqa: E501
    return self._tts</code></pre>
</details>
<div class="desc"><p>Retrieves the Text-To-Speech component for the agent.</p>
<p>If this property was not set at Agent creation, but an <code><a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a></code> provides a TTS component,
the session's TTS will be used at runtime instead.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NotGivenOr[tts.TTS | None]</code></dt>
<dd>An optional TTS component for generating audio output.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.turn_detection"><code class="name">prop <span class="ident">turn_detection</span> : NotGivenOr[TurnDetectionMode | None]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def turn_detection(self) -&gt; NotGivenOr[TurnDetectionMode | None]:
    &#34;&#34;&#34;
    Retrieves the turn detection mode for identifying conversational turns.

    If this property was not set at Agent creation, but an ``AgentSession`` provides a turn detection,
    the session&#39;s turn detection mode will be used at runtime instead.

    Returns:
        NotGivenOr[TurnDetectionMode | None]: An optional turn detection mode for managing conversation flow.
    &#34;&#34;&#34;  # noqa: E501
    return self._turn_detection</code></pre>
</details>
<div class="desc"><p>Retrieves the turn detection mode for identifying conversational turns.</p>
<p>If this property was not set at Agent creation, but an <code><a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a></code> provides a turn detection,
the session's turn detection mode will be used at runtime instead.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NotGivenOr[TurnDetectionMode | None]</code></dt>
<dd>An optional turn detection mode for managing conversation flow.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.vad"><code class="name">prop <span class="ident">vad</span> : NotGivenOr[<a title="livekit.agents.vad.VAD" href="vad.html#livekit.agents.vad.VAD">VAD</a> | None]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vad(self) -&gt; NotGivenOr[vad.VAD | None]:
    &#34;&#34;&#34;
    Retrieves the Voice Activity Detection component for the agent.

    If this property was not set at Agent creation, but an ``AgentSession`` provides a VAD component,
    the session&#39;s VAD will be used at runtime instead.

    Returns:
        NotGivenOr[vad.VAD | None]: An optional VAD component for detecting voice activity.
    &#34;&#34;&#34;  # noqa: E501
    return self._vad</code></pre>
</details>
<div class="desc"><p>Retrieves the Voice Activity Detection component for the agent.</p>
<p>If this property was not set at Agent creation, but an <code><a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a></code> provides a VAD component,
the session's VAD will be used at runtime instead.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NotGivenOr[vad.VAD | None]</code></dt>
<dd>An optional VAD component for detecting voice activity.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.Agent.llm_node"><code class="name flex">
<span>def <span class="ident">llm_node</span></span>(<span>self,<br>chat_ctx: <a title="livekit.agents.llm.ChatContext" href="llm/index.html#livekit.agents.llm.ChatContext">ChatContext</a>,<br>tools: list[<a title="livekit.agents.FunctionTool" href="#livekit.agents.FunctionTool">FunctionTool</a>],<br>model_settings: <a title="livekit.agents.ModelSettings" href="#livekit.agents.ModelSettings">ModelSettings</a>) ‑> collections.abc.AsyncIterable[<a title="livekit.agents.llm.llm.ChatChunk" href="llm/llm.html#livekit.agents.llm.llm.ChatChunk">ChatChunk</a> | str] | collections.abc.Coroutine[typing.Any, typing.Any, collections.abc.AsyncIterable[<a title="livekit.agents.llm.llm.ChatChunk" href="llm/llm.html#livekit.agents.llm.llm.ChatChunk">ChatChunk</a> | str]] | collections.abc.Coroutine[typing.Any, typing.Any, str] | collections.abc.Coroutine[typing.Any, typing.Any, <a title="livekit.agents.llm.llm.ChatChunk" href="llm/llm.html#livekit.agents.llm.llm.ChatChunk">ChatChunk</a>] | collections.abc.Coroutine[typing.Any, typing.Any, None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def llm_node(
    self,
    chat_ctx: llm.ChatContext,
    tools: list[FunctionTool],
    model_settings: ModelSettings,
) -&gt; (
    AsyncIterable[llm.ChatChunk | str]
    | Coroutine[Any, Any, AsyncIterable[llm.ChatChunk | str]]
    | Coroutine[Any, Any, str]
    | Coroutine[Any, Any, llm.ChatChunk]
    | Coroutine[Any, Any, None]
):
    &#34;&#34;&#34;
    A node in the processing pipeline that processes text generation with an LLM.

    By default, this node uses the agent&#39;s LLM to process the provided context. It may yield
    plain text (as `str`) for straightforward text generation, or `llm.ChatChunk` objects that
    can include text and optional tool calls. `ChatChunk` is helpful for capturing more complex
    outputs such as function calls, usage statistics, or other metadata.

    You can override this node to customize how the LLM is used or how tool invocations
    and responses are handled.

    Args:
        chat_ctx (llm.ChatContext): The context for the LLM (the conversation history).
        tools (list[FunctionTool]): A list of callable tools that the LLM may invoke.
        model_settings (ModelSettings): Configuration and parameters for model execution.

    Yields/Returns:
        str: Plain text output from the LLM.
        llm.ChatChunk: An object that can contain both text and optional tool calls.
    &#34;&#34;&#34;
    return Agent.default.llm_node(self, chat_ctx, tools, model_settings)</code></pre>
</details>
<div class="desc"><p>A node in the processing pipeline that processes text generation with an LLM.</p>
<p>By default, this node uses the agent's LLM to process the provided context. It may yield
plain text (as <code>str</code>) for straightforward text generation, or <code><a title="livekit.agents.llm.ChatChunk" href="llm/index.html#livekit.agents.llm.ChatChunk">ChatChunk</a></code> objects that
can include text and optional tool calls. <code>ChatChunk</code> is helpful for capturing more complex
outputs such as function calls, usage statistics, or other metadata.</p>
<p>You can override this node to customize how the LLM is used or how tool invocations
and responses are handled.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>chat_ctx</code></strong> :&ensp;<code><a title="livekit.agents.llm.ChatContext" href="llm/index.html#livekit.agents.llm.ChatContext">ChatContext</a></code></dt>
<dd>The context for the LLM (the conversation history).</dd>
<dt><strong><code>tools</code></strong> :&ensp;<code>list[<a title="livekit.agents.FunctionTool" href="#livekit.agents.FunctionTool">FunctionTool</a>]</code></dt>
<dd>A list of callable tools that the LLM may invoke.</dd>
<dt><strong><code>model_settings</code></strong> :&ensp;<code><a title="livekit.agents.ModelSettings" href="#livekit.agents.ModelSettings">ModelSettings</a></code></dt>
<dd>Configuration and parameters for model execution.</dd>
</dl>
<p>Yields/Returns:
str: Plain text output from the LLM.
llm.ChatChunk: An object that can contain both text and optional tool calls.</p></div>
</dd>
<dt id="livekit.agents.Agent.on_enter"><code class="name flex">
<span>async def <span class="ident">on_enter</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_enter(self) -&gt; None:
    &#34;&#34;&#34;Called when the task is entered&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Called when the task is entered</p></div>
</dd>
<dt id="livekit.agents.Agent.on_exit"><code class="name flex">
<span>async def <span class="ident">on_exit</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_exit(self) -&gt; None:
    &#34;&#34;&#34;Called when the task is exited&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Called when the task is exited</p></div>
</dd>
<dt id="livekit.agents.Agent.on_user_turn_completed"><code class="name flex">
<span>async def <span class="ident">on_user_turn_completed</span></span>(<span>self,<br>turn_ctx: <a title="livekit.agents.llm.ChatContext" href="llm/index.html#livekit.agents.llm.ChatContext">ChatContext</a>,<br>new_message: <a title="livekit.agents.llm.ChatMessage" href="llm/index.html#livekit.agents.llm.ChatMessage">ChatMessage</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_user_turn_completed(
    self, turn_ctx: llm.ChatContext, new_message: llm.ChatMessage
) -&gt; None:
    &#34;&#34;&#34;Called when the user has finished speaking, and the LLM is about to respond

    This is a good opportunity to update the chat context or edit the new message before it is
    sent to the LLM.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Called when the user has finished speaking, and the LLM is about to respond</p>
<p>This is a good opportunity to update the chat context or edit the new message before it is
sent to the LLM.</p></div>
</dd>
<dt id="livekit.agents.Agent.realtime_audio_output_node"><code class="name flex">
<span>def <span class="ident">realtime_audio_output_node</span></span>(<span>self,<br>audio: AsyncIterable[rtc.AudioFrame],<br>model_settings: <a title="livekit.agents.ModelSettings" href="#livekit.agents.ModelSettings">ModelSettings</a>) ‑> collections.abc.AsyncIterable[<a title="livekit.rtc.audio_frame.AudioFrame" href="../rtc/audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>] | collections.abc.Coroutine[typing.Any, typing.Any, collections.abc.AsyncIterable[<a title="livekit.rtc.audio_frame.AudioFrame" href="../rtc/audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>]] | collections.abc.Coroutine[typing.Any, typing.Any, None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def realtime_audio_output_node(
    self, audio: AsyncIterable[rtc.AudioFrame], model_settings: ModelSettings
) -&gt; (
    AsyncIterable[rtc.AudioFrame]
    | Coroutine[Any, Any, AsyncIterable[rtc.AudioFrame]]
    | Coroutine[Any, Any, None]
):
    &#34;&#34;&#34;A node processing the audio from the realtime LLM session before it is played out.&#34;&#34;&#34;
    return Agent.default.realtime_audio_output_node(self, audio, model_settings)</code></pre>
</details>
<div class="desc"><p>A node processing the audio from the realtime LLM session before it is played out.</p></div>
</dd>
<dt id="livekit.agents.Agent.stt_node"><code class="name flex">
<span>def <span class="ident">stt_node</span></span>(<span>self,<br>audio: AsyncIterable[rtc.AudioFrame],<br>model_settings: <a title="livekit.agents.ModelSettings" href="#livekit.agents.ModelSettings">ModelSettings</a>) ‑> collections.abc.AsyncIterable[<a title="livekit.agents.stt.stt.SpeechEvent" href="stt/stt.html#livekit.agents.stt.stt.SpeechEvent">SpeechEvent</a> | str] | collections.abc.Coroutine[typing.Any, typing.Any, collections.abc.AsyncIterable[<a title="livekit.agents.stt.stt.SpeechEvent" href="stt/stt.html#livekit.agents.stt.stt.SpeechEvent">SpeechEvent</a> | str]] | collections.abc.Coroutine[typing.Any, typing.Any, None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stt_node(
    self, audio: AsyncIterable[rtc.AudioFrame], model_settings: ModelSettings
) -&gt; (
    AsyncIterable[stt.SpeechEvent | str]
    | Coroutine[Any, Any, AsyncIterable[stt.SpeechEvent | str]]
    | Coroutine[Any, Any, None]
):
    &#34;&#34;&#34;
    A node in the processing pipeline that transcribes audio frames into speech events.

    By default, this node uses a Speech-To-Text (STT) capability from the current agent.
    If the STT implementation does not support streaming natively, a VAD (Voice Activity
    Detection) mechanism is required to wrap the STT.

    You can override this node with your own implementation for more flexibility (e.g.,
    custom pre-processing of audio, additional buffering, or alternative STT strategies).

    Args:
        audio (AsyncIterable[rtc.AudioFrame]): An asynchronous stream of audio frames.
        model_settings (ModelSettings): Configuration and parameters for model execution.

    Yields:
        stt.SpeechEvent: An event containing transcribed text or other STT-related data.
    &#34;&#34;&#34;
    return Agent.default.stt_node(self, audio, model_settings)</code></pre>
</details>
<div class="desc"><p>A node in the processing pipeline that transcribes audio frames into speech events.</p>
<p>By default, this node uses a Speech-To-Text (STT) capability from the current agent.
If the STT implementation does not support streaming natively, a VAD (Voice Activity
Detection) mechanism is required to wrap the STT.</p>
<p>You can override this node with your own implementation for more flexibility (e.g.,
custom pre-processing of audio, additional buffering, or alternative STT strategies).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>audio</code></strong> :&ensp;<code>AsyncIterable[rtc.AudioFrame]</code></dt>
<dd>An asynchronous stream of audio frames.</dd>
<dt><strong><code>model_settings</code></strong> :&ensp;<code><a title="livekit.agents.ModelSettings" href="#livekit.agents.ModelSettings">ModelSettings</a></code></dt>
<dd>Configuration and parameters for model execution.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code><a title="livekit.agents.stt.SpeechEvent" href="stt/index.html#livekit.agents.stt.SpeechEvent">SpeechEvent</a></code></dt>
<dd>An event containing transcribed text or other STT-related data.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.transcription_node"><code class="name flex">
<span>def <span class="ident">transcription_node</span></span>(<span>self,<br>text: AsyncIterable[str],<br>model_settings: <a title="livekit.agents.ModelSettings" href="#livekit.agents.ModelSettings">ModelSettings</a>) ‑> collections.abc.AsyncIterable[str] | collections.abc.Coroutine[typing.Any, typing.Any, collections.abc.AsyncIterable[str]] | collections.abc.Coroutine[typing.Any, typing.Any, None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transcription_node(
    self, text: AsyncIterable[str], model_settings: ModelSettings
) -&gt; AsyncIterable[str] | Coroutine[Any, Any, AsyncIterable[str]] | Coroutine[Any, Any, None]:
    &#34;&#34;&#34;
    A node in the processing pipeline that finalizes transcriptions from text segments.

    This node can be used to adjust or post-process text coming from an LLM (or any other
    source) into a final transcribed form. For instance, you might clean up formatting, fix
    punctuation, or perform any other text transformations here.

    You can override this node to customize post-processing logic according to your needs.

    Args:
        text (AsyncIterable[str]): An asynchronous stream of text segments.
        model_settings (ModelSettings): Configuration and parameters for model execution.

    Yields:
        str: Finalized or post-processed text segments.
    &#34;&#34;&#34;
    return Agent.default.transcription_node(self, text, model_settings)</code></pre>
</details>
<div class="desc"><p>A node in the processing pipeline that finalizes transcriptions from text segments.</p>
<p>This node can be used to adjust or post-process text coming from an LLM (or any other
source) into a final transcribed form. For instance, you might clean up formatting, fix
punctuation, or perform any other text transformations here.</p>
<p>You can override this node to customize post-processing logic according to your needs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>AsyncIterable[str]</code></dt>
<dd>An asynchronous stream of text segments.</dd>
<dt><strong><code>model_settings</code></strong> :&ensp;<code><a title="livekit.agents.ModelSettings" href="#livekit.agents.ModelSettings">ModelSettings</a></code></dt>
<dd>Configuration and parameters for model execution.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>str</code></dt>
<dd>Finalized or post-processed text segments.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.tts_node"><code class="name flex">
<span>def <span class="ident">tts_node</span></span>(<span>self,<br>text: AsyncIterable[str],<br>model_settings: <a title="livekit.agents.ModelSettings" href="#livekit.agents.ModelSettings">ModelSettings</a>) ‑> collections.abc.AsyncGenerator[<a title="livekit.rtc.audio_frame.AudioFrame" href="../rtc/audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>, None] | collections.abc.Coroutine[typing.Any, typing.Any, collections.abc.AsyncIterable[<a title="livekit.rtc.audio_frame.AudioFrame" href="../rtc/audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>]] | collections.abc.Coroutine[typing.Any, typing.Any, None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tts_node(
    self, text: AsyncIterable[str], model_settings: ModelSettings
) -&gt; (
    AsyncGenerator[rtc.AudioFrame, None]
    | Coroutine[Any, Any, AsyncIterable[rtc.AudioFrame]]
    | Coroutine[Any, Any, None]
):
    &#34;&#34;&#34;
    A node in the processing pipeline that synthesizes audio from text segments.

    By default, this node converts incoming text into audio frames using the Text-To-Speech
    from the agent.
    If the TTS implementation does not support streaming natively, it uses a sentence tokenizer
    to split text for incremental synthesis.

    You can override this node to provide different text chunking behavior, a custom TTS engine,
    or any other specialized processing.

    Args:
        text (AsyncIterable[str]): An asynchronous stream of text segments to be synthesized.
        model_settings (ModelSettings): Configuration and parameters for model execution.

    Yields:
        rtc.AudioFrame: Audio frames synthesized from the provided text.
    &#34;&#34;&#34;
    return Agent.default.tts_node(self, text, model_settings)</code></pre>
</details>
<div class="desc"><p>A node in the processing pipeline that synthesizes audio from text segments.</p>
<p>By default, this node converts incoming text into audio frames using the Text-To-Speech
from the agent.
If the TTS implementation does not support streaming natively, it uses a sentence tokenizer
to split text for incremental synthesis.</p>
<p>You can override this node to provide different text chunking behavior, a custom TTS engine,
or any other specialized processing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>AsyncIterable[str]</code></dt>
<dd>An asynchronous stream of text segments to be synthesized.</dd>
<dt><strong><code>model_settings</code></strong> :&ensp;<code><a title="livekit.agents.ModelSettings" href="#livekit.agents.ModelSettings">ModelSettings</a></code></dt>
<dd>Configuration and parameters for model execution.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>rtc.AudioFrame</code></dt>
<dd>Audio frames synthesized from the provided text.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.update_chat_ctx"><code class="name flex">
<span>async def <span class="ident">update_chat_ctx</span></span>(<span>self,<br>chat_ctx: <a title="livekit.agents.llm.ChatContext" href="llm/index.html#livekit.agents.llm.ChatContext">ChatContext</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_chat_ctx(self, chat_ctx: llm.ChatContext) -&gt; None:
    &#34;&#34;&#34;
    Updates the agent&#39;s chat context.

    If the agent is running in realtime mode, this method also updates
    the chat context for the ongoing realtime session.

    Args:
        chat_ctx (llm.ChatContext):
            The new or updated chat context for the agent.

    Raises:
        llm.RealtimeError: If updating the realtime session chat context fails.
    &#34;&#34;&#34;
    if self._activity is None:
        self._chat_ctx = chat_ctx.copy(tools=self._tools)
        return

    await self._activity.update_chat_ctx(chat_ctx)</code></pre>
</details>
<div class="desc"><p>Updates the agent's chat context.</p>
<p>If the agent is running in realtime mode, this method also updates
the chat context for the ongoing realtime session.</p>
<h2 id="args">Args</h2>
<p>chat_ctx (llm.ChatContext):
The new or updated chat context for the agent.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="livekit.agents.llm.RealtimeError" href="llm/index.html#livekit.agents.llm.RealtimeError">RealtimeError</a></code></dt>
<dd>If updating the realtime session chat context fails.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.update_instructions"><code class="name flex">
<span>async def <span class="ident">update_instructions</span></span>(<span>self, instructions: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_instructions(self, instructions: str) -&gt; None:
    &#34;&#34;&#34;
    Updates the agent&#39;s instructions.

    If the agent is running in realtime mode, this method also updates
    the instructions for the ongoing realtime session.

    Args:
        instructions (str):
            The new instructions to set for the agent.

    Raises:
        llm.RealtimeError: If updating the realtime session instructions fails.
    &#34;&#34;&#34;
    if self._activity is None:
        self._instructions = instructions
        return

    await self._activity.update_instructions(instructions)</code></pre>
</details>
<div class="desc"><p>Updates the agent's instructions.</p>
<p>If the agent is running in realtime mode, this method also updates
the instructions for the ongoing realtime session.</p>
<h2 id="args">Args</h2>
<p>instructions (str):
The new instructions to set for the agent.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="livekit.agents.llm.RealtimeError" href="llm/index.html#livekit.agents.llm.RealtimeError">RealtimeError</a></code></dt>
<dd>If updating the realtime session instructions fails.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.Agent.update_tools"><code class="name flex">
<span>async def <span class="ident">update_tools</span></span>(<span>self,<br>tools: list[<a title="livekit.agents.llm.FunctionTool" href="llm/index.html#livekit.agents.llm.FunctionTool">FunctionTool</a>]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_tools(self, tools: list[llm.FunctionTool]) -&gt; None:
    &#34;&#34;&#34;
    Updates the agent&#39;s available function tools.

    If the agent is running in realtime mode, this method also updates
    the tools for the ongoing realtime session.

    Args:
        tools (list[llm.FunctionTool]):
            The new list of function tools available to the agent.

    Raises:
        llm.RealtimeError: If updating the realtime session tools fails.
    &#34;&#34;&#34;
    if self._activity is None:
        self._tools = list(set(tools))
        self._chat_ctx = self._chat_ctx.copy(tools=self._tools)
        return

    await self._activity.update_tools(tools)</code></pre>
</details>
<div class="desc"><p>Updates the agent's available function tools.</p>
<p>If the agent is running in realtime mode, this method also updates
the tools for the ongoing realtime session.</p>
<h2 id="args">Args</h2>
<p>tools (list[llm.FunctionTool]):
The new list of function tools available to the agent.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="livekit.agents.llm.RealtimeError" href="llm/index.html#livekit.agents.llm.RealtimeError">RealtimeError</a></code></dt>
<dd>If updating the realtime session tools fails.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.AgentSession"><code class="flex name class">
<span>class <span class="ident">AgentSession</span></span>
<span>(</span><span>*,<br>turn_detection: NotGivenOr[TurnDetectionMode] = NOT_GIVEN,<br>stt: NotGivenOr[<a title="livekit.agents.stt.STT" href="stt/index.html#livekit.agents.stt.STT">STT</a>] = NOT_GIVEN,<br>vad: NotGivenOr[<a title="livekit.agents.vad.VAD" href="vad.html#livekit.agents.vad.VAD">VAD</a>] = NOT_GIVEN,<br>llm: NotGivenOr[<a title="livekit.agents.llm.LLM" href="llm/index.html#livekit.agents.llm.LLM">LLM</a> | <a title="livekit.agents.llm.RealtimeModel" href="llm/index.html#livekit.agents.llm.RealtimeModel">RealtimeModel</a>] = NOT_GIVEN,<br>tts: NotGivenOr[<a title="livekit.agents.tts.TTS" href="tts/index.html#livekit.agents.tts.TTS">TTS</a>] = NOT_GIVEN,<br>userdata: NotGivenOr[Userdata_T] = NOT_GIVEN,<br>allow_interruptions: bool = True,<br>discard_audio_if_uninterruptible: bool = True,<br>min_interruption_duration: float = 0.5,<br>min_endpointing_delay: float = 0.5,<br>max_endpointing_delay: float = 6.0,<br>max_tool_steps: int = 3,<br>video_sampler: NotGivenOr[_VideoSampler | None] = NOT_GIVEN,<br>loop: asyncio.AbstractEventLoop | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AgentSession(rtc.EventEmitter[EventTypes], Generic[Userdata_T]):
    def __init__(
        self,
        *,
        turn_detection: NotGivenOr[TurnDetectionMode] = NOT_GIVEN,
        stt: NotGivenOr[stt.STT] = NOT_GIVEN,
        vad: NotGivenOr[vad.VAD] = NOT_GIVEN,
        llm: NotGivenOr[llm.LLM | llm.RealtimeModel] = NOT_GIVEN,
        tts: NotGivenOr[tts.TTS] = NOT_GIVEN,
        userdata: NotGivenOr[Userdata_T] = NOT_GIVEN,
        allow_interruptions: bool = True,
        discard_audio_if_uninterruptible: bool = True,
        min_interruption_duration: float = 0.5,
        min_endpointing_delay: float = 0.5,
        max_endpointing_delay: float = 6.0,
        max_tool_steps: int = 3,
        video_sampler: NotGivenOr[_VideoSampler | None] = NOT_GIVEN,
        loop: asyncio.AbstractEventLoop | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;`AgentSession` is the LiveKit Agents runtime that glues together
        media streams, speech/LLM components, and tool orchestration into a
        single real-time voice agent.

        It links audio, video, and text I/O with STT, VAD, TTS, and the LLM;
        handles turn detection, endpointing, interruptions, and multi-step
        tool calls; and exposes everything through event callbacks so you can
        focus on writing function tools and simple hand-offs rather than
        low-level streaming logic.

        Args:
            turn_detection (TurnDetectionMode, optional): Strategy for deciding
                when the user has finished speaking.

                * ``&#34;stt&#34;`` – rely on speech-to-text end-of-utterance cues
                * ``&#34;vad&#34;`` – rely on Voice Activity Detection start/stop cues
                * ``&#34;realtime_llm&#34;`` – use server-side detection from a
                  realtime LLM
                * ``&#34;manual&#34;`` – caller controls turn boundaries explicitly
                * ``_TurnDetector`` instance – plug-in custom detector

                If *NOT_GIVEN*, the session chooses the best available mode in
                priority order ``realtime_llm → vad → stt → manual``; it
                automatically falls back if the necessary model is missing.
            stt (stt.STT, optional): Speech-to-text backend.
            vad (vad.VAD, optional): Voice-activity detector
            llm (llm.LLM | llm.RealtimeModel, optional): LLM or RealtimeModel
            tts (tts.TTS, optional): Text-to-speech engine.
            userdata (Userdata_T, optional): Arbitrary per-session user data.
            allow_interruptions (bool): Whether the user can interrupt the
                agent mid-utterance. Default ``True``.
            discard_audio_if_uninterruptible (bool): When ``True``, buffered
                audio is dropped while the agent is speaking and cannot be
                interrupted. Default ``True``.
            min_interruption_duration (float): Minimum speech length (s) to
                register as an interruption. Default ``0.5`` s.
            min_endpointing_delay (float): Minimum time-in-seconds the agent
                must wait after a potential end-of-utterance signal (from VAD
                or an EOU model) before it declares the user’s turn complete.
                Default ``0.5`` s.
            max_endpointing_delay (float): Maximum time-in-seconds the agent
                will wait before terminating the turn. Default ``6.0`` s.
            max_tool_steps (int): Maximum consecutive tool calls per LLM turn.
                Default ``3``.
            video_sampler (_VideoSampler, optional): Uses
                :class:`VoiceActivityVideoSampler` when *NOT_GIVEN*; that sampler
                captures video at ~1 fps while the user is speaking and ~0.3 fps
                when silent by default.
            loop (asyncio.AbstractEventLoop, optional): Event loop to bind the
                session to. Falls back to :pyfunc:`asyncio.get_event_loop()`.
        &#34;&#34;&#34;
        super().__init__()
        self._loop = loop or asyncio.get_event_loop()

        if not is_given(video_sampler):
            video_sampler = VoiceActivityVideoSampler(speaking_fps=1.0, silent_fps=0.3)

        self._video_sampler = video_sampler

        # This is the &#34;global&#34; chat_context, it holds the entire conversation history
        self._chat_ctx = ChatContext.empty()
        self._opts = VoiceOptions(
            allow_interruptions=allow_interruptions,
            discard_audio_if_uninterruptible=discard_audio_if_uninterruptible,
            min_interruption_duration=min_interruption_duration,
            min_endpointing_delay=min_endpointing_delay,
            max_endpointing_delay=max_endpointing_delay,
            max_tool_steps=max_tool_steps,
        )
        self._started = False
        self._turn_detection = turn_detection or None
        self._stt = stt or None
        self._vad = vad or None
        self._llm = llm or None
        self._tts = tts or None

        # configurable IO
        self._input = io.AgentInput(self._on_video_input_changed, self._on_audio_input_changed)
        self._output = io.AgentOutput(
            self._on_video_output_changed,
            self._on_audio_output_changed,
            self._on_text_output_changed,
        )

        self._forward_audio_atask: asyncio.Task | None = None
        self._update_activity_atask: asyncio.Task | None = None
        self._activity_lock = asyncio.Lock()
        self._lock = asyncio.Lock()

        # used to keep a reference to the room io
        # this is not exposed, if users want access to it, they can create their own RoomIO
        self._room_io: room_io.RoomIO | None = None

        self._agent: Agent | None = None
        self._activity: AgentActivity | None = None
        self._user_state: UserState = &#34;listening&#34;
        self._agent_state: AgentState = &#34;initializing&#34;

        self._userdata: Userdata_T | None = userdata if is_given(userdata) else None
        self._closing_task: asyncio.Task | None = None

    @property
    def userdata(self) -&gt; Userdata_T:
        if self._userdata is None:
            raise ValueError(&#34;VoiceAgent userdata is not set&#34;)

        return self._userdata

    @userdata.setter
    def userdata(self, value: Userdata_T) -&gt; None:
        self._userdata = value

    @property
    def turn_detection(self) -&gt; TurnDetectionMode | None:
        return self._turn_detection

    @property
    def stt(self) -&gt; stt.STT | None:
        return self._stt

    @property
    def llm(self) -&gt; llm.LLM | llm.RealtimeModel | None:
        return self._llm

    @property
    def tts(self) -&gt; tts.TTS | None:
        return self._tts

    @property
    def vad(self) -&gt; vad.VAD | None:
        return self._vad

    @property
    def input(self) -&gt; io.AgentInput:
        return self._input

    @property
    def output(self) -&gt; io.AgentOutput:
        return self._output

    @property
    def options(self) -&gt; VoiceOptions:
        return self._opts

    @property
    def history(self) -&gt; llm.ChatContext:
        return self._chat_ctx

    @property
    def current_speech(self) -&gt; SpeechHandle | None:
        return self._activity.current_speech if self._activity is not None else None

    @property
    def user_state(self) -&gt; UserState:
        return self._user_state

    @property
    def agent_state(self) -&gt; AgentState:
        return self._agent_state

    @property
    def current_agent(self) -&gt; Agent:
        if self._agent is None:
            raise RuntimeError(&#34;VoiceAgent isn&#39;t running&#34;)

        return self._agent

    async def start(
        self,
        agent: Agent,
        *,
        room: NotGivenOr[rtc.Room] = NOT_GIVEN,
        room_input_options: NotGivenOr[room_io.RoomInputOptions] = NOT_GIVEN,
        room_output_options: NotGivenOr[room_io.RoomOutputOptions] = NOT_GIVEN,
    ) -&gt; None:
        &#34;&#34;&#34;Start the voice agent.

        Create a default RoomIO if the input or output audio is not already set.
        If the console flag is provided, start a ChatCLI.

        Args:
            room: The room to use for input and output
            room_input_options: Options for the room input
            room_output_options: Options for the room output
        &#34;&#34;&#34;
        async with self._lock:
            if self._started:
                return

            self._agent = agent
            self._update_agent_state(&#34;initializing&#34;)

            if cli.CLI_ARGUMENTS is not None and cli.CLI_ARGUMENTS.console:
                from .chat_cli import ChatCLI

                if (
                    self.input.audio is not None
                    or self.output.audio is not None
                    or self.output.transcription is not None
                ):
                    logger.warning(
                        &#34;agent started with the console subcommand, but input.audio or output.audio &#34;  # noqa: E501
                        &#34;or output.transcription is already set, overriding..&#34;
                    )

                chat_cli = ChatCLI(self)
                await chat_cli.start()

            elif is_given(room) and not self._room_io:
                room_input_options = copy.copy(
                    room_input_options or room_io.DEFAULT_ROOM_INPUT_OPTIONS
                )
                room_output_options = copy.copy(
                    room_output_options or room_io.DEFAULT_ROOM_OUTPUT_OPTIONS
                )

                if self.input.audio is not None and room_input_options.audio_enabled:
                    logger.warning(
                        &#34;RoomIO audio input is enabled but input.audio is already set, ignoring..&#34;
                    )
                    room_input_options.audio_enabled = False

                if self.output.audio is not None and room_output_options.audio_enabled:
                    logger.warning(
                        &#34;RoomIO audio output is enabled but output.audio is already set, ignoring..&#34;
                    )
                    room_output_options.audio_enabled = False

                if (
                    self.output.transcription is not None
                    and room_output_options.transcription_enabled
                ):
                    logger.warning(
                        &#34;RoomIO transcription output is enabled but output.transcription is already set, ignoring..&#34;  # noqa: E501
                    )
                    room_output_options.transcription_enabled = False

                self._room_io = room_io.RoomIO(
                    room=room,
                    agent_session=self,
                    input_options=room_input_options,
                    output_options=room_output_options,
                )
                await self._room_io.start()

            else:
                if not self._room_io and not self.output.audio and not self.output.transcription:
                    logger.warning(
                        &#34;session starts without output, forgetting to pass `room` to `AgentSession.start()`?&#34;  # noqa: E501
                    )

            try:
                job_ctx = get_job_context()
                job_ctx.add_tracing_callback(self._trace_chat_ctx)
            except RuntimeError:
                pass  # ignore

            # it is ok to await it directly, there is no previous task to drain
            await self._update_activity_task(self._agent)

            # important: no await should be done after this!

            if self.input.audio is not None:
                self._forward_audio_atask = asyncio.create_task(
                    self._forward_audio_task(), name=&#34;_forward_audio_task&#34;
                )

            if self.input.video is not None:
                self._forward_video_atask = asyncio.create_task(
                    self._forward_video_task(), name=&#34;_forward_video_task&#34;
                )

            self._started = True
            self._update_agent_state(&#34;listening&#34;)

    async def _trace_chat_ctx(self) -&gt; None:
        if self._activity is None:
            return  # can happen at startup

        chat_ctx = self._activity.agent.chat_ctx
        debug.Tracing.store_kv(&#34;chat_ctx&#34;, chat_ctx.to_dict(exclude_function_call=False))
        debug.Tracing.store_kv(&#34;history&#34;, self.history.to_dict(exclude_function_call=False))

    async def drain(self) -&gt; None:
        if self._activity is None:
            raise RuntimeError(&#34;AgentSession isn&#39;t running&#34;)

        await self._activity.drain()

    async def _aclose_impl(
        self,
        *,
        error: llm.LLMError | stt.STTError | tts.TTSError | None = None,
    ) -&gt; None:
        async with self._lock:
            if not self._started:
                return

            self.emit(&#34;close&#34;, CloseEvent(error=error))

            if self._activity is not None:
                await self._activity.aclose()

            if self._forward_audio_atask is not None:
                await utils.aio.cancel_and_wait(self._forward_audio_atask)

            if self._room_io:
                await self._room_io.aclose()

    async def aclose(self) -&gt; None:
        await self._aclose_impl()

    def emit(self, event: EventTypes, ev: AgentEvent) -&gt; None:  # type: ignore
        # don&#39;t log VAD metrics as they are too verbose
        if ev.type != &#34;metrics_collected&#34; or ev.metrics.type != &#34;vad_metrics&#34;:
            debug.Tracing.log_event(f&#39;agent.on(&#34;{event}&#34;)&#39;, ev.model_dump())

        return super().emit(event, ev)

    def update_options(self) -&gt; None:
        pass

    def say(
        self,
        text: str | AsyncIterable[str],
        *,
        audio: NotGivenOr[AsyncIterable[rtc.AudioFrame]] = NOT_GIVEN,
        allow_interruptions: NotGivenOr[bool] = NOT_GIVEN,
        add_to_chat_ctx: bool = True,
    ) -&gt; SpeechHandle:
        if self._activity is None:
            raise RuntimeError(&#34;AgentSession isn&#39;t running&#34;)

        if self._activity.draining:
            if self._next_activity is None:
                raise RuntimeError(&#34;AgentSession is closing, cannot use say()&#34;)

            return self._next_activity.say(
                text,
                audio=audio,
                allow_interruptions=allow_interruptions,
                add_to_chat_ctx=add_to_chat_ctx,
            )

        return self._activity.say(
            text,
            audio=audio,
            allow_interruptions=allow_interruptions,
            add_to_chat_ctx=add_to_chat_ctx,
        )

    def generate_reply(
        self,
        *,
        user_input: NotGivenOr[str] = NOT_GIVEN,
        instructions: NotGivenOr[str] = NOT_GIVEN,
        tool_choice: NotGivenOr[llm.ToolChoice] = NOT_GIVEN,
        allow_interruptions: NotGivenOr[bool] = NOT_GIVEN,
    ) -&gt; SpeechHandle:
        &#34;&#34;&#34;Generate a reply for the agent to speak to the user.

        Args:
            user_input (NotGivenOr[str], optional): The user&#39;s input that may influence the reply,
                such as answering a question.
            instructions (NotGivenOr[str], optional): Additional instructions for generating the reply.
            tool_choice (NotGivenOr[llm.ToolChoice], optional): Specifies the external tool to use when
                generating the reply. If generate_reply is invoked within a function_tool, defaults to &#34;none&#34;.
            allow_interruptions (NotGivenOr[bool], optional): Indicates whether the user can interrupt this speech.

        Returns:
            SpeechHandle: A handle to the generated reply.
        &#34;&#34;&#34;  # noqa: E501
        if self._activity is None:
            raise RuntimeError(&#34;AgentSession isn&#39;t running&#34;)

        user_message = (
            llm.ChatMessage(role=&#34;user&#34;, content=[user_input])
            if is_given(user_input)
            else NOT_GIVEN
        )

        if self._activity.draining:
            if self._next_activity is None:
                raise RuntimeError(&#34;AgentSession is closing, cannot use generate_reply()&#34;)

            return self._next_activity._generate_reply(
                user_message=user_message,
                instructions=instructions,
                tool_choice=tool_choice,
                allow_interruptions=allow_interruptions,
            )

        return self._activity._generate_reply(
            user_message=user_message,
            instructions=instructions,
            tool_choice=tool_choice,
            allow_interruptions=allow_interruptions,
        )

    def interrupt(self) -&gt; asyncio.Future:
        &#34;&#34;&#34;Interrupt the current speech generation.

        Returns:
            An asyncio.Future that completes when the interruption is fully processed
            and chat context has been updated.

        Example:
            ```python
            await session.interrupt()
            ```
        &#34;&#34;&#34;
        if self._activity is None:
            raise RuntimeError(&#34;AgentSession isn&#39;t running&#34;)

        return self._activity.interrupt()

    def clear_user_turn(self) -&gt; None:
        # clear the transcription or input audio buffer of the user turn
        if self._activity is None:
            raise RuntimeError(&#34;AgentSession isn&#39;t running&#34;)

        self._activity.clear_user_turn()

    def commit_user_turn(self) -&gt; None:
        # commit the user turn and generate a reply
        if self._activity is None:
            raise RuntimeError(&#34;AgentSession isn&#39;t running&#34;)

        self._activity.commit_user_turn()

    def update_agent(self, agent: Agent) -&gt; None:
        self._agent = agent

        if self._started:
            self._update_activity_atask = asyncio.create_task(
                self._update_activity_task(self._agent), name=&#34;_update_activity_task&#34;
            )

    def _on_error(
        self,
        error: llm.LLMError | stt.STTError | tts.TTSError | llm.RealtimeModelError,
    ) -&gt; None:
        if self._closing_task or error.recoverable:
            return

        async def drain_and_close() -&gt; None:
            await self.drain()
            await self._aclose_impl(error=error)

        def on_close_done(_: asyncio.Task) -&gt; None:
            self._closing_task = None

        self._closing_task = asyncio.create_task(drain_and_close())
        self._closing_task.add_done_callback(on_close_done)

    @utils.log_exceptions(logger=logger)
    async def _update_activity_task(self, task: Agent) -&gt; None:
        async with self._activity_lock:
            self._next_activity = AgentActivity(task, self)

            if self._activity is not None:
                await self._activity.drain()
                await self._activity.aclose()

            self._activity = self._next_activity
            self._next_activity = None
            await self._activity.start()

    @utils.log_exceptions(logger=logger)
    async def _forward_audio_task(self) -&gt; None:
        audio_input = self.input.audio
        if audio_input is None:
            return

        async for frame in audio_input:
            if self._activity is not None:
                self._activity.push_audio(frame)

    @utils.log_exceptions(logger=logger)
    async def _forward_video_task(self) -&gt; None:
        video_input = self.input.video
        if video_input is None:
            return

        async for frame in video_input:
            if self._activity is not None:
                if self._video_sampler is not None and not self._video_sampler(frame, self):
                    continue  # ignore this frame

                self._activity.push_video(frame)

    def _update_agent_state(self, state: AgentState) -&gt; None:
        if self._agent_state == state:
            return

        old_state = self._agent_state
        self._agent_state = state
        self.emit(
            &#34;agent_state_changed&#34;, AgentStateChangedEvent(old_state=old_state, new_state=state)
        )

    def _update_user_state(self, state: UserState) -&gt; None:
        if self._user_state == state:
            return

        old_state = self._user_state
        self._user_state = state
        self.emit(&#34;user_state_changed&#34;, UserStateChangedEvent(old_state=old_state, new_state=state))

    def _conversation_item_added(self, message: llm.ChatMessage) -&gt; None:
        self._chat_ctx.items.append(message)
        self.emit(&#34;conversation_item_added&#34;, ConversationItemAddedEvent(item=message))

    # -- User changed input/output streams/sinks --

    def _on_video_input_changed(self) -&gt; None:
        if not self._started:
            return

        if self._forward_video_atask is not None:
            self._forward_video_atask.cancel()

        self._forward_video_atask = asyncio.create_task(
            self._forward_video_task(), name=&#34;_forward_video_task&#34;
        )

    def _on_audio_input_changed(self) -&gt; None:
        if not self._started:
            return

        if self._forward_audio_atask is not None:
            self._forward_audio_atask.cancel()

        self._forward_audio_atask = asyncio.create_task(
            self._forward_audio_task(), name=&#34;_forward_audio_task&#34;
        )

    def _on_video_output_changed(self) -&gt; None:
        pass

    def _on_audio_output_changed(self) -&gt; None:
        pass

    def _on_text_output_changed(self) -&gt; None:
        pass

    # ---</code></pre>
</details>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::</p>
<pre><code>class Mapping[KT, VT]:
    def __getitem__(self, key: KT) -&gt; VT:
        ...
    # Etc.
</code></pre>
<p>On older versions of Python, however, generic classes have to
explicitly inherit from Generic.</p>
<p>After a class has been declared to be generic, it can then be used as
follows::</p>
<pre><code>def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
    try:
        return mapping[key]
    except KeyError:
        return default
</code></pre>
<p><code><a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a></code> is the LiveKit Agents runtime that glues together
media streams, speech/LLM components, and tool orchestration into a
single real-time voice agent.</p>
<p>It links audio, video, and text I/O with STT, VAD, TTS, and the LLM;
handles turn detection, endpointing, interruptions, and multi-step
tool calls; and exposes everything through event callbacks so you can
focus on writing function tools and simple hand-offs rather than
low-level streaming logic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>turn_detection</code></strong> :&ensp;<code>TurnDetectionMode</code>, optional</dt>
<dd>
<p>Strategy for deciding
when the user has finished speaking.</p>
<ul>
<li><code>"stt"</code> – rely on speech-to-text end-of-utterance cues</li>
<li><code>"vad"</code> – rely on Voice Activity Detection start/stop cues</li>
<li><code>"realtime_llm"</code> – use server-side detection from a
realtime LLM</li>
<li><code>"manual"</code> – caller controls turn boundaries explicitly</li>
<li><code>_TurnDetector</code> instance – plug-in custom detector</li>
</ul>
<p>If <em>NOT_GIVEN</em>, the session chooses the best available mode in
priority order <code>realtime_llm → vad → stt → manual</code>; it
automatically falls back if the necessary model is missing.</p>
</dd>
<dt><strong><code>stt</code></strong> :&ensp;<code><a title="livekit.agents.stt.STT" href="stt/index.html#livekit.agents.stt.STT">STT</a></code>, optional</dt>
<dd>Speech-to-text backend.</dd>
<dt><strong><code>vad</code></strong> :&ensp;<code><a title="livekit.agents.vad.VAD" href="vad.html#livekit.agents.vad.VAD">VAD</a></code>, optional</dt>
<dd>Voice-activity detector</dd>
<dt><strong><code>llm</code></strong> :&ensp;<code>llm.LLM | llm.RealtimeModel</code>, optional</dt>
<dd>LLM or RealtimeModel</dd>
<dt><strong><code>tts</code></strong> :&ensp;<code><a title="livekit.agents.tts.TTS" href="tts/index.html#livekit.agents.tts.TTS">TTS</a></code>, optional</dt>
<dd>Text-to-speech engine.</dd>
<dt><strong><code>userdata</code></strong> :&ensp;<code>Userdata_T</code>, optional</dt>
<dd>Arbitrary per-session user data.</dd>
<dt><strong><code>allow_interruptions</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the user can interrupt the
agent mid-utterance. Default <code>True</code>.</dd>
<dt><strong><code>discard_audio_if_uninterruptible</code></strong> :&ensp;<code>bool</code></dt>
<dd>When <code>True</code>, buffered
audio is dropped while the agent is speaking and cannot be
interrupted. Default <code>True</code>.</dd>
<dt><strong><code>min_interruption_duration</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum speech length (s) to
register as an interruption. Default <code>0.5</code> s.</dd>
<dt><strong><code>min_endpointing_delay</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum time-in-seconds the agent
must wait after a potential end-of-utterance signal (from VAD
or an EOU model) before it declares the user’s turn complete.
Default <code>0.5</code> s.</dd>
<dt><strong><code>max_endpointing_delay</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum time-in-seconds the agent
will wait before terminating the turn. Default <code>6.0</code> s.</dd>
<dt><strong><code>max_tool_steps</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum consecutive tool calls per LLM turn.
Default <code>3</code>.</dd>
<dt><strong><code>video_sampler</code></strong> :&ensp;<code>_VideoSampler</code>, optional</dt>
<dd>Uses
:class:<code>VoiceActivityVideoSampler</code> when <em>NOT_GIVEN</em>; that sampler
captures video at ~1 fps while the user is speaking and ~0.3 fps
when silent by default.</dd>
<dt><strong><code>loop</code></strong> :&ensp;<code>asyncio.AbstractEventLoop</code>, optional</dt>
<dd>Event loop to bind the
session to. Falls back to :pyfunc:<code>asyncio.get_event_loop()</code>.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.event_emitter.EventEmitter" href="../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a></li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.AgentSession.agent_state"><code class="name">prop <span class="ident">agent_state</span> : AgentState</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def agent_state(self) -&gt; AgentState:
    return self._agent_state</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.current_agent"><code class="name">prop <span class="ident">current_agent</span> : <a title="livekit.agents.Agent" href="#livekit.agents.Agent">Agent</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def current_agent(self) -&gt; Agent:
    if self._agent is None:
        raise RuntimeError(&#34;VoiceAgent isn&#39;t running&#34;)

    return self._agent</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.current_speech"><code class="name">prop <span class="ident">current_speech</span> : SpeechHandle | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def current_speech(self) -&gt; SpeechHandle | None:
    return self._activity.current_speech if self._activity is not None else None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.history"><code class="name">prop <span class="ident">history</span> : <a title="livekit.agents.llm.ChatContext" href="llm/index.html#livekit.agents.llm.ChatContext">ChatContext</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def history(self) -&gt; llm.ChatContext:
    return self._chat_ctx</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.input"><code class="name">prop <span class="ident">input</span> : io.AgentInput</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def input(self) -&gt; io.AgentInput:
    return self._input</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.llm"><code class="name">prop <span class="ident">llm</span> : <a title="livekit.agents.llm.LLM" href="llm/index.html#livekit.agents.llm.LLM">LLM</a> | <a title="livekit.agents.llm.RealtimeModel" href="llm/index.html#livekit.agents.llm.RealtimeModel">RealtimeModel</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def llm(self) -&gt; llm.LLM | llm.RealtimeModel | None:
    return self._llm</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.options"><code class="name">prop <span class="ident">options</span> : VoiceOptions</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def options(self) -&gt; VoiceOptions:
    return self._opts</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.output"><code class="name">prop <span class="ident">output</span> : io.AgentOutput</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def output(self) -&gt; io.AgentOutput:
    return self._output</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.stt"><code class="name">prop <span class="ident">stt</span> : <a title="livekit.agents.stt.STT" href="stt/index.html#livekit.agents.stt.STT">STT</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stt(self) -&gt; stt.STT | None:
    return self._stt</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.tts"><code class="name">prop <span class="ident">tts</span> : <a title="livekit.agents.tts.TTS" href="tts/index.html#livekit.agents.tts.TTS">TTS</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tts(self) -&gt; tts.TTS | None:
    return self._tts</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.turn_detection"><code class="name">prop <span class="ident">turn_detection</span> : TurnDetectionMode | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def turn_detection(self) -&gt; TurnDetectionMode | None:
    return self._turn_detection</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.user_state"><code class="name">prop <span class="ident">user_state</span> : UserState</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def user_state(self) -&gt; UserState:
    return self._user_state</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.userdata"><code class="name">prop <span class="ident">userdata</span> : Userdata_T</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def userdata(self) -&gt; Userdata_T:
    if self._userdata is None:
        raise ValueError(&#34;VoiceAgent userdata is not set&#34;)

    return self._userdata</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.vad"><code class="name">prop <span class="ident">vad</span> : <a title="livekit.agents.vad.VAD" href="vad.html#livekit.agents.vad.VAD">VAD</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vad(self) -&gt; vad.VAD | None:
    return self._vad</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.AgentSession.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self) -&gt; None:
    await self._aclose_impl()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.clear_user_turn"><code class="name flex">
<span>def <span class="ident">clear_user_turn</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_user_turn(self) -&gt; None:
    # clear the transcription or input audio buffer of the user turn
    if self._activity is None:
        raise RuntimeError(&#34;AgentSession isn&#39;t running&#34;)

    self._activity.clear_user_turn()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.commit_user_turn"><code class="name flex">
<span>def <span class="ident">commit_user_turn</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit_user_turn(self) -&gt; None:
    # commit the user turn and generate a reply
    if self._activity is None:
        raise RuntimeError(&#34;AgentSession isn&#39;t running&#34;)

    self._activity.commit_user_turn()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.drain"><code class="name flex">
<span>async def <span class="ident">drain</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def drain(self) -&gt; None:
    if self._activity is None:
        raise RuntimeError(&#34;AgentSession isn&#39;t running&#34;)

    await self._activity.drain()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.generate_reply"><code class="name flex">
<span>def <span class="ident">generate_reply</span></span>(<span>self,<br>*,<br>user_input: NotGivenOr[str] = NOT_GIVEN,<br>instructions: NotGivenOr[str] = NOT_GIVEN,<br>tool_choice: NotGivenOr[llm.ToolChoice] = NOT_GIVEN,<br>allow_interruptions: NotGivenOr[bool] = NOT_GIVEN) ‑> livekit.agents.voice.speech_handle.SpeechHandle</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_reply(
    self,
    *,
    user_input: NotGivenOr[str] = NOT_GIVEN,
    instructions: NotGivenOr[str] = NOT_GIVEN,
    tool_choice: NotGivenOr[llm.ToolChoice] = NOT_GIVEN,
    allow_interruptions: NotGivenOr[bool] = NOT_GIVEN,
) -&gt; SpeechHandle:
    &#34;&#34;&#34;Generate a reply for the agent to speak to the user.

    Args:
        user_input (NotGivenOr[str], optional): The user&#39;s input that may influence the reply,
            such as answering a question.
        instructions (NotGivenOr[str], optional): Additional instructions for generating the reply.
        tool_choice (NotGivenOr[llm.ToolChoice], optional): Specifies the external tool to use when
            generating the reply. If generate_reply is invoked within a function_tool, defaults to &#34;none&#34;.
        allow_interruptions (NotGivenOr[bool], optional): Indicates whether the user can interrupt this speech.

    Returns:
        SpeechHandle: A handle to the generated reply.
    &#34;&#34;&#34;  # noqa: E501
    if self._activity is None:
        raise RuntimeError(&#34;AgentSession isn&#39;t running&#34;)

    user_message = (
        llm.ChatMessage(role=&#34;user&#34;, content=[user_input])
        if is_given(user_input)
        else NOT_GIVEN
    )

    if self._activity.draining:
        if self._next_activity is None:
            raise RuntimeError(&#34;AgentSession is closing, cannot use generate_reply()&#34;)

        return self._next_activity._generate_reply(
            user_message=user_message,
            instructions=instructions,
            tool_choice=tool_choice,
            allow_interruptions=allow_interruptions,
        )

    return self._activity._generate_reply(
        user_message=user_message,
        instructions=instructions,
        tool_choice=tool_choice,
        allow_interruptions=allow_interruptions,
    )</code></pre>
</details>
<div class="desc"><p>Generate a reply for the agent to speak to the user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_input</code></strong> :&ensp;<code>NotGivenOr[str]</code>, optional</dt>
<dd>The user's input that may influence the reply,
such as answering a question.</dd>
<dt><strong><code>instructions</code></strong> :&ensp;<code>NotGivenOr[str]</code>, optional</dt>
<dd>Additional instructions for generating the reply.</dd>
<dt><strong><code>tool_choice</code></strong> :&ensp;<code>NotGivenOr[llm.ToolChoice]</code>, optional</dt>
<dd>Specifies the external tool to use when
generating the reply. If generate_reply is invoked within a function_tool, defaults to "none".</dd>
<dt><strong><code>allow_interruptions</code></strong> :&ensp;<code>NotGivenOr[bool]</code>, optional</dt>
<dd>Indicates whether the user can interrupt this speech.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SpeechHandle</code></dt>
<dd>A handle to the generated reply.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.AgentSession.interrupt"><code class="name flex">
<span>def <span class="ident">interrupt</span></span>(<span>self) ‑> _asyncio.Future</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interrupt(self) -&gt; asyncio.Future:
    &#34;&#34;&#34;Interrupt the current speech generation.

    Returns:
        An asyncio.Future that completes when the interruption is fully processed
        and chat context has been updated.

    Example:
        ```python
        await session.interrupt()
        ```
    &#34;&#34;&#34;
    if self._activity is None:
        raise RuntimeError(&#34;AgentSession isn&#39;t running&#34;)

    return self._activity.interrupt()</code></pre>
</details>
<div class="desc"><p>Interrupt the current speech generation.</p>
<h2 id="returns">Returns</h2>
<p>An asyncio.Future that completes when the interruption is fully processed
and chat context has been updated.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">await session.interrupt()
</code></pre></div>
</dd>
<dt id="livekit.agents.AgentSession.say"><code class="name flex">
<span>def <span class="ident">say</span></span>(<span>self,<br>text: str | AsyncIterable[str],<br>*,<br>audio: NotGivenOr[AsyncIterable[rtc.AudioFrame]] = NOT_GIVEN,<br>allow_interruptions: NotGivenOr[bool] = NOT_GIVEN,<br>add_to_chat_ctx: bool = True) ‑> livekit.agents.voice.speech_handle.SpeechHandle</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def say(
    self,
    text: str | AsyncIterable[str],
    *,
    audio: NotGivenOr[AsyncIterable[rtc.AudioFrame]] = NOT_GIVEN,
    allow_interruptions: NotGivenOr[bool] = NOT_GIVEN,
    add_to_chat_ctx: bool = True,
) -&gt; SpeechHandle:
    if self._activity is None:
        raise RuntimeError(&#34;AgentSession isn&#39;t running&#34;)

    if self._activity.draining:
        if self._next_activity is None:
            raise RuntimeError(&#34;AgentSession is closing, cannot use say()&#34;)

        return self._next_activity.say(
            text,
            audio=audio,
            allow_interruptions=allow_interruptions,
            add_to_chat_ctx=add_to_chat_ctx,
        )

    return self._activity.say(
        text,
        audio=audio,
        allow_interruptions=allow_interruptions,
        add_to_chat_ctx=add_to_chat_ctx,
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.start"><code class="name flex">
<span>async def <span class="ident">start</span></span>(<span>self,<br>agent: <a title="livekit.agents.Agent" href="#livekit.agents.Agent">Agent</a>,<br>*,<br>room: NotGivenOr[rtc.Room] = NOT_GIVEN,<br>room_input_options: NotGivenOr[room_io.RoomInputOptions] = NOT_GIVEN,<br>room_output_options: NotGivenOr[room_io.RoomOutputOptions] = NOT_GIVEN) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start(
    self,
    agent: Agent,
    *,
    room: NotGivenOr[rtc.Room] = NOT_GIVEN,
    room_input_options: NotGivenOr[room_io.RoomInputOptions] = NOT_GIVEN,
    room_output_options: NotGivenOr[room_io.RoomOutputOptions] = NOT_GIVEN,
) -&gt; None:
    &#34;&#34;&#34;Start the voice agent.

    Create a default RoomIO if the input or output audio is not already set.
    If the console flag is provided, start a ChatCLI.

    Args:
        room: The room to use for input and output
        room_input_options: Options for the room input
        room_output_options: Options for the room output
    &#34;&#34;&#34;
    async with self._lock:
        if self._started:
            return

        self._agent = agent
        self._update_agent_state(&#34;initializing&#34;)

        if cli.CLI_ARGUMENTS is not None and cli.CLI_ARGUMENTS.console:
            from .chat_cli import ChatCLI

            if (
                self.input.audio is not None
                or self.output.audio is not None
                or self.output.transcription is not None
            ):
                logger.warning(
                    &#34;agent started with the console subcommand, but input.audio or output.audio &#34;  # noqa: E501
                    &#34;or output.transcription is already set, overriding..&#34;
                )

            chat_cli = ChatCLI(self)
            await chat_cli.start()

        elif is_given(room) and not self._room_io:
            room_input_options = copy.copy(
                room_input_options or room_io.DEFAULT_ROOM_INPUT_OPTIONS
            )
            room_output_options = copy.copy(
                room_output_options or room_io.DEFAULT_ROOM_OUTPUT_OPTIONS
            )

            if self.input.audio is not None and room_input_options.audio_enabled:
                logger.warning(
                    &#34;RoomIO audio input is enabled but input.audio is already set, ignoring..&#34;
                )
                room_input_options.audio_enabled = False

            if self.output.audio is not None and room_output_options.audio_enabled:
                logger.warning(
                    &#34;RoomIO audio output is enabled but output.audio is already set, ignoring..&#34;
                )
                room_output_options.audio_enabled = False

            if (
                self.output.transcription is not None
                and room_output_options.transcription_enabled
            ):
                logger.warning(
                    &#34;RoomIO transcription output is enabled but output.transcription is already set, ignoring..&#34;  # noqa: E501
                )
                room_output_options.transcription_enabled = False

            self._room_io = room_io.RoomIO(
                room=room,
                agent_session=self,
                input_options=room_input_options,
                output_options=room_output_options,
            )
            await self._room_io.start()

        else:
            if not self._room_io and not self.output.audio and not self.output.transcription:
                logger.warning(
                    &#34;session starts without output, forgetting to pass `room` to `AgentSession.start()`?&#34;  # noqa: E501
                )

        try:
            job_ctx = get_job_context()
            job_ctx.add_tracing_callback(self._trace_chat_ctx)
        except RuntimeError:
            pass  # ignore

        # it is ok to await it directly, there is no previous task to drain
        await self._update_activity_task(self._agent)

        # important: no await should be done after this!

        if self.input.audio is not None:
            self._forward_audio_atask = asyncio.create_task(
                self._forward_audio_task(), name=&#34;_forward_audio_task&#34;
            )

        if self.input.video is not None:
            self._forward_video_atask = asyncio.create_task(
                self._forward_video_task(), name=&#34;_forward_video_task&#34;
            )

        self._started = True
        self._update_agent_state(&#34;listening&#34;)</code></pre>
</details>
<div class="desc"><p>Start the voice agent.</p>
<p>Create a default RoomIO if the input or output audio is not already set.
If the console flag is provided, start a ChatCLI.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>room</code></strong></dt>
<dd>The room to use for input and output</dd>
<dt><strong><code>room_input_options</code></strong></dt>
<dd>Options for the room input</dd>
<dt><strong><code>room_output_options</code></strong></dt>
<dd>Options for the room output</dd>
</dl></div>
</dd>
<dt id="livekit.agents.AgentSession.update_agent"><code class="name flex">
<span>def <span class="ident">update_agent</span></span>(<span>self,<br>agent: <a title="livekit.agents.Agent" href="#livekit.agents.Agent">Agent</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_agent(self, agent: Agent) -&gt; None:
    self._agent = agent

    if self._started:
        self._update_activity_atask = asyncio.create_task(
            self._update_activity_task(self._agent), name=&#34;_update_activity_task&#34;
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.AgentSession.update_options"><code class="name flex">
<span>def <span class="ident">update_options</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_options(self) -&gt; None:
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livekit.rtc.event_emitter.EventEmitter" href="../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a></b></code>:
<ul class="hlist">
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.emit" href="../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.emit">emit</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.off" href="../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.off">off</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.on" href="../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.on">on</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.once" href="../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.once">once</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livekit.agents.AgentStateChangedEvent"><code class="flex name class">
<span>class <span class="ident">AgentStateChangedEvent</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AgentStateChangedEvent(BaseModel):
    type: Literal[&#34;agent_state_changed&#34;] = &#34;agent_state_changed&#34;
    old_state: AgentState
    new_state: AgentState</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.AgentStateChangedEvent.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.AgentStateChangedEvent.new_state"><code class="name">var <span class="ident">new_state</span> : Literal['initializing', 'idle', 'listening', 'thinking', 'speaking']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.AgentStateChangedEvent.old_state"><code class="name">var <span class="ident">old_state</span> : Literal['initializing', 'idle', 'listening', 'thinking', 'speaking']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.AgentStateChangedEvent.type"><code class="name">var <span class="ident">type</span> : Literal['agent_state_changed']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.AssignmentTimeoutError"><code class="flex name class">
<span>class <span class="ident">AssignmentTimeoutError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssignmentTimeoutError(Exception):
    &#34;&#34;&#34;Raised when accepting a job but not receiving an assignment within the specified timeout.
    The server may have chosen another worker to handle this job.&#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Raised when accepting a job but not receiving an assignment within the specified timeout.
The server may have chosen another worker to handle this job.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="livekit.agents.AudioConfig"><code class="flex name class">
<span>class <span class="ident">AudioConfig</span></span>
<span>(</span><span>source: ForwardRef('AudioSource'),<br>volume: ForwardRef('float') = 1.0,<br>probability: ForwardRef('float') = 1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioConfig(NamedTuple):
    &#34;&#34;&#34;
    Definition for the audio to be played in the background

    Args:
        volume: The volume of the audio (0.0-1.0)
        probability: The probability of the audio being played, when multiple
            AudioConfigs are provided (0.0-1.0)
    &#34;&#34;&#34;

    source: AudioSource
    volume: float = 1.0
    probability: float = 1.0</code></pre>
</details>
<div class="desc"><p>Definition for the audio to be played in the background</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>volume</code></strong></dt>
<dd>The volume of the audio (0.0-1.0)</dd>
<dt><strong><code>probability</code></strong></dt>
<dd>The probability of the audio being played, when multiple
AudioConfigs are provided (0.0-1.0)</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.AudioConfig.probability"><code class="name">var <span class="ident">probability</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioConfig(NamedTuple):
    &#34;&#34;&#34;
    Definition for the audio to be played in the background

    Args:
        volume: The volume of the audio (0.0-1.0)
        probability: The probability of the audio being played, when multiple
            AudioConfigs are provided (0.0-1.0)
    &#34;&#34;&#34;

    source: AudioSource
    volume: float = 1.0
    probability: float = 1.0</code></pre>
</details>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="livekit.agents.AudioConfig.source"><code class="name">var <span class="ident">source</span> : AsyncIterator[<a title="livekit.rtc.audio_frame.AudioFrame" href="../rtc/audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>] | str | <a title="livekit.agents.voice.background_audio.BuiltinAudioClip" href="voice/background_audio.html#livekit.agents.voice.background_audio.BuiltinAudioClip">BuiltinAudioClip</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioConfig(NamedTuple):
    &#34;&#34;&#34;
    Definition for the audio to be played in the background

    Args:
        volume: The volume of the audio (0.0-1.0)
        probability: The probability of the audio being played, when multiple
            AudioConfigs are provided (0.0-1.0)
    &#34;&#34;&#34;

    source: AudioSource
    volume: float = 1.0
    probability: float = 1.0</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="livekit.agents.AudioConfig.volume"><code class="name">var <span class="ident">volume</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioConfig(NamedTuple):
    &#34;&#34;&#34;
    Definition for the audio to be played in the background

    Args:
        volume: The volume of the audio (0.0-1.0)
        probability: The probability of the audio being played, when multiple
            AudioConfigs are provided (0.0-1.0)
    &#34;&#34;&#34;

    source: AudioSource
    volume: float = 1.0
    probability: float = 1.0</code></pre>
</details>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.AutoSubscribe"><code class="flex name class">
<span>class <span class="ident">AutoSubscribe</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AutoSubscribe(str, Enum):
    SUBSCRIBE_ALL = &#34;subscribe_all&#34;
    SUBSCRIBE_NONE = &#34;subscribe_none&#34;
    AUDIO_ONLY = &#34;audio_only&#34;
    VIDEO_ONLY = &#34;video_only&#34;</code></pre>
</details>
<div class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to 'utf-8'.
errors defaults to 'strict'.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.AutoSubscribe.AUDIO_ONLY"><code class="name">var <span class="ident">AUDIO_ONLY</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.AutoSubscribe.SUBSCRIBE_ALL"><code class="name">var <span class="ident">SUBSCRIBE_ALL</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.AutoSubscribe.SUBSCRIBE_NONE"><code class="name">var <span class="ident">SUBSCRIBE_NONE</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.AutoSubscribe.VIDEO_ONLY"><code class="name">var <span class="ident">VIDEO_ONLY</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.BackgroundAudioPlayer"><code class="flex name class">
<span>class <span class="ident">BackgroundAudioPlayer</span></span>
<span>(</span><span>*,<br>ambient_sound: NotGivenOr[AudioSource | <a title="livekit.agents.AudioConfig" href="#livekit.agents.AudioConfig">AudioConfig</a> | list[<a title="livekit.agents.AudioConfig" href="#livekit.agents.AudioConfig">AudioConfig</a>] | None] = NOT_GIVEN,<br>thinking_sound: NotGivenOr[AudioSource | <a title="livekit.agents.AudioConfig" href="#livekit.agents.AudioConfig">AudioConfig</a> | list[<a title="livekit.agents.AudioConfig" href="#livekit.agents.AudioConfig">AudioConfig</a>] | None] = NOT_GIVEN)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BackgroundAudioPlayer:
    def __init__(
        self,
        *,
        ambient_sound: NotGivenOr[AudioSource | AudioConfig | list[AudioConfig] | None] = NOT_GIVEN,
        thinking_sound: NotGivenOr[
            AudioSource | AudioConfig | list[AudioConfig] | None
        ] = NOT_GIVEN,
    ) -&gt; None:
        &#34;&#34;&#34;
        Initializes the BackgroundAudio component with optional ambient and thinking sounds.

        This component creates and publishes a continuous audio track to a LiveKit room while managing
        the playback of ambient and agent “thinking” sounds. It supports three types of audio sources:
        - A BuiltinAudioClip enum value, which will use a pre-defined sound from the package resources
        - A file path (string) pointing to an audio file, which can be looped.
        - An AsyncIterator that yields rtc.AudioFrame

        When a list (or AudioConfig) is supplied, the component considers each sound’s volume and probability:
        - The probability value determines the chance that a particular sound is selected for playback.
        - A total probability below 1.0 means there is a chance no sound will be selected (resulting in silence).

        Args:
            ambient_sound (NotGivenOr[Union[AudioSource, AudioConfig, List[AudioConfig], None]], optional):
                The ambient sound to be played continuously. For file paths, the sound will be looped.
                For AsyncIterator sources, ensure the iterator is infinite or looped.

            thinking_sound (NotGivenOr[Union[AudioSource, AudioConfig, List[AudioConfig], None]], optional):
                The sound to be played when the associated agent enters a “thinking” state. This can be a single
                sound source or a list of AudioConfig objects (with volume and probability settings).

        &#34;&#34;&#34;  # noqa: E501

        self._ambient_sound = ambient_sound if is_given(ambient_sound) else None
        self._thinking_sound = thinking_sound if is_given(thinking_sound) else None

        self._audio_source = rtc.AudioSource(48000, 1, queue_size_ms=_AUDIO_SOURCE_BUFFER_MS)
        self._audio_mixer = rtc.AudioMixer(48000, 1, blocksize=4800, capacity=1)
        self._publication: rtc.LocalTrackPublication | None = None
        self._lock = asyncio.Lock()

        self._republish_task: asyncio.Task | None = None  # republish the task on reconnect
        self._mixer_atask: asyncio.Task | None = None

        self._play_tasks: list[asyncio.Task] = []

        self._ambient_handle: PlayHandle | None = None
        self._thinking_handle: PlayHandle | None = None

    def _select_sound_from_list(self, sounds: list[AudioConfig]) -&gt; AudioConfig | None:
        &#34;&#34;&#34;
        Selects a sound from a list of BackgroundSound based on their probabilities.
        Returns None if no sound is selected (when sum of probabilities &lt; 1.0).
        &#34;&#34;&#34;
        total_probability = sum(sound.probability for sound in sounds)
        if total_probability &lt;= 0:
            return None

        if total_probability &lt; 1.0 and random.random() &gt; total_probability:
            return None

        normalize_factor = 1.0 if total_probability &lt;= 1.0 else total_probability
        r = random.random() * min(total_probability, 1.0)
        cumulative = 0.0

        for sound in sounds:
            if sound.probability &lt;= 0:
                continue

            norm_prob = sound.probability / normalize_factor
            cumulative += norm_prob

            if r &lt;= cumulative:
                return sound

        return sounds[-1]

    def _normalize_sound_source(
        self, source: AudioSource | AudioConfig | list[AudioConfig] | None
    ) -&gt; tuple[AudioSource, float] | None:
        if source is None:
            return None

        if isinstance(source, BuiltinAudioClip):
            return self._normalize_builtin_audio(source), 1.0
        elif isinstance(source, list):
            selected = self._select_sound_from_list(cast(list[AudioConfig], source))
            if selected is None:
                return None
            return selected.source, selected.volume
        elif isinstance(source, AudioConfig):
            return self._normalize_builtin_audio(source.source), source.volume

        return source, 1.0

    def _normalize_builtin_audio(self, source: AudioSource) -&gt; AsyncIterator[rtc.AudioFrame] | str:
        if isinstance(source, BuiltinAudioClip):
            return source.path()
        else:
            return source

    def play(
        self,
        audio: AudioSource | AudioConfig | list[AudioConfig],
        *,
        loop: bool = False,
    ) -&gt; PlayHandle:
        &#34;&#34;&#34;
        Plays an audio once or in a loop.

        Args:
            audio (Union[AudioSource, AudioConfig, List[AudioConfig]]):
                The audio to play. Can be:
                - A string pointing to a file path
                - An AsyncIterator that yields `rtc.AudioFrame`
                - An AudioConfig object with volume and probability
                - A list of AudioConfig objects, where one will be selected based on probability

                If a string is provided and `loop` is True, the sound will be looped.
                If an AsyncIterator is provided, it is played until exhaustion (and cannot be looped
                automatically).
            loop (bool, optional):
                Whether to loop the audio. Only applicable if `audio` is a string or contains strings.
                Defaults to False.

        Returns:
            PlayHandle: An object representing the playback handle. This can be
            awaited or stopped manually.
        &#34;&#34;&#34;  # noqa: E501
        if not self._mixer_atask:
            raise RuntimeError(&#34;BackgroundAudio is not started&#34;)

        normalized = self._normalize_sound_source(audio)
        if normalized is None:
            play_handle = PlayHandle()
            play_handle._mark_playout_done()
            return play_handle

        sound_source, volume = normalized

        if loop and isinstance(sound_source, AsyncIterator):
            raise ValueError(
                &#34;Looping sound via AsyncIterator is not supported. Use a string file path or your own &#39;infinite&#39; AsyncIterator with loop=False&#34;  # noqa: E501
            )

        play_handle = PlayHandle()
        task = asyncio.create_task(self._play_task(play_handle, sound_source, volume, loop))
        task.add_done_callback(lambda _: self._play_tasks.remove(task))
        task.add_done_callback(lambda _: play_handle._mark_playout_done())
        self._play_tasks.append(task)
        return play_handle

    async def start(
        self,
        *,
        room: rtc.Room,
        agent_session: NotGivenOr[AgentSession] = NOT_GIVEN,
        track_publish_options: NotGivenOr[rtc.TrackPublishOptions] = NOT_GIVEN,
    ) -&gt; None:
        &#34;&#34;&#34;
        Starts the background audio system, publishing the audio track
        and beginning playback of any configured ambient sound.

        If `ambient_sound` is provided (and contains file paths), they will loop
        automatically. If `ambient_sound` contains AsyncIterators, they are assumed
        to be already infinite or looped.

        Args:
            room (rtc.Room):
                The LiveKit Room object where the audio track will be published.
            agent_session (NotGivenOr[AgentSession], optional):
                The session object used to track the agent&#39;s state (e.g., &#34;thinking&#34;).
                Required if `thinking_sound` is provided.
            track_publish_options (NotGivenOr[rtc.TrackPublishOptions], optional):
                Options used when publishing the audio track. If not given, defaults will
                be used.
        &#34;&#34;&#34;
        async with self._lock:
            self._room = room
            self._agent_session = agent_session or None
            self._track_publish_options = track_publish_options or None

            if cli.CLI_ARGUMENTS is not None and cli.CLI_ARGUMENTS.console:
                logger.warning(
                    &#34;Background audio is not supported in console mode. Audio will not be played.&#34;
                )

            await self._publish_track()

            self._mixer_atask = asyncio.create_task(self._run_mixer_task())
            self._room.on(&#34;reconnected&#34;, self._on_reconnected)

            if self._agent_session:
                self._agent_session.on(&#34;agent_state_changed&#34;, self._agent_state_changed)

            if self._ambient_sound:
                normalized = self._normalize_sound_source(self._ambient_sound)
                if normalized:
                    sound_source, volume = normalized
                    selected_sound = AudioConfig(sound_source, volume)
                    if isinstance(sound_source, str):
                        self._ambient_handle = self.play(selected_sound, loop=True)
                    else:
                        self._ambient_handle = self.play(selected_sound)

    async def aclose(self) -&gt; None:
        &#34;&#34;&#34;
        Gracefully closes the background audio system, canceling all ongoing
        playback tasks and unpublishing the audio track.
        &#34;&#34;&#34;
        async with self._lock:
            if not self._mixer_atask:
                return  # not started

            await cancel_and_wait(*self._play_tasks)

            if self._republish_task:
                await cancel_and_wait(self._republish_task)

            await cancel_and_wait(self._mixer_atask)

            await self._audio_source.aclose()
            await self._audio_mixer.aclose()

            if self._agent_session:
                self._agent_session.off(&#34;agent_state_changed&#34;, self._agent_state_changed)

            self._room.off(&#34;reconnected&#34;, self._on_reconnected)

            with contextlib.suppress(Exception):
                if self._publication is not None:
                    await self._room.local_participant.unpublish_track(self._publication.sid)

    def _on_reconnected(self) -&gt; None:
        if self._republish_task:
            self._republish_task.cancel()

        self._publication = None
        self._republish_task = asyncio.create_task(self._republish_track_task())

    def _agent_state_changed(self, ev: AgentStateChangedEvent) -&gt; None:
        if not self._thinking_sound:
            return

        if ev.new_state == &#34;thinking&#34;:
            if self._thinking_handle and not self._thinking_handle.done():
                return

            self._thinking_handle = self.play(self._thinking_sound)

        elif self._thinking_handle:
            self._thinking_handle.stop()

    @log_exceptions(logger=logger)
    async def _play_task(
        self, play_handle: PlayHandle, sound: AudioSource, volume: float, loop: bool
    ) -&gt; None:
        if isinstance(sound, BuiltinAudioClip):
            sound = sound.path()

        if isinstance(sound, str):
            if loop:
                sound = _loop_audio_frames(sound)
            else:
                sound = audio_frames_from_file(sound)

        async def _gen_wrapper() -&gt; AsyncGenerator[rtc.AudioFrame, None]:
            async for frame in sound:
                if volume != 1.0:
                    data = np.frombuffer(frame.data, dtype=np.int16).astype(np.float32)
                    data *= 10 ** (np.log10(volume))
                    np.clip(data, -32768, 32767, out=data)
                    yield rtc.AudioFrame(
                        data=data.astype(np.int16).tobytes(),
                        sample_rate=frame.sample_rate,
                        num_channels=frame.num_channels,
                        samples_per_channel=frame.samples_per_channel,
                    )
                else:
                    yield frame

            # TODO(theomonnom): the wait_for_playout() may be innaccurate by 400ms
            play_handle._mark_playout_done()

        gen = _gen_wrapper()
        try:
            self._audio_mixer.add_stream(gen)
            await play_handle.wait_for_playout()  # wait for playout or interruption
        finally:
            if play_handle._stop_fut.done():
                self._audio_mixer.remove_stream(gen)
                await gen.aclose()

            play_handle._mark_playout_done()  # the task could be cancelled

    @log_exceptions(logger=logger)
    async def _run_mixer_task(self) -&gt; None:
        async for frame in self._audio_mixer:
            await self._audio_source.capture_frame(frame)

    async def _publish_track(self) -&gt; None:
        if self._publication is not None:
            return

        track = rtc.LocalAudioTrack.create_audio_track(&#34;background_audio&#34;, self._audio_source)
        self._publication = await self._room.local_participant.publish_track(
            track, self._track_publish_options or rtc.TrackPublishOptions()
        )

    @log_exceptions(logger=logger)
    async def _republish_track_task(self) -&gt; None:
        # used to republish the track on agent reconnect
        async with self._lock:
            await self._publish_track()</code></pre>
</details>
<div class="desc"><p>Initializes the BackgroundAudio component with optional ambient and thinking sounds.</p>
<p>This component creates and publishes a continuous audio track to a LiveKit room while managing
the playback of ambient and agent “thinking” sounds. It supports three types of audio sources:
- A BuiltinAudioClip enum value, which will use a pre-defined sound from the package resources
- A file path (string) pointing to an audio file, which can be looped.
- An AsyncIterator that yields rtc.AudioFrame</p>
<p>When a list (or AudioConfig) is supplied, the component considers each sound’s volume and probability:
- The probability value determines the chance that a particular sound is selected for playback.
- A total probability below 1.0 means there is a chance no sound will be selected (resulting in silence).</p>
<h2 id="args">Args</h2>
<p>ambient_sound (NotGivenOr[Union[AudioSource, AudioConfig, List[AudioConfig], None]], optional):
The ambient sound to be played continuously. For file paths, the sound will be looped.
For AsyncIterator sources, ensure the iterator is infinite or looped.</p>
<p>thinking_sound (NotGivenOr[Union[AudioSource, AudioConfig, List[AudioConfig], None]], optional):
The sound to be played when the associated agent enters a “thinking” state. This can be a single
sound source or a list of AudioConfig objects (with volume and probability settings).</p></div>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.BackgroundAudioPlayer.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self) -&gt; None:
    &#34;&#34;&#34;
    Gracefully closes the background audio system, canceling all ongoing
    playback tasks and unpublishing the audio track.
    &#34;&#34;&#34;
    async with self._lock:
        if not self._mixer_atask:
            return  # not started

        await cancel_and_wait(*self._play_tasks)

        if self._republish_task:
            await cancel_and_wait(self._republish_task)

        await cancel_and_wait(self._mixer_atask)

        await self._audio_source.aclose()
        await self._audio_mixer.aclose()

        if self._agent_session:
            self._agent_session.off(&#34;agent_state_changed&#34;, self._agent_state_changed)

        self._room.off(&#34;reconnected&#34;, self._on_reconnected)

        with contextlib.suppress(Exception):
            if self._publication is not None:
                await self._room.local_participant.unpublish_track(self._publication.sid)</code></pre>
</details>
<div class="desc"><p>Gracefully closes the background audio system, canceling all ongoing
playback tasks and unpublishing the audio track.</p></div>
</dd>
<dt id="livekit.agents.BackgroundAudioPlayer.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self,<br>audio: AudioSource | <a title="livekit.agents.AudioConfig" href="#livekit.agents.AudioConfig">AudioConfig</a> | list[<a title="livekit.agents.AudioConfig" href="#livekit.agents.AudioConfig">AudioConfig</a>],<br>*,<br>loop: bool = False) ‑> <a title="livekit.agents.voice.background_audio.PlayHandle" href="voice/background_audio.html#livekit.agents.voice.background_audio.PlayHandle">PlayHandle</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play(
    self,
    audio: AudioSource | AudioConfig | list[AudioConfig],
    *,
    loop: bool = False,
) -&gt; PlayHandle:
    &#34;&#34;&#34;
    Plays an audio once or in a loop.

    Args:
        audio (Union[AudioSource, AudioConfig, List[AudioConfig]]):
            The audio to play. Can be:
            - A string pointing to a file path
            - An AsyncIterator that yields `rtc.AudioFrame`
            - An AudioConfig object with volume and probability
            - A list of AudioConfig objects, where one will be selected based on probability

            If a string is provided and `loop` is True, the sound will be looped.
            If an AsyncIterator is provided, it is played until exhaustion (and cannot be looped
            automatically).
        loop (bool, optional):
            Whether to loop the audio. Only applicable if `audio` is a string or contains strings.
            Defaults to False.

    Returns:
        PlayHandle: An object representing the playback handle. This can be
        awaited or stopped manually.
    &#34;&#34;&#34;  # noqa: E501
    if not self._mixer_atask:
        raise RuntimeError(&#34;BackgroundAudio is not started&#34;)

    normalized = self._normalize_sound_source(audio)
    if normalized is None:
        play_handle = PlayHandle()
        play_handle._mark_playout_done()
        return play_handle

    sound_source, volume = normalized

    if loop and isinstance(sound_source, AsyncIterator):
        raise ValueError(
            &#34;Looping sound via AsyncIterator is not supported. Use a string file path or your own &#39;infinite&#39; AsyncIterator with loop=False&#34;  # noqa: E501
        )

    play_handle = PlayHandle()
    task = asyncio.create_task(self._play_task(play_handle, sound_source, volume, loop))
    task.add_done_callback(lambda _: self._play_tasks.remove(task))
    task.add_done_callback(lambda _: play_handle._mark_playout_done())
    self._play_tasks.append(task)
    return play_handle</code></pre>
</details>
<div class="desc"><p>Plays an audio once or in a loop.</p>
<h2 id="args">Args</h2>
<p>audio (Union[AudioSource, AudioConfig, List[AudioConfig]]):
The audio to play. Can be:
- A string pointing to a file path
- An AsyncIterator that yields <code>rtc.AudioFrame</code>
- An AudioConfig object with volume and probability
- A list of AudioConfig objects, where one will be selected based on probability</p>
<pre><code>If a string is provided and &lt;code&gt;loop&lt;/code&gt; is True, the sound will be looped.
If an AsyncIterator is provided, it is played until exhaustion (and cannot be looped
automatically).
</code></pre>
<p>loop (bool, optional):
Whether to loop the audio. Only applicable if <code>audio</code> is a string or contains strings.
Defaults to False.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PlayHandle</code></dt>
<dd>An object representing the playback handle. This can be</dd>
</dl>
<p>awaited or stopped manually.</p></div>
</dd>
<dt id="livekit.agents.BackgroundAudioPlayer.start"><code class="name flex">
<span>async def <span class="ident">start</span></span>(<span>self,<br>*,<br>room: rtc.Room,<br>agent_session: NotGivenOr[<a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a>] = NOT_GIVEN,<br>track_publish_options: NotGivenOr[rtc.TrackPublishOptions] = NOT_GIVEN) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start(
    self,
    *,
    room: rtc.Room,
    agent_session: NotGivenOr[AgentSession] = NOT_GIVEN,
    track_publish_options: NotGivenOr[rtc.TrackPublishOptions] = NOT_GIVEN,
) -&gt; None:
    &#34;&#34;&#34;
    Starts the background audio system, publishing the audio track
    and beginning playback of any configured ambient sound.

    If `ambient_sound` is provided (and contains file paths), they will loop
    automatically. If `ambient_sound` contains AsyncIterators, they are assumed
    to be already infinite or looped.

    Args:
        room (rtc.Room):
            The LiveKit Room object where the audio track will be published.
        agent_session (NotGivenOr[AgentSession], optional):
            The session object used to track the agent&#39;s state (e.g., &#34;thinking&#34;).
            Required if `thinking_sound` is provided.
        track_publish_options (NotGivenOr[rtc.TrackPublishOptions], optional):
            Options used when publishing the audio track. If not given, defaults will
            be used.
    &#34;&#34;&#34;
    async with self._lock:
        self._room = room
        self._agent_session = agent_session or None
        self._track_publish_options = track_publish_options or None

        if cli.CLI_ARGUMENTS is not None and cli.CLI_ARGUMENTS.console:
            logger.warning(
                &#34;Background audio is not supported in console mode. Audio will not be played.&#34;
            )

        await self._publish_track()

        self._mixer_atask = asyncio.create_task(self._run_mixer_task())
        self._room.on(&#34;reconnected&#34;, self._on_reconnected)

        if self._agent_session:
            self._agent_session.on(&#34;agent_state_changed&#34;, self._agent_state_changed)

        if self._ambient_sound:
            normalized = self._normalize_sound_source(self._ambient_sound)
            if normalized:
                sound_source, volume = normalized
                selected_sound = AudioConfig(sound_source, volume)
                if isinstance(sound_source, str):
                    self._ambient_handle = self.play(selected_sound, loop=True)
                else:
                    self._ambient_handle = self.play(selected_sound)</code></pre>
</details>
<div class="desc"><p>Starts the background audio system, publishing the audio track
and beginning playback of any configured ambient sound.</p>
<p>If <code>ambient_sound</code> is provided (and contains file paths), they will loop
automatically. If <code>ambient_sound</code> contains AsyncIterators, they are assumed
to be already infinite or looped.</p>
<h2 id="args">Args</h2>
<p>room (rtc.Room):
The LiveKit Room object where the audio track will be published.
agent_session (NotGivenOr[AgentSession], optional):
The session object used to track the agent's state (e.g., "thinking").
Required if <code>thinking_sound</code> is provided.
track_publish_options (NotGivenOr[rtc.TrackPublishOptions], optional):
Options used when publishing the audio track. If not given, defaults will
be used.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.BuiltinAudioClip"><code class="flex name class">
<span>class <span class="ident">BuiltinAudioClip</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BuiltinAudioClip(enum.Enum):
    OFFICE_AMBIENCE = &#34;office-ambience.ogg&#34;
    KEYBOARD_TYPING = &#34;keyboard-typing.ogg&#34;
    KEYBOARD_TYPING2 = &#34;keyboard-typing2.ogg&#34;

    def path(self) -&gt; str:
        file_path = files(&#34;livekit.agents.resources&#34;) / self.value
        return str(_resource_stack.enter_context(as_file(file_path)))</code></pre>
</details>
<div class="desc"><p>Create a collection of name/value pairs.</p>
<p>Example enumeration:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     BLUE = 2
...     GREEN = 3
</code></pre>
<p>Access them by:</p>
<ul>
<li>attribute access:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color.RED
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>value lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color(1)
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>name lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color['RED']
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<p>Enumerations can be iterated over, and know how many members they have:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len(Color)
3
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</code></pre>
<p>Methods can be added to enumerations, and members can have their own
attributes &ndash; see the documentation for details.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.BuiltinAudioClip.KEYBOARD_TYPING"><code class="name">var <span class="ident">KEYBOARD_TYPING</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.BuiltinAudioClip.KEYBOARD_TYPING2"><code class="name">var <span class="ident">KEYBOARD_TYPING2</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.BuiltinAudioClip.OFFICE_AMBIENCE"><code class="name">var <span class="ident">OFFICE_AMBIENCE</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.BuiltinAudioClip.path"><code class="name flex">
<span>def <span class="ident">path</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path(self) -&gt; str:
    file_path = files(&#34;livekit.agents.resources&#34;) / self.value
    return str(_resource_stack.enter_context(as_file(file_path)))</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.ChatContext"><code class="flex name class">
<span>class <span class="ident">ChatContext</span></span>
<span>(</span><span>items: NotGivenOr[list[ChatItem]] = NOT_GIVEN)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChatContext:
    def __init__(self, items: NotGivenOr[list[ChatItem]] = NOT_GIVEN):
        self._items: list[ChatItem] = items if is_given(items) else []

    @classmethod
    def empty(cls) -&gt; ChatContext:
        return cls([])

    @property
    def items(self) -&gt; list[ChatItem]:
        return self._items

    @items.setter
    def items(self, items: list[ChatItem]):
        self._items = items

    def add_message(
        self,
        *,
        role: ChatRole,
        content: list[ChatContent] | str,
        id: NotGivenOr[str] = NOT_GIVEN,
        interrupted: NotGivenOr[bool] = NOT_GIVEN,
        created_at: NotGivenOr[float] = NOT_GIVEN,
    ) -&gt; ChatMessage:
        kwargs = {}
        if is_given(id):
            kwargs[&#34;id&#34;] = id
        if is_given(interrupted):
            kwargs[&#34;interrupted&#34;] = interrupted
        if is_given(created_at):
            kwargs[&#34;created_at&#34;] = created_at

        if isinstance(content, str):
            message = ChatMessage(role=role, content=[content], **kwargs)
        else:
            message = ChatMessage(role=role, content=content, **kwargs)

        self._items.append(message)
        return message

    def get_by_id(self, item_id: str) -&gt; ChatItem | None:
        return next((item for item in self.items if item.id == item_id), None)

    def index_by_id(self, item_id: str) -&gt; int | None:
        return next((i for i, item in enumerate(self.items) if item.id == item_id), None)

    def copy(
        self,
        *,
        exclude_function_call: bool = False,
        exclude_instructions: bool = False,
        tools: NotGivenOr[list[FunctionTool | RawFunctionTool | str | Any]] = NOT_GIVEN,
    ) -&gt; ChatContext:
        items = []

        from .tool_context import (
            get_function_info,
            get_raw_function_info,
            is_function_tool,
            is_raw_function_tool,
        )

        valid_tools = set()
        if is_given(tools):
            for tool in tools:
                if isinstance(tool, str):
                    valid_tools.add(tool)
                elif is_function_tool(tool):
                    valid_tools.add(get_function_info(tool).name)
                elif is_raw_function_tool(tool):
                    valid_tools.add(get_raw_function_info(tool).name)
                # TODO(theomonnom): other tools

        for item in self.items:
            if exclude_function_call and item.type in [
                &#34;function_call&#34;,
                &#34;function_call_output&#34;,
            ]:
                continue

            if (
                exclude_instructions
                and item.type == &#34;message&#34;
                and item.role in [&#34;system&#34;, &#34;developer&#34;]
            ):
                continue

            if (
                is_given(tools)
                and item.type in [&#34;function_call&#34;, &#34;function_call_output&#34;]
                and item.name not in valid_tools
            ):
                continue

            items.append(item)

        return ChatContext(items)

    def truncate(self, *, max_items: int) -&gt; ChatContext:
        &#34;&#34;&#34;Truncate the chat context to the last N items in place.

        Removes leading function calls to avoid partial function outputs.
        Preserves the first system message by adding it back to the beginning.
        &#34;&#34;&#34;
        instructions = next(
            (item for item in self._items if item.type == &#34;message&#34; and item.role == &#34;system&#34;),
            None,
        )

        new_items = self._items[-max_items:]
        # chat ctx shouldn&#39;t start with function_call or function_call_output
        while new_items and new_items[0].type in [
            &#34;function_call&#34;,
            &#34;function_call_output&#34;,
        ]:
            new_items.pop(0)

        if instructions:
            new_items.insert(0, instructions)

        self._items[:] = new_items
        return self

    def to_dict(
        self,
        *,
        exclude_image: bool = True,
        exclude_audio: bool = True,
        exclude_timestamp: bool = True,
        exclude_function_call: bool = False,
    ) -&gt; dict:
        items = []
        for item in self.items:
            if exclude_function_call and item.type in [
                &#34;function_call&#34;,
                &#34;function_call_output&#34;,
            ]:
                continue

            if item.type == &#34;message&#34;:
                item = item.model_copy()
                if exclude_image:
                    item.content = [c for c in item.content if not isinstance(c, ImageContent)]
                if exclude_audio:
                    item.content = [c for c in item.content if not isinstance(c, AudioContent)]

            items.append(item)

        exclude_fields = set()
        if exclude_timestamp:
            exclude_fields.add(&#34;created_at&#34;)

        return {
            &#34;items&#34;: [
                item.model_dump(
                    mode=&#34;json&#34;,
                    exclude_none=True,
                    exclude_defaults=False,
                    exclude=exclude_fields,
                )
                for item in items
            ],
        }

    def find_insertion_index(self, *, created_at: float) -&gt; int:
        &#34;&#34;&#34;
        Returns the index to insert an item by creation time.

        Iterates in reverse, assuming items are sorted by `created_at`.
        Finds the position after the last item with `created_at &lt;=` the given timestamp.
        &#34;&#34;&#34;
        for i in reversed(range(len(self._items))):
            item = self._items[i]
            if item.type == &#34;message&#34; and item.created_at &lt;= created_at:
                return i + 1

        return 0

    @classmethod
    def from_dict(cls, data: dict) -&gt; ChatContext:
        item_adapter = TypeAdapter(list[ChatItem])
        items = item_adapter.validate_python(data[&#34;items&#34;])
        return cls(items)

    @property
    def readonly(self) -&gt; bool:
        return False</code></pre>
</details>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li>livekit.agents.llm.chat_context._ReadOnlyChatContext</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="livekit.agents.ChatContext.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="livekit.agents.llm.chat_context.ChatContext" href="llm/chat_context.html#livekit.agents.llm.chat_context.ChatContext">ChatContext</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.ChatContext.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict) ‑> <a title="livekit.agents.llm.chat_context.ChatContext" href="llm/chat_context.html#livekit.agents.llm.chat_context.ChatContext">ChatContext</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.ChatContext.items"><code class="name">prop <span class="ident">items</span> : list[ChatItem]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def items(self) -&gt; list[ChatItem]:
    return self._items</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.ChatContext.readonly"><code class="name">prop <span class="ident">readonly</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def readonly(self) -&gt; bool:
    return False</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.ChatContext.add_message"><code class="name flex">
<span>def <span class="ident">add_message</span></span>(<span>self,<br>*,<br>role: ChatRole,<br>content: list[ChatContent] | str,<br>id: NotGivenOr[str] = NOT_GIVEN,<br>interrupted: NotGivenOr[bool] = NOT_GIVEN,<br>created_at: NotGivenOr[float] = NOT_GIVEN) ‑> <a title="livekit.agents.llm.chat_context.ChatMessage" href="llm/chat_context.html#livekit.agents.llm.chat_context.ChatMessage">ChatMessage</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_message(
    self,
    *,
    role: ChatRole,
    content: list[ChatContent] | str,
    id: NotGivenOr[str] = NOT_GIVEN,
    interrupted: NotGivenOr[bool] = NOT_GIVEN,
    created_at: NotGivenOr[float] = NOT_GIVEN,
) -&gt; ChatMessage:
    kwargs = {}
    if is_given(id):
        kwargs[&#34;id&#34;] = id
    if is_given(interrupted):
        kwargs[&#34;interrupted&#34;] = interrupted
    if is_given(created_at):
        kwargs[&#34;created_at&#34;] = created_at

    if isinstance(content, str):
        message = ChatMessage(role=role, content=[content], **kwargs)
    else:
        message = ChatMessage(role=role, content=content, **kwargs)

    self._items.append(message)
    return message</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.ChatContext.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self,<br>*,<br>exclude_function_call: bool = False,<br>exclude_instructions: bool = False,<br>tools: NotGivenOr[list[<a title="livekit.agents.FunctionTool" href="#livekit.agents.FunctionTool">FunctionTool</a> | RawFunctionTool | str | Any]] = NOT_GIVEN) ‑> <a title="livekit.agents.ChatContext" href="#livekit.agents.ChatContext">ChatContext</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(
    self,
    *,
    exclude_function_call: bool = False,
    exclude_instructions: bool = False,
    tools: NotGivenOr[list[FunctionTool | RawFunctionTool | str | Any]] = NOT_GIVEN,
) -&gt; ChatContext:
    items = []

    from .tool_context import (
        get_function_info,
        get_raw_function_info,
        is_function_tool,
        is_raw_function_tool,
    )

    valid_tools = set()
    if is_given(tools):
        for tool in tools:
            if isinstance(tool, str):
                valid_tools.add(tool)
            elif is_function_tool(tool):
                valid_tools.add(get_function_info(tool).name)
            elif is_raw_function_tool(tool):
                valid_tools.add(get_raw_function_info(tool).name)
            # TODO(theomonnom): other tools

    for item in self.items:
        if exclude_function_call and item.type in [
            &#34;function_call&#34;,
            &#34;function_call_output&#34;,
        ]:
            continue

        if (
            exclude_instructions
            and item.type == &#34;message&#34;
            and item.role in [&#34;system&#34;, &#34;developer&#34;]
        ):
            continue

        if (
            is_given(tools)
            and item.type in [&#34;function_call&#34;, &#34;function_call_output&#34;]
            and item.name not in valid_tools
        ):
            continue

        items.append(item)

    return ChatContext(items)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.ChatContext.find_insertion_index"><code class="name flex">
<span>def <span class="ident">find_insertion_index</span></span>(<span>self, *, created_at: float) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_insertion_index(self, *, created_at: float) -&gt; int:
    &#34;&#34;&#34;
    Returns the index to insert an item by creation time.

    Iterates in reverse, assuming items are sorted by `created_at`.
    Finds the position after the last item with `created_at &lt;=` the given timestamp.
    &#34;&#34;&#34;
    for i in reversed(range(len(self._items))):
        item = self._items[i]
        if item.type == &#34;message&#34; and item.created_at &lt;= created_at:
            return i + 1

    return 0</code></pre>
</details>
<div class="desc"><p>Returns the index to insert an item by creation time.</p>
<p>Iterates in reverse, assuming items are sorted by <code>created_at</code>.
Finds the position after the last item with <code>created_at &lt;=</code> the given timestamp.</p></div>
</dd>
<dt id="livekit.agents.ChatContext.get_by_id"><code class="name flex">
<span>def <span class="ident">get_by_id</span></span>(<span>self, item_id: str) ‑> <a title="livekit.agents.llm.chat_context.ChatMessage" href="llm/chat_context.html#livekit.agents.llm.chat_context.ChatMessage">ChatMessage</a> | <a title="livekit.agents.llm.chat_context.FunctionCall" href="llm/chat_context.html#livekit.agents.llm.chat_context.FunctionCall">FunctionCall</a> | <a title="livekit.agents.llm.chat_context.FunctionCallOutput" href="llm/chat_context.html#livekit.agents.llm.chat_context.FunctionCallOutput">FunctionCallOutput</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_id(self, item_id: str) -&gt; ChatItem | None:
    return next((item for item in self.items if item.id == item_id), None)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.ChatContext.index_by_id"><code class="name flex">
<span>def <span class="ident">index_by_id</span></span>(<span>self, item_id: str) ‑> int | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_by_id(self, item_id: str) -&gt; int | None:
    return next((i for i, item in enumerate(self.items) if item.id == item_id), None)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.ChatContext.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self,<br>*,<br>exclude_image: bool = True,<br>exclude_audio: bool = True,<br>exclude_timestamp: bool = True,<br>exclude_function_call: bool = False) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(
    self,
    *,
    exclude_image: bool = True,
    exclude_audio: bool = True,
    exclude_timestamp: bool = True,
    exclude_function_call: bool = False,
) -&gt; dict:
    items = []
    for item in self.items:
        if exclude_function_call and item.type in [
            &#34;function_call&#34;,
            &#34;function_call_output&#34;,
        ]:
            continue

        if item.type == &#34;message&#34;:
            item = item.model_copy()
            if exclude_image:
                item.content = [c for c in item.content if not isinstance(c, ImageContent)]
            if exclude_audio:
                item.content = [c for c in item.content if not isinstance(c, AudioContent)]

        items.append(item)

    exclude_fields = set()
    if exclude_timestamp:
        exclude_fields.add(&#34;created_at&#34;)

    return {
        &#34;items&#34;: [
            item.model_dump(
                mode=&#34;json&#34;,
                exclude_none=True,
                exclude_defaults=False,
                exclude=exclude_fields,
            )
            for item in items
        ],
    }</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.ChatContext.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *, max_items: int) ‑> <a title="livekit.agents.llm.chat_context.ChatContext" href="llm/chat_context.html#livekit.agents.llm.chat_context.ChatContext">ChatContext</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def truncate(self, *, max_items: int) -&gt; ChatContext:
    &#34;&#34;&#34;Truncate the chat context to the last N items in place.

    Removes leading function calls to avoid partial function outputs.
    Preserves the first system message by adding it back to the beginning.
    &#34;&#34;&#34;
    instructions = next(
        (item for item in self._items if item.type == &#34;message&#34; and item.role == &#34;system&#34;),
        None,
    )

    new_items = self._items[-max_items:]
    # chat ctx shouldn&#39;t start with function_call or function_call_output
    while new_items and new_items[0].type in [
        &#34;function_call&#34;,
        &#34;function_call_output&#34;,
    ]:
        new_items.pop(0)

    if instructions:
        new_items.insert(0, instructions)

    self._items[:] = new_items
    return self</code></pre>
</details>
<div class="desc"><p>Truncate the chat context to the last N items in place.</p>
<p>Removes leading function calls to avoid partial function outputs.
Preserves the first system message by adding it back to the beginning.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.ChatMessage"><code class="flex name class">
<span>class <span class="ident">ChatMessage</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChatMessage(BaseModel):
    id: str = Field(default_factory=lambda: utils.shortuuid(&#34;item_&#34;))
    type: Literal[&#34;message&#34;] = &#34;message&#34;
    role: ChatRole
    content: list[ChatContent]
    interrupted: bool = False
    hash: bytes | None = None
    created_at: float = Field(default_factory=time.time)

    @property
    def text_content(self) -&gt; str | None:
        &#34;&#34;&#34;
        Returns a string of all text content in the message.

        Multiple text content items will be joined by a newline.
        &#34;&#34;&#34;
        text_parts = [c for c in self.content if isinstance(c, str)]
        if not text_parts:
            return None
        return &#34;\n&#34;.join(text_parts)</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.ChatMessage.content"><code class="name">var <span class="ident">content</span> : list[<a title="livekit.agents.llm.chat_context.ImageContent" href="llm/chat_context.html#livekit.agents.llm.chat_context.ImageContent">ImageContent</a> | <a title="livekit.agents.llm.chat_context.AudioContent" href="llm/chat_context.html#livekit.agents.llm.chat_context.AudioContent">AudioContent</a> | str]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.ChatMessage.created_at"><code class="name">var <span class="ident">created_at</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.ChatMessage.hash"><code class="name">var <span class="ident">hash</span> : bytes | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.ChatMessage.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.ChatMessage.interrupted"><code class="name">var <span class="ident">interrupted</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.ChatMessage.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.ChatMessage.role"><code class="name">var <span class="ident">role</span> : Literal['developer', 'system', 'user', 'assistant']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.ChatMessage.type"><code class="name">var <span class="ident">type</span> : Literal['message']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.ChatMessage.text_content"><code class="name">prop <span class="ident">text_content</span> : str | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text_content(self) -&gt; str | None:
    &#34;&#34;&#34;
    Returns a string of all text content in the message.

    Multiple text content items will be joined by a newline.
    &#34;&#34;&#34;
    text_parts = [c for c in self.content if isinstance(c, str)]
    if not text_parts:
        return None
    return &#34;\n&#34;.join(text_parts)</code></pre>
</details>
<div class="desc"><p>Returns a string of all text content in the message.</p>
<p>Multiple text content items will be joined by a newline.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.CloseEvent"><code class="flex name class">
<span>class <span class="ident">CloseEvent</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CloseEvent(BaseModel):
    type: Literal[&#34;close&#34;] = &#34;close&#34;
    error: LLMError | STTError | TTSError | RealtimeModelError | None = None</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.CloseEvent.error"><code class="name">var <span class="ident">error</span> : <a title="livekit.agents.llm.llm.LLMError" href="llm/llm.html#livekit.agents.llm.llm.LLMError">LLMError</a> | <a title="livekit.agents.stt.stt.STTError" href="stt/stt.html#livekit.agents.stt.stt.STTError">STTError</a> | <a title="livekit.agents.tts.tts.TTSError" href="tts/tts.html#livekit.agents.tts.tts.TTSError">TTSError</a> | <a title="livekit.agents.llm.realtime.RealtimeModelError" href="llm/realtime.html#livekit.agents.llm.realtime.RealtimeModelError">RealtimeModelError</a> | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.CloseEvent.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.CloseEvent.type"><code class="name">var <span class="ident">type</span> : Literal['close']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.ConversationItemAddedEvent"><code class="flex name class">
<span>class <span class="ident">ConversationItemAddedEvent</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConversationItemAddedEvent(BaseModel):
    type: Literal[&#34;conversation_item_added&#34;] = &#34;conversation_item_added&#34;
    item: ChatMessage | _TypeDiscriminator</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.ConversationItemAddedEvent.item"><code class="name">var <span class="ident">item</span> : <a title="livekit.agents.llm.chat_context.ChatMessage" href="llm/chat_context.html#livekit.agents.llm.chat_context.ChatMessage">ChatMessage</a> | livekit.agents.voice.events._TypeDiscriminator</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.ConversationItemAddedEvent.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.ConversationItemAddedEvent.type"><code class="name">var <span class="ident">type</span> : Literal['conversation_item_added']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.ErrorEvent"><code class="flex name class">
<span>class <span class="ident">ErrorEvent</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ErrorEvent(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)
    type: Literal[&#34;error&#34;] = &#34;error&#34;
    error: LLMError | STTError | TTSError | RealtimeModelError | Any
    source: LLM | STT | TTS | RealtimeModel | Any</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.ErrorEvent.error"><code class="name">var <span class="ident">error</span> : <a title="livekit.agents.llm.llm.LLMError" href="llm/llm.html#livekit.agents.llm.llm.LLMError">LLMError</a> | <a title="livekit.agents.stt.stt.STTError" href="stt/stt.html#livekit.agents.stt.stt.STTError">STTError</a> | <a title="livekit.agents.tts.tts.TTSError" href="tts/tts.html#livekit.agents.tts.tts.TTSError">TTSError</a> | <a title="livekit.agents.llm.realtime.RealtimeModelError" href="llm/realtime.html#livekit.agents.llm.realtime.RealtimeModelError">RealtimeModelError</a> | typing.Any</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.ErrorEvent.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.ErrorEvent.source"><code class="name">var <span class="ident">source</span> : <a title="livekit.agents.llm.llm.LLM" href="llm/llm.html#livekit.agents.llm.llm.LLM">LLM</a> | <a title="livekit.agents.stt.stt.STT" href="stt/stt.html#livekit.agents.stt.stt.STT">STT</a> | <a title="livekit.agents.tts.tts.TTS" href="tts/tts.html#livekit.agents.tts.tts.TTS">TTS</a> | <a title="livekit.agents.llm.realtime.RealtimeModel" href="llm/realtime.html#livekit.agents.llm.realtime.RealtimeModel">RealtimeModel</a> | typing.Any</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.ErrorEvent.type"><code class="name">var <span class="ident">type</span> : Literal['error']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.FunctionCall"><code class="flex name class">
<span>class <span class="ident">FunctionCall</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FunctionCall(BaseModel):
    id: str = Field(default_factory=lambda: utils.shortuuid(&#34;item_&#34;))
    type: Literal[&#34;function_call&#34;] = &#34;function_call&#34;
    call_id: str
    arguments: str
    name: str</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.FunctionCall.arguments"><code class="name">var <span class="ident">arguments</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.FunctionCall.call_id"><code class="name">var <span class="ident">call_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.FunctionCall.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.FunctionCall.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.FunctionCall.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.FunctionCall.type"><code class="name">var <span class="ident">type</span> : Literal['function_call']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.FunctionCallOutput"><code class="flex name class">
<span>class <span class="ident">FunctionCallOutput</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FunctionCallOutput(BaseModel):
    id: str = Field(default_factory=lambda: utils.shortuuid(&#34;item_&#34;))
    name: str = Field(default=&#34;&#34;)
    type: Literal[&#34;function_call_output&#34;] = Field(default=&#34;function_call_output&#34;)
    call_id: str
    output: str
    is_error: bool</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.FunctionCallOutput.call_id"><code class="name">var <span class="ident">call_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.FunctionCallOutput.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.FunctionCallOutput.is_error"><code class="name">var <span class="ident">is_error</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.FunctionCallOutput.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.FunctionCallOutput.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.FunctionCallOutput.output"><code class="name">var <span class="ident">output</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.FunctionCallOutput.type"><code class="name">var <span class="ident">type</span> : Literal['function_call_output']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.FunctionTool"><code class="flex name class">
<span>class <span class="ident">FunctionTool</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@runtime_checkable
class FunctionTool(Protocol):
    __livekit_tool_info: _FunctionToolInfo

    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any: ...</code></pre>
</details>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing).</p>
<p>For example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto[T](Protocol):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="livekit.agents.JobContext"><code class="flex name class">
<span>class <span class="ident">JobContext</span></span>
<span>(</span><span>*,<br>proc: <a title="livekit.agents.JobProcess" href="#livekit.agents.JobProcess">JobProcess</a>,<br>info: RunningJobInfo,<br>room: rtc.Room,<br>on_connect: Callable[[], None],<br>on_shutdown: Callable[[str], None],<br>inference_executor: InferenceExecutor)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JobContext:
    # private ctor
    def __init__(
        self,
        *,
        proc: JobProcess,
        info: RunningJobInfo,
        room: rtc.Room,
        on_connect: Callable[[], None],
        on_shutdown: Callable[[str], None],
        inference_executor: InferenceExecutor,
    ) -&gt; None:
        self._proc = proc
        self._info = info
        self._room = room
        self._on_connect = on_connect
        self._on_shutdown = on_shutdown
        self._shutdown_callbacks: list[Callable[[str], Coroutine[None, None, None]]] = []
        self._tracing_callbacks: list[Callable[[], Coroutine[None, None, None]]] = []
        self._participant_entrypoints: list[
            tuple[
                Callable[[JobContext, rtc.RemoteParticipant], Coroutine[None, None, None]],
                list[rtc.ParticipantKind.ValueType] | rtc.ParticipantKind.ValueType,
            ]
        ] = []
        self._participant_tasks = dict[tuple[str, Callable], asyncio.Task[None]]()
        self._pending_tasks = list[asyncio.Task]()
        self._room.on(&#34;participant_connected&#34;, self._participant_available)
        self._inf_executor = inference_executor

        self._init_log_factory()
        self._log_fields = {}

    def _init_log_factory(self) -&gt; None:
        old_factory = logging.getLogRecordFactory()

        def record_factory(*args, **kwargs) -&gt; logging.LogRecord:
            record = old_factory(*args, **kwargs)

            if self.proc.executor_type != JobExecutorType.PROCESS:
                try:
                    ctx = get_job_context()
                except RuntimeError:
                    return record
                else:
                    if ctx != self:
                        return record

            for key, value in self._log_fields.items():
                setattr(record, key, value)

            return record

        logging.setLogRecordFactory(record_factory)

    @property
    def inference_executor(self) -&gt; InferenceExecutor:
        return self._inf_executor

    @functools.cached_property
    def api(self) -&gt; api.LiveKitAPI:
        return api.LiveKitAPI(session=http_context.http_session())

    @property
    def proc(self) -&gt; JobProcess:
        &#34;&#34;&#34;Returns the process running the job. Useful for storing process-specific state.&#34;&#34;&#34;
        return self._proc

    @property
    def job(self) -&gt; agent.Job:
        &#34;&#34;&#34;Returns the current job that the worker is executing.&#34;&#34;&#34;
        return self._info.job

    @property
    def worker_id(self) -&gt; str:
        &#34;&#34;&#34;Returns the id of the worker.&#34;&#34;&#34;
        return self._info.worker_id

    @property
    def room(self) -&gt; rtc.Room:
        &#34;&#34;&#34;The Room object is the main interface that the worker should interact with.

        When the entrypoint is called, the worker has not connected to the Room yet.
        Certain properties of Room would not be available before calling JobContext.connect()
        &#34;&#34;&#34;
        return self._room

    @property
    def agent(self) -&gt; rtc.LocalParticipant:
        return self._room.local_participant

    @property
    def log_context_fields(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;
        Returns the current dictionary of log fields that will be injected into log records.

        These fields enable enriched structured logging and can include job metadata,
        worker ID, trace IDs, or other diagnostic context.

        The returned dictionary can be directly edited, or entirely replaced via assignment
        (e.g., `job_context.log_context_fields = {...}`)
        &#34;&#34;&#34;
        return self._log_fields

    @log_context_fields.setter
    def log_context_fields(self, fields: dict[str, Any]) -&gt; None:
        &#34;&#34;&#34;
        Sets the log fields to be injected into future log records.

        Args:
            fields (dict[str, Any]): A dictionary of key-value pairs representing
                structured data to attach to each log entry. Typically includes contextual
                information like job ID, trace information, or worker metadata.
        &#34;&#34;&#34;
        self._log_fields = fields

    def add_tracing_callback(
        self,
        callback: Callable[[], Coroutine[None, None, None]],
    ) -&gt; None:
        &#34;&#34;&#34;
        Add a callback to be called when the job is about to receive a new tracing request.
        &#34;&#34;&#34;
        self._tracing_callbacks.append(callback)

    def add_shutdown_callback(
        self,
        callback: Callable[[], Coroutine[None, None, None]]
        | Callable[[str], Coroutine[None, None, None]],
    ) -&gt; None:
        &#34;&#34;&#34;
        Add a callback to be called when the job is shutting down.
        Optionally the callback can take a single argument, the shutdown reason.
        &#34;&#34;&#34;
        if callback.__code__.co_argcount &gt; 0:
            self._shutdown_callbacks.append(callback)  # type: ignore
        else:

            async def wrapper(_: str) -&gt; None:
                await callback()  # type: ignore

            self._shutdown_callbacks.append(wrapper)

    async def wait_for_participant(
        self,
        *,
        identity: str | None = None,
        kind: list[rtc.ParticipantKind.ValueType]
        | rtc.ParticipantKind.ValueType = DEFAULT_PARTICIPANT_KINDS,
    ) -&gt; rtc.RemoteParticipant:
        &#34;&#34;&#34;
        Returns a participant that matches the given identity. If identity is None, the first
        participant that joins the room will be returned.
        If the participant has already joined, the function will return immediately.
        &#34;&#34;&#34;
        return await wait_for_participant(self._room, identity=identity, kind=kind)

    async def connect(
        self,
        *,
        e2ee: rtc.E2EEOptions | None = None,
        auto_subscribe: AutoSubscribe = AutoSubscribe.SUBSCRIBE_ALL,
        rtc_config: rtc.RtcConfiguration | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Connect to the room. This method should be called only once.

        Args:
            e2ee: End-to-end encryption options. If provided, the Agent will utilize end-to-end encryption. Note: clients will also need to handle E2EE.
            auto_subscribe: Whether to automatically subscribe to tracks. Default is AutoSubscribe.SUBSCRIBE_ALL.
            rtc_config: Custom RTC configuration to use when connecting to the room.
        &#34;&#34;&#34;  # noqa: E501
        room_options = rtc.RoomOptions(
            e2ee=e2ee,
            auto_subscribe=auto_subscribe == AutoSubscribe.SUBSCRIBE_ALL,
            rtc_config=rtc_config,
        )

        await self._room.connect(self._info.url, self._info.token, options=room_options)
        self._on_connect()
        for p in self._room.remote_participants.values():
            self._participant_available(p)

        _apply_auto_subscribe_opts(self._room, auto_subscribe)

    def delete_room(self) -&gt; asyncio.Future[api.DeleteRoomResponse]:
        &#34;&#34;&#34;Deletes the room and disconnects all participants.&#34;&#34;&#34;
        task = asyncio.create_task(
            self.api.room.delete_room(api.DeleteRoomRequest(room=self._room.name))
        )
        self._pending_tasks.append(task)
        task.add_done_callback(lambda _: self._pending_tasks.remove(task))
        return task

    def add_sip_participant(
        self,
        *,
        call_to: str,
        trunk_id: str,
        participant_identity: str,
        participant_name: str | NotGivenOr[str] = &#34;SIP-participant&#34;,
    ) -&gt; asyncio.Future[api.SIPParticipantInfo]:
        &#34;&#34;&#34;
        Add a SIP participant to the room.

        Args:
            call_to: The number or SIP destination to transfer the participant to.
                         This can either be a number (+12345555555) or a
                         sip host (sip:&lt;user&gt;@&lt;host&gt;)
            trunk_id: The ID of the SIP trunk to use
            participant_identity: The identity of the participant to add
            participant_name: The name of the participant to add

        Make sure you have an outbound SIP trunk created in LiveKit.
        See https://docs.livekit.io/sip/trunk-outbound/ for more information.
        &#34;&#34;&#34;
        task = asyncio.create_task(
            self.api.sip.create_sip_participant(
                api.CreateSIPParticipantRequest(
                    room_name=self._room.name,
                    participant_identity=participant_identity,
                    sip_trunk_id=trunk_id,
                    sip_call_to=call_to,
                    participant_name=participant_name,
                )
            ),
        )
        self._pending_tasks.append(task)
        task.add_done_callback(lambda _: self._pending_tasks.remove(task))
        return task

    def transfer_sip_participant(
        self,
        participant: rtc.RemoteParticipant | str,
        transfer_to: str,
        play_dialtone: bool = False,
    ) -&gt; asyncio.Future[api.SIPParticipantInfo]:
        &#34;&#34;&#34;Transfer a SIP participant to another number.

        Args:
            participant: The participant to transfer
            transfer_to: The number or SIP destination to transfer the participant to.
                         This can either be a number (+12345555555) or a
                         sip host (sip:&lt;user&gt;@&lt;host&gt;)
            play_dialtone: Whether to play a dialtone during transfer. Defaults to True.


        Returns:
            Future that completes when the transfer is complete

        Make sure you have enabled call transfer on your provider SIP trunk.
        See https://docs.livekit.io/sip/transfer-cold/ for more information.
        &#34;&#34;&#34;
        assert participant.kind == rtc.ParticipantKind.PARTICIPANT_KIND_SIP, (
            &#34;Participant must be a SIP participant&#34;
        )
        task = asyncio.create_task(
            self.api.sip.transfer_sip_participant(
                api.TransferSIPParticipantRequest(
                    room_name=self._room.name,
                    participant_identity=participant.identity,
                    transfer_to=transfer_to,
                    play_dialtone=play_dialtone,
                )
            ),
        )
        self._pending_tasks.append(task)
        task.add_done_callback(lambda _: self._pending_tasks.remove(task))
        return task

    def shutdown(self, reason: str = &#34;&#34;) -&gt; None:
        self._on_shutdown(reason)

    def add_participant_entrypoint(
        self,
        entrypoint_fnc: Callable[[JobContext, rtc.RemoteParticipant], Coroutine[None, None, None]],
        *_,
        kind: list[rtc.ParticipantKind.ValueType]
        | rtc.ParticipantKind.ValueType = DEFAULT_PARTICIPANT_KINDS,
    ):
        &#34;&#34;&#34;Adds an entrypoint function to be run when a participant joins the room. In cases where
        the participant has already joined, the entrypoint will be run immediately. Multiple unique entrypoints can be
        added and they will each be run in parallel for each participant.
        &#34;&#34;&#34;  # noqa: E501

        if entrypoint_fnc in [e for (e, _) in self._participant_entrypoints]:
            raise ValueError(&#34;entrypoints cannot be added more than once&#34;)

        self._participant_entrypoints.append((entrypoint_fnc, kind))

    def _participant_available(self, p: rtc.RemoteParticipant) -&gt; None:
        for coro, kind in self._participant_entrypoints:
            if isinstance(kind, list):
                if p.kind not in kind:
                    continue
            else:
                if p.kind != kind:
                    continue

            if (p.identity, coro) in self._participant_tasks:
                logger.warning(
                    f&#34;a participant has joined before a prior participant task matching the same identity has finished: &#39;{p.identity}&#39;&#34;  # noqa: E501
                )
            task_name = f&#34;part-entry-{p.identity}-{coro.__name__}&#34;
            task = asyncio.create_task(coro(self, p), name=task_name)
            self._participant_tasks[(p.identity, coro)] = task
            task.add_done_callback(
                lambda _, coro=coro: self._participant_tasks.pop((p.identity, coro))
            )</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.JobContext.agent"><code class="name">prop <span class="ident">agent</span> : rtc.LocalParticipant</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def agent(self) -&gt; rtc.LocalParticipant:
    return self._room.local_participant</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.JobContext.api"><code class="name">var <span class="ident">api</span> : api.LiveKitAPI</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@functools.cached_property
def api(self) -&gt; api.LiveKitAPI:
    return api.LiveKitAPI(session=http_context.http_session())</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.JobContext.inference_executor"><code class="name">prop <span class="ident">inference_executor</span> : InferenceExecutor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inference_executor(self) -&gt; InferenceExecutor:
    return self._inf_executor</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.JobContext.job"><code class="name">prop <span class="ident">job</span> : agent.Job</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def job(self) -&gt; agent.Job:
    &#34;&#34;&#34;Returns the current job that the worker is executing.&#34;&#34;&#34;
    return self._info.job</code></pre>
</details>
<div class="desc"><p>Returns the current job that the worker is executing.</p></div>
</dd>
<dt id="livekit.agents.JobContext.log_context_fields"><code class="name">prop <span class="ident">log_context_fields</span> : dict[str, Any]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def log_context_fields(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Returns the current dictionary of log fields that will be injected into log records.

    These fields enable enriched structured logging and can include job metadata,
    worker ID, trace IDs, or other diagnostic context.

    The returned dictionary can be directly edited, or entirely replaced via assignment
    (e.g., `job_context.log_context_fields = {...}`)
    &#34;&#34;&#34;
    return self._log_fields</code></pre>
</details>
<div class="desc"><p>Returns the current dictionary of log fields that will be injected into log records.</p>
<p>These fields enable enriched structured logging and can include job metadata,
worker ID, trace IDs, or other diagnostic context.</p>
<p>The returned dictionary can be directly edited, or entirely replaced via assignment
(e.g., <code>job_context.log_context_fields = {...}</code>)</p></div>
</dd>
<dt id="livekit.agents.JobContext.proc"><code class="name">prop <span class="ident">proc</span> : <a title="livekit.agents.JobProcess" href="#livekit.agents.JobProcess">JobProcess</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def proc(self) -&gt; JobProcess:
    &#34;&#34;&#34;Returns the process running the job. Useful for storing process-specific state.&#34;&#34;&#34;
    return self._proc</code></pre>
</details>
<div class="desc"><p>Returns the process running the job. Useful for storing process-specific state.</p></div>
</dd>
<dt id="livekit.agents.JobContext.room"><code class="name">prop <span class="ident">room</span> : rtc.Room</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def room(self) -&gt; rtc.Room:
    &#34;&#34;&#34;The Room object is the main interface that the worker should interact with.

    When the entrypoint is called, the worker has not connected to the Room yet.
    Certain properties of Room would not be available before calling JobContext.connect()
    &#34;&#34;&#34;
    return self._room</code></pre>
</details>
<div class="desc"><p>The Room object is the main interface that the worker should interact with.</p>
<p>When the entrypoint is called, the worker has not connected to the Room yet.
Certain properties of Room would not be available before calling JobContext.connect()</p></div>
</dd>
<dt id="livekit.agents.JobContext.worker_id"><code class="name">prop <span class="ident">worker_id</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def worker_id(self) -&gt; str:
    &#34;&#34;&#34;Returns the id of the worker.&#34;&#34;&#34;
    return self._info.worker_id</code></pre>
</details>
<div class="desc"><p>Returns the id of the worker.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.JobContext.add_participant_entrypoint"><code class="name flex">
<span>def <span class="ident">add_participant_entrypoint</span></span>(<span>self,<br>entrypoint_fnc: Callable[[<a title="livekit.agents.JobContext" href="#livekit.agents.JobContext">JobContext</a>, rtc.RemoteParticipant], Coroutine[None, None, None]],<br>*_,<br>kind: list[rtc.ParticipantKind.ValueType] | rtc.ParticipantKind.ValueType = [3, 0])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_participant_entrypoint(
    self,
    entrypoint_fnc: Callable[[JobContext, rtc.RemoteParticipant], Coroutine[None, None, None]],
    *_,
    kind: list[rtc.ParticipantKind.ValueType]
    | rtc.ParticipantKind.ValueType = DEFAULT_PARTICIPANT_KINDS,
):
    &#34;&#34;&#34;Adds an entrypoint function to be run when a participant joins the room. In cases where
    the participant has already joined, the entrypoint will be run immediately. Multiple unique entrypoints can be
    added and they will each be run in parallel for each participant.
    &#34;&#34;&#34;  # noqa: E501

    if entrypoint_fnc in [e for (e, _) in self._participant_entrypoints]:
        raise ValueError(&#34;entrypoints cannot be added more than once&#34;)

    self._participant_entrypoints.append((entrypoint_fnc, kind))</code></pre>
</details>
<div class="desc"><p>Adds an entrypoint function to be run when a participant joins the room. In cases where
the participant has already joined, the entrypoint will be run immediately. Multiple unique entrypoints can be
added and they will each be run in parallel for each participant.</p></div>
</dd>
<dt id="livekit.agents.JobContext.add_shutdown_callback"><code class="name flex">
<span>def <span class="ident">add_shutdown_callback</span></span>(<span>self,<br>callback: Callable[[], Coroutine[None, None, None]] | Callable[[str], Coroutine[None, None, None]]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_shutdown_callback(
    self,
    callback: Callable[[], Coroutine[None, None, None]]
    | Callable[[str], Coroutine[None, None, None]],
) -&gt; None:
    &#34;&#34;&#34;
    Add a callback to be called when the job is shutting down.
    Optionally the callback can take a single argument, the shutdown reason.
    &#34;&#34;&#34;
    if callback.__code__.co_argcount &gt; 0:
        self._shutdown_callbacks.append(callback)  # type: ignore
    else:

        async def wrapper(_: str) -&gt; None:
            await callback()  # type: ignore

        self._shutdown_callbacks.append(wrapper)</code></pre>
</details>
<div class="desc"><p>Add a callback to be called when the job is shutting down.
Optionally the callback can take a single argument, the shutdown reason.</p></div>
</dd>
<dt id="livekit.agents.JobContext.add_sip_participant"><code class="name flex">
<span>def <span class="ident">add_sip_participant</span></span>(<span>self,<br>*,<br>call_to: str,<br>trunk_id: str,<br>participant_identity: str,<br>participant_name: str | NotGivenOr[str] = 'SIP-participant') ‑> _asyncio.Future[sip.SIPParticipantInfo]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sip_participant(
    self,
    *,
    call_to: str,
    trunk_id: str,
    participant_identity: str,
    participant_name: str | NotGivenOr[str] = &#34;SIP-participant&#34;,
) -&gt; asyncio.Future[api.SIPParticipantInfo]:
    &#34;&#34;&#34;
    Add a SIP participant to the room.

    Args:
        call_to: The number or SIP destination to transfer the participant to.
                     This can either be a number (+12345555555) or a
                     sip host (sip:&lt;user&gt;@&lt;host&gt;)
        trunk_id: The ID of the SIP trunk to use
        participant_identity: The identity of the participant to add
        participant_name: The name of the participant to add

    Make sure you have an outbound SIP trunk created in LiveKit.
    See https://docs.livekit.io/sip/trunk-outbound/ for more information.
    &#34;&#34;&#34;
    task = asyncio.create_task(
        self.api.sip.create_sip_participant(
            api.CreateSIPParticipantRequest(
                room_name=self._room.name,
                participant_identity=participant_identity,
                sip_trunk_id=trunk_id,
                sip_call_to=call_to,
                participant_name=participant_name,
            )
        ),
    )
    self._pending_tasks.append(task)
    task.add_done_callback(lambda _: self._pending_tasks.remove(task))
    return task</code></pre>
</details>
<div class="desc"><p>Add a SIP participant to the room.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>call_to</code></strong></dt>
<dd>The number or SIP destination to transfer the participant to.
This can either be a number (+12345555555) or a
sip host (sip:<user>@<host>)</dd>
<dt><strong><code>trunk_id</code></strong></dt>
<dd>The ID of the SIP trunk to use</dd>
<dt><strong><code>participant_identity</code></strong></dt>
<dd>The identity of the participant to add</dd>
<dt><strong><code>participant_name</code></strong></dt>
<dd>The name of the participant to add</dd>
</dl>
<p>Make sure you have an outbound SIP trunk created in LiveKit.
See <a href="https://docs.livekit.io/sip/trunk-outbound/">https://docs.livekit.io/sip/trunk-outbound/</a> for more information.</p></div>
</dd>
<dt id="livekit.agents.JobContext.add_tracing_callback"><code class="name flex">
<span>def <span class="ident">add_tracing_callback</span></span>(<span>self, callback: Callable[[], Coroutine[None, None, None]]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_tracing_callback(
    self,
    callback: Callable[[], Coroutine[None, None, None]],
) -&gt; None:
    &#34;&#34;&#34;
    Add a callback to be called when the job is about to receive a new tracing request.
    &#34;&#34;&#34;
    self._tracing_callbacks.append(callback)</code></pre>
</details>
<div class="desc"><p>Add a callback to be called when the job is about to receive a new tracing request.</p></div>
</dd>
<dt id="livekit.agents.JobContext.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self,<br>*,<br>e2ee: rtc.E2EEOptions | None = None,<br>auto_subscribe: <a title="livekit.agents.AutoSubscribe" href="#livekit.agents.AutoSubscribe">AutoSubscribe</a> = AutoSubscribe.SUBSCRIBE_ALL,<br>rtc_config: rtc.RtcConfiguration | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(
    self,
    *,
    e2ee: rtc.E2EEOptions | None = None,
    auto_subscribe: AutoSubscribe = AutoSubscribe.SUBSCRIBE_ALL,
    rtc_config: rtc.RtcConfiguration | None = None,
) -&gt; None:
    &#34;&#34;&#34;Connect to the room. This method should be called only once.

    Args:
        e2ee: End-to-end encryption options. If provided, the Agent will utilize end-to-end encryption. Note: clients will also need to handle E2EE.
        auto_subscribe: Whether to automatically subscribe to tracks. Default is AutoSubscribe.SUBSCRIBE_ALL.
        rtc_config: Custom RTC configuration to use when connecting to the room.
    &#34;&#34;&#34;  # noqa: E501
    room_options = rtc.RoomOptions(
        e2ee=e2ee,
        auto_subscribe=auto_subscribe == AutoSubscribe.SUBSCRIBE_ALL,
        rtc_config=rtc_config,
    )

    await self._room.connect(self._info.url, self._info.token, options=room_options)
    self._on_connect()
    for p in self._room.remote_participants.values():
        self._participant_available(p)

    _apply_auto_subscribe_opts(self._room, auto_subscribe)</code></pre>
</details>
<div class="desc"><p>Connect to the room. This method should be called only once.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>e2ee</code></strong></dt>
<dd>End-to-end encryption options. If provided, the Agent will utilize end-to-end encryption. Note: clients will also need to handle E2EE.</dd>
<dt><strong><code>auto_subscribe</code></strong></dt>
<dd>Whether to automatically subscribe to tracks. Default is AutoSubscribe.SUBSCRIBE_ALL.</dd>
<dt><strong><code>rtc_config</code></strong></dt>
<dd>Custom RTC configuration to use when connecting to the room.</dd>
</dl></div>
</dd>
<dt id="livekit.agents.JobContext.delete_room"><code class="name flex">
<span>def <span class="ident">delete_room</span></span>(<span>self) ‑> _asyncio.Future[room.DeleteRoomResponse]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_room(self) -&gt; asyncio.Future[api.DeleteRoomResponse]:
    &#34;&#34;&#34;Deletes the room and disconnects all participants.&#34;&#34;&#34;
    task = asyncio.create_task(
        self.api.room.delete_room(api.DeleteRoomRequest(room=self._room.name))
    )
    self._pending_tasks.append(task)
    task.add_done_callback(lambda _: self._pending_tasks.remove(task))
    return task</code></pre>
</details>
<div class="desc"><p>Deletes the room and disconnects all participants.</p></div>
</dd>
<dt id="livekit.agents.JobContext.shutdown"><code class="name flex">
<span>def <span class="ident">shutdown</span></span>(<span>self, reason: str = '') ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown(self, reason: str = &#34;&#34;) -&gt; None:
    self._on_shutdown(reason)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.JobContext.transfer_sip_participant"><code class="name flex">
<span>def <span class="ident">transfer_sip_participant</span></span>(<span>self,<br>participant: rtc.RemoteParticipant | str,<br>transfer_to: str,<br>play_dialtone: bool = False) ‑> _asyncio.Future[sip.SIPParticipantInfo]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer_sip_participant(
    self,
    participant: rtc.RemoteParticipant | str,
    transfer_to: str,
    play_dialtone: bool = False,
) -&gt; asyncio.Future[api.SIPParticipantInfo]:
    &#34;&#34;&#34;Transfer a SIP participant to another number.

    Args:
        participant: The participant to transfer
        transfer_to: The number or SIP destination to transfer the participant to.
                     This can either be a number (+12345555555) or a
                     sip host (sip:&lt;user&gt;@&lt;host&gt;)
        play_dialtone: Whether to play a dialtone during transfer. Defaults to True.


    Returns:
        Future that completes when the transfer is complete

    Make sure you have enabled call transfer on your provider SIP trunk.
    See https://docs.livekit.io/sip/transfer-cold/ for more information.
    &#34;&#34;&#34;
    assert participant.kind == rtc.ParticipantKind.PARTICIPANT_KIND_SIP, (
        &#34;Participant must be a SIP participant&#34;
    )
    task = asyncio.create_task(
        self.api.sip.transfer_sip_participant(
            api.TransferSIPParticipantRequest(
                room_name=self._room.name,
                participant_identity=participant.identity,
                transfer_to=transfer_to,
                play_dialtone=play_dialtone,
            )
        ),
    )
    self._pending_tasks.append(task)
    task.add_done_callback(lambda _: self._pending_tasks.remove(task))
    return task</code></pre>
</details>
<div class="desc"><p>Transfer a SIP participant to another number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>participant</code></strong></dt>
<dd>The participant to transfer</dd>
<dt><strong><code>transfer_to</code></strong></dt>
<dd>The number or SIP destination to transfer the participant to.
This can either be a number (+12345555555) or a
sip host (sip:<user>@<host>)</dd>
<dt><strong><code>play_dialtone</code></strong></dt>
<dd>Whether to play a dialtone during transfer. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Future that completes when the transfer is complete
Make sure you have enabled call transfer on your provider SIP trunk.
See <a href="https://docs.livekit.io/sip/transfer-cold/">https://docs.livekit.io/sip/transfer-cold/</a> for more information.</p></div>
</dd>
<dt id="livekit.agents.JobContext.wait_for_participant"><code class="name flex">
<span>async def <span class="ident">wait_for_participant</span></span>(<span>self,<br>*,<br>identity: str | None = None,<br>kind: list[rtc.ParticipantKind.ValueType] | rtc.ParticipantKind.ValueType = [3, 0]) ‑> <a title="livekit.rtc.participant.RemoteParticipant" href="../rtc/participant.html#livekit.rtc.participant.RemoteParticipant">RemoteParticipant</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_participant(
    self,
    *,
    identity: str | None = None,
    kind: list[rtc.ParticipantKind.ValueType]
    | rtc.ParticipantKind.ValueType = DEFAULT_PARTICIPANT_KINDS,
) -&gt; rtc.RemoteParticipant:
    &#34;&#34;&#34;
    Returns a participant that matches the given identity. If identity is None, the first
    participant that joins the room will be returned.
    If the participant has already joined, the function will return immediately.
    &#34;&#34;&#34;
    return await wait_for_participant(self._room, identity=identity, kind=kind)</code></pre>
</details>
<div class="desc"><p>Returns a participant that matches the given identity. If identity is None, the first
participant that joins the room will be returned.
If the participant has already joined, the function will return immediately.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.JobExecutorType"><code class="flex name class">
<span>class <span class="ident">JobExecutorType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@unique
class JobExecutorType(Enum):
    PROCESS = &#34;process&#34;
    THREAD = &#34;thread&#34;</code></pre>
</details>
<div class="desc"><p>Create a collection of name/value pairs.</p>
<p>Example enumeration:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     BLUE = 2
...     GREEN = 3
</code></pre>
<p>Access them by:</p>
<ul>
<li>attribute access:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color.RED
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>value lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color(1)
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>name lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color['RED']
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<p>Enumerations can be iterated over, and know how many members they have:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len(Color)
3
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</code></pre>
<p>Methods can be added to enumerations, and members can have their own
attributes &ndash; see the documentation for details.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.JobExecutorType.PROCESS"><code class="name">var <span class="ident">PROCESS</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.JobExecutorType.THREAD"><code class="name">var <span class="ident">THREAD</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.JobProcess"><code class="flex name class">
<span>class <span class="ident">JobProcess</span></span>
<span>(</span><span>*,<br>executor_type: <a title="livekit.agents.JobExecutorType" href="#livekit.agents.JobExecutorType">JobExecutorType</a>,<br>user_arguments: Any | None,<br>http_proxy: str | None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JobProcess:
    def __init__(
        self,
        *,
        executor_type: JobExecutorType,
        user_arguments: Any | None,
        http_proxy: str | None,
    ) -&gt; None:
        self._executor_type = executor_type
        self._mp_proc = mp.current_process()
        self._userdata: dict[str, Any] = {}
        self._user_arguments = user_arguments
        self._http_proxy: str | None = http_proxy

    @property
    def executor_type(self) -&gt; JobExecutorType:
        return self._executor_type

    @property
    def pid(self) -&gt; int | None:
        return self._mp_proc.pid

    @property
    def userdata(self) -&gt; dict:
        return self._userdata

    @property
    def user_arguments(self) -&gt; Any | None:
        return self._user_arguments

    @property
    def http_proxy(self) -&gt; str | None:
        return self._http_proxy</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.JobProcess.executor_type"><code class="name">prop <span class="ident">executor_type</span> : <a title="livekit.agents.JobExecutorType" href="#livekit.agents.JobExecutorType">JobExecutorType</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def executor_type(self) -&gt; JobExecutorType:
    return self._executor_type</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.JobProcess.http_proxy"><code class="name">prop <span class="ident">http_proxy</span> : str | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def http_proxy(self) -&gt; str | None:
    return self._http_proxy</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.JobProcess.pid"><code class="name">prop <span class="ident">pid</span> : int | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pid(self) -&gt; int | None:
    return self._mp_proc.pid</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.JobProcess.user_arguments"><code class="name">prop <span class="ident">user_arguments</span> : Any | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def user_arguments(self) -&gt; Any | None:
    return self._user_arguments</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.JobProcess.userdata"><code class="name">prop <span class="ident">userdata</span> : dict</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def userdata(self) -&gt; dict:
    return self._userdata</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.JobRequest"><code class="flex name class">
<span>class <span class="ident">JobRequest</span></span>
<span>(</span><span>*,<br>job: agent.Job,<br>on_reject: Callable[[], Coroutine[None, None, None]],<br>on_accept: Callable[[JobAcceptArguments], Coroutine[None, None, None]])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JobRequest:
    def __init__(
        self,
        *,
        job: agent.Job,
        on_reject: Callable[[], Coroutine[None, None, None]],
        on_accept: Callable[[JobAcceptArguments], Coroutine[None, None, None]],
    ) -&gt; None:
        self._job = job
        self._lock = asyncio.Lock()
        self._on_reject = on_reject
        self._on_accept = on_accept

    @property
    def id(self) -&gt; str:
        return self._job.id

    @property
    def job(self) -&gt; agent.Job:
        return self._job

    @property
    def room(self) -&gt; models.Room:
        return self._job.room

    @property
    def publisher(self) -&gt; models.ParticipantInfo | None:
        return self._job.participant

    @property
    def agent_name(self) -&gt; str:
        return self._job.agent_name

    async def reject(self) -&gt; None:
        &#34;&#34;&#34;Reject the job request. The job may be assigned to another worker&#34;&#34;&#34;
        await self._on_reject()

    async def accept(
        self,
        *,
        name: str = &#34;&#34;,
        identity: str = &#34;&#34;,
        metadata: str = &#34;&#34;,
        attributes: dict[str, str] | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Accept the job request, and start the job if the LiveKit SFU assigns the job to our worker.&#34;&#34;&#34;  # noqa: E501
        if not identity:
            identity = &#34;agent-&#34; + self.id

        accept_arguments = JobAcceptArguments(
            name=name,
            identity=identity,
            metadata=metadata,
            attributes=attributes,
        )

        await self._on_accept(accept_arguments)</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.JobRequest.agent_name"><code class="name">prop <span class="ident">agent_name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def agent_name(self) -&gt; str:
    return self._job.agent_name</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.JobRequest.id"><code class="name">prop <span class="ident">id</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self) -&gt; str:
    return self._job.id</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.JobRequest.job"><code class="name">prop <span class="ident">job</span> : agent.Job</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def job(self) -&gt; agent.Job:
    return self._job</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.JobRequest.publisher"><code class="name">prop <span class="ident">publisher</span> : models.ParticipantInfo | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def publisher(self) -&gt; models.ParticipantInfo | None:
    return self._job.participant</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.JobRequest.room"><code class="name">prop <span class="ident">room</span> : models.Room</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def room(self) -&gt; models.Room:
    return self._job.room</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.JobRequest.accept"><code class="name flex">
<span>async def <span class="ident">accept</span></span>(<span>self,<br>*,<br>name: str = '',<br>identity: str = '',<br>metadata: str = '',<br>attributes: dict[str, str] | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def accept(
    self,
    *,
    name: str = &#34;&#34;,
    identity: str = &#34;&#34;,
    metadata: str = &#34;&#34;,
    attributes: dict[str, str] | None = None,
) -&gt; None:
    &#34;&#34;&#34;Accept the job request, and start the job if the LiveKit SFU assigns the job to our worker.&#34;&#34;&#34;  # noqa: E501
    if not identity:
        identity = &#34;agent-&#34; + self.id

    accept_arguments = JobAcceptArguments(
        name=name,
        identity=identity,
        metadata=metadata,
        attributes=attributes,
    )

    await self._on_accept(accept_arguments)</code></pre>
</details>
<div class="desc"><p>Accept the job request, and start the job if the LiveKit SFU assigns the job to our worker.</p></div>
</dd>
<dt id="livekit.agents.JobRequest.reject"><code class="name flex">
<span>async def <span class="ident">reject</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def reject(self) -&gt; None:
    &#34;&#34;&#34;Reject the job request. The job may be assigned to another worker&#34;&#34;&#34;
    await self._on_reject()</code></pre>
</details>
<div class="desc"><p>Reject the job request. The job may be assigned to another worker</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.MetricsCollectedEvent"><code class="flex name class">
<span>class <span class="ident">MetricsCollectedEvent</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetricsCollectedEvent(BaseModel):
    type: Literal[&#34;metrics_collected&#34;] = &#34;metrics_collected&#34;
    metrics: AgentMetrics</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.MetricsCollectedEvent.metrics"><code class="name">var <span class="ident">metrics</span> : <a title="livekit.agents.metrics.base.STTMetrics" href="metrics/base.html#livekit.agents.metrics.base.STTMetrics">STTMetrics</a> | <a title="livekit.agents.metrics.base.LLMMetrics" href="metrics/base.html#livekit.agents.metrics.base.LLMMetrics">LLMMetrics</a> | <a title="livekit.agents.metrics.base.TTSMetrics" href="metrics/base.html#livekit.agents.metrics.base.TTSMetrics">TTSMetrics</a> | <a title="livekit.agents.metrics.base.VADMetrics" href="metrics/base.html#livekit.agents.metrics.base.VADMetrics">VADMetrics</a> | <a title="livekit.agents.metrics.base.EOUMetrics" href="metrics/base.html#livekit.agents.metrics.base.EOUMetrics">EOUMetrics</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.MetricsCollectedEvent.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.MetricsCollectedEvent.type"><code class="name">var <span class="ident">type</span> : Literal['metrics_collected']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.ModelSettings"><code class="flex name class">
<span>class <span class="ident">ModelSettings</span></span>
<span>(</span><span>tool_choice: NotGivenOr[llm.ToolChoice] = NOT_GIVEN)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ModelSettings:
    tool_choice: NotGivenOr[llm.ToolChoice] = NOT_GIVEN
    &#34;&#34;&#34;The tool choice to use when calling the LLM.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>ModelSettings(tool_choice: 'NotGivenOr[llm.ToolChoice]' = NOT_GIVEN)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.ModelSettings.tool_choice"><code class="name">var <span class="ident">tool_choice</span> : <a title="livekit.agents.llm.tool_context.NamedToolChoice" href="llm/tool_context.html#livekit.agents.llm.tool_context.NamedToolChoice">NamedToolChoice</a> | Literal['auto', 'required', 'none'] | <a title="livekit.agents.types.NotGiven" href="types.html#livekit.agents.types.NotGiven">NotGiven</a></code></dt>
<dd>
<div class="desc"><p>The tool choice to use when calling the LLM.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.NotGiven"><code class="flex name class">
<span>class <span class="ident">NotGiven</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotGiven:
    def __bool__(self) -&gt; Literal[False]:
        return False

    def __repr__(self) -&gt; str:
        return &#34;NOT_GIVEN&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.Plugin"><code class="flex name class">
<span>class <span class="ident">Plugin</span></span>
<span>(</span><span>title: str, version: str, package: str, logger: logging.Logger | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Plugin(ABC):  # noqa: B024
    registered_plugins: list[Plugin] = []
    emitter: utils.EventEmitter[EventTypes] = utils.EventEmitter()

    # TODO(theomonnom): make logger mandatory once all plugins have been updated
    def __init__(
        self,
        title: str,
        version: str,
        package: str,
        logger: logging.Logger | None = None,
    ) -&gt; None:
        self._title = title
        self._version = version
        self._package = package
        self._logger = logger

    @classmethod
    def register_plugin(cls, plugin: Plugin) -&gt; None:
        if threading.current_thread() != threading.main_thread():
            raise RuntimeError(&#34;Plugins must be registered on the main thread&#34;)

        cls.registered_plugins.append(plugin)
        cls.emitter.emit(&#34;plugin_registered&#34;, plugin)

    # plugin can implement an optional download_files method
    def download_files(self) -&gt; None:  # noqa: B027
        pass

    @property
    def package(self) -&gt; str:
        return self._package

    @property
    def title(self) -&gt; str:
        return self._title

    @property
    def version(self) -&gt; str:
        return self._version

    @property
    def logger(self) -&gt; logging.Logger | None:
        return self._logger</code></pre>
</details>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>livekit.plugins.anthropic.AnthropicPlugin</li>
<li>livekit.plugins.assemblyai.AssemblyAIPlugin</li>
<li>livekit.plugins.aws.AWSPlugin</li>
<li>livekit.plugins.azure.AzurePlugin</li>
<li>livekit.plugins.bey.BeyPlugin</li>
<li>livekit.plugins.bithuman.BitHumanPlugin</li>
<li>livekit.plugins.cartesia.CartesiaPlugin</li>
<li>livekit.plugins.clova.ClovaSTTPlugin</li>
<li>livekit.plugins.deepgram.DeepgramPlugin</li>
<li>livekit.plugins.elevenlabs.ElevenLabsPlugin</li>
<li>livekit.plugins.fal.FalPlugin</li>
<li>livekit.plugins.gladia.GladiaPlugin</li>
<li>livekit.plugins.google.GooglePlugin</li>
<li>livekit.plugins.groq.GroqPlugin</li>
<li>livekit.plugins.hume.HumeAIPlugin</li>
<li><a title="livekit.plugins.minimal.MinimalPlugin" href="../plugins/minimal/index.html#livekit.plugins.minimal.MinimalPlugin">MinimalPlugin</a></li>
<li>livekit.plugins.neuphonic.NeuphonicPlugin</li>
<li>livekit.plugins.nltk.NltkPlugin</li>
<li>livekit.plugins.openai.OpenAIPlugin</li>
<li>livekit.plugins.playai.PlayAIPlugin</li>
<li>livekit.plugins.resemble.ResemblePlugin</li>
<li>livekit.plugins.rime.RimePlugin</li>
<li>livekit.plugins.silero.SileroPlugin</li>
<li>livekit.plugins.speechify.SpeechifyPlugin</li>
<li>livekit.plugins.speechmatics.SpeechmaticsPlugin</li>
<li>livekit.plugins.tavus.TavusPlugin</li>
<li>livekit.plugins.turn_detector.EOUPlugin</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.Plugin.emitter"><code class="name">var <span class="ident">emitter</span> : <a title="livekit.rtc.event_emitter.EventEmitter" href="../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a>[typing.Literal['plugin_registered']]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.Plugin.registered_plugins"><code class="name">var <span class="ident">registered_plugins</span> : list[<a title="livekit.agents.plugin.Plugin" href="plugin.html#livekit.agents.plugin.Plugin">Plugin</a>]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="livekit.agents.Plugin.register_plugin"><code class="name flex">
<span>def <span class="ident">register_plugin</span></span>(<span>plugin: <a title="livekit.agents.Plugin" href="#livekit.agents.Plugin">Plugin</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.Plugin.logger"><code class="name">prop <span class="ident">logger</span> : logging.Logger | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def logger(self) -&gt; logging.Logger | None:
    return self._logger</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.Plugin.package"><code class="name">prop <span class="ident">package</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def package(self) -&gt; str:
    return self._package</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.Plugin.title"><code class="name">prop <span class="ident">title</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def title(self) -&gt; str:
    return self._title</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.Plugin.version"><code class="name">prop <span class="ident">version</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; str:
    return self._version</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.Plugin.download_files"><code class="name flex">
<span>def <span class="ident">download_files</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_files(self) -&gt; None:  # noqa: B027
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.RoomIO"><code class="flex name class">
<span>class <span class="ident">RoomIO</span></span>
<span>(</span><span>agent_session: <a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a>,<br>room: rtc.Room,<br>*,<br>participant: rtc.RemoteParticipant | str | None = None,<br>input_options: <a title="livekit.agents.RoomInputOptions" href="#livekit.agents.RoomInputOptions">RoomInputOptions</a> = RoomInputOptions(text_enabled=True, audio_enabled=True, video_enabled=False, audio_sample_rate=24000, audio_num_channels=1, noise_cancellation=None, text_input_cb=&lt;function _default_text_input_cb&gt;, participant_kinds=NOT_GIVEN, participant_identity=NOT_GIVEN),<br>output_options: <a title="livekit.agents.RoomOutputOptions" href="#livekit.agents.RoomOutputOptions">RoomOutputOptions</a> = RoomOutputOptions(transcription_enabled=True, audio_enabled=True, audio_sample_rate=24000, audio_num_channels=1, audio_publish_options=source: SOURCE_MICROPHONE
, sync_transcription=NOT_GIVEN))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoomIO:
    def __init__(
        self,
        agent_session: AgentSession,
        room: rtc.Room,
        *,
        participant: rtc.RemoteParticipant | str | None = None,
        input_options: RoomInputOptions = DEFAULT_ROOM_INPUT_OPTIONS,
        output_options: RoomOutputOptions = DEFAULT_ROOM_OUTPUT_OPTIONS,
    ) -&gt; None:
        self._agent_session, self._room = agent_session, room
        self._input_options = input_options
        self._output_options = output_options
        self._participant_identity = (
            participant.identity if isinstance(participant, rtc.RemoteParticipant) else participant
        )
        if self._participant_identity is None and utils.is_given(
            input_options.participant_identity
        ):
            self._participant_identity = input_options.participant_identity

        self._audio_input: _ParticipantAudioInputStream | None = None
        self._video_input: _ParticipantVideoInputStream | None = None
        self._audio_output: _ParticipantAudioOutput | None = None
        self._user_tr_output: _ParallelTextOutput | None = None
        self._agent_tr_output: _ParallelTextOutput | None = None
        self._tr_synchronizer: TranscriptSynchronizer | None = None

        self._participant_available_fut = asyncio.Future[rtc.RemoteParticipant]()
        self._room_connected_fut = asyncio.Future[None]()

        self._init_atask: asyncio.Task | None = None
        self._tasks: set[asyncio.Task] = set()
        self._update_state_task: asyncio.Task | None = None

    async def start(self) -&gt; None:
        # -- create inputs --
        if self._input_options.text_enabled:
            try:
                self._room.register_text_stream_handler(TOPIC_CHAT, self._on_user_text_input)
            except ValueError:
                logger.warning(
                    f&#34;text stream handler for topic &#39;{TOPIC_CHAT}&#39; already set, ignoring&#34;
                )

        if self._input_options.video_enabled:
            self._video_input = _ParticipantVideoInputStream(self._room)

        if self._input_options.audio_enabled:
            self._audio_input = _ParticipantAudioInputStream(
                self._room,
                sample_rate=self._input_options.audio_sample_rate,
                num_channels=self._input_options.audio_num_channels,
                noise_cancellation=self._input_options.noise_cancellation,
            )

        # -- create outputs --
        if self._output_options.audio_enabled:
            self._audio_output = _ParticipantAudioOutput(
                self._room,
                sample_rate=self._output_options.audio_sample_rate,
                num_channels=self._output_options.audio_num_channels,
                track_publish_options=self._output_options.audio_publish_options,
            )

        if self._output_options.transcription_enabled:
            self._user_tr_output = self._create_transcription_output(
                is_delta_stream=False, participant=self._participant_identity
            )
            # TODO(long): add next in the chain for session.output.transcription
            self._agent_tr_output = self._create_transcription_output(
                is_delta_stream=True, participant=None
            )

            # use the RoomIO&#39;s audio output if available, otherwise use the agent&#39;s audio output
            # (e.g the audio output isn&#39;t using RoomIO with our avatar datastream impl)
            sync_transcription = True
            if utils.is_given(self._output_options.sync_transcription):
                sync_transcription = self._output_options.sync_transcription

            if sync_transcription and (
                audio_output := self._audio_output or self._agent_session.output.audio
            ):
                self._tr_synchronizer = TranscriptSynchronizer(
                    next_in_chain_audio=audio_output, next_in_chain_text=self._agent_tr_output
                )

        # -- set the room event handlers --
        self._room.on(&#34;participant_connected&#34;, self._on_participant_connected)
        self._room.on(&#34;connection_state_changed&#34;, self._on_connection_state_changed)
        if self._room.isconnected():
            self._on_connection_state_changed(rtc.ConnectionState.CONN_CONNECTED)

        self._init_atask = asyncio.create_task(self._init_task())

        # -- attach to the agent session --
        if self.audio_input:
            self._agent_session.input.audio = self.audio_input

        if self.video_input:
            self._agent_session.input.video = self.video_input

        if self.audio_output:
            self._agent_session.output.audio = self.audio_output

        if self.transcription_output:
            self._agent_session.output.transcription = self.transcription_output

        self._agent_session.on(&#34;agent_state_changed&#34;, self._on_agent_state_changed)
        self._agent_session.on(&#34;user_input_transcribed&#34;, self._on_user_input_transcribed)
        self._agent_session._room_io = self

    async def aclose(self) -&gt; None:
        self._room.off(&#34;participant_connected&#34;, self._on_participant_connected)
        self._room.off(&#34;connection_state_changed&#34;, self._on_connection_state_changed)

        if self._init_atask:
            await utils.aio.cancel_and_wait(self._init_atask)

        if self._audio_input:
            await self._audio_input.aclose()
        if self._video_input:
            await self._video_input.aclose()

        if self._tr_synchronizer:
            await self._tr_synchronizer.aclose()

        # cancel and wait for all pending tasks
        await utils.aio.cancel_and_wait(*self._tasks)
        self._tasks.clear()

    @property
    def audio_output(self) -&gt; AudioOutput | None:
        if self._tr_synchronizer:
            return self._tr_synchronizer.audio_output

        return self._audio_output

    @property
    def transcription_output(self) -&gt; TextOutput | None:
        if self._tr_synchronizer:
            return self._tr_synchronizer.text_output

        return self._agent_tr_output

    @property
    def audio_input(self) -&gt; AudioInput | None:
        return self._audio_input

    @property
    def video_input(self) -&gt; VideoInput | None:
        return self._video_input

    @property
    def linked_participant(self) -&gt; rtc.RemoteParticipant | None:
        if not self._participant_available_fut.done():
            return None
        return self._participant_available_fut.result()

    def set_participant(self, participant_identity: str | None) -&gt; None:
        &#34;&#34;&#34;Switch audio and video streams to specified participant&#34;&#34;&#34;
        if participant_identity is None:
            self.unset_participant()
            return

        if (
            self._participant_identity is not None
            and self._participant_identity != participant_identity
        ):
            # reset future if switching to a different participant
            self._participant_available_fut = asyncio.Future[rtc.RemoteParticipant]()

            # check if new participant is already connected
            for participant in self._room.remote_participants.values():
                if participant.identity == participant_identity:
                    self._participant_available_fut.set_result(participant)
                    break

        # update participant identity and handlers
        self._participant_identity = participant_identity
        if self._audio_input:
            self._audio_input.set_participant(participant_identity)
        if self._video_input:
            self._video_input.set_participant(participant_identity)

        self._update_transcription_output(self._user_tr_output, participant_identity)

    def unset_participant(self) -&gt; None:
        self._participant_identity = None
        self._participant_available_fut = asyncio.Future[rtc.RemoteParticipant]()
        if self._audio_input:
            self._audio_input.set_participant(None)
        if self._video_input:
            self._video_input.set_participant(None)
        self._update_transcription_output(self._user_tr_output, None)

    @utils.log_exceptions(logger=logger)
    async def _init_task(self) -&gt; None:
        await self._room_connected_fut

        # check existing participants
        for participant in self._room.remote_participants.values():
            self._on_participant_connected(participant)

        participant = await self._participant_available_fut
        self.set_participant(participant.identity)

        # init outputs
        self._update_transcription_output(
            self._agent_tr_output, self._room.local_participant.identity
        )
        if self._audio_output:
            await self._audio_output.start()

    def _on_connection_state_changed(self, state: rtc.ConnectionState.ValueType) -&gt; None:
        if self._room.isconnected() and not self._room_connected_fut.done():
            self._room_connected_fut.set_result(None)

    def _on_participant_connected(self, participant: rtc.RemoteParticipant) -&gt; None:
        if self._participant_available_fut.done():
            return

        if self._participant_identity is not None:
            if participant.identity != self._participant_identity:
                return
        # otherwise, skip participants that are marked as publishing for this agent
        elif (
            participant.attributes.get(ATTRIBUTE_PUBLISH_ON_BEHALF)
            == self._room.local_participant.identity
        ):
            return

        accepted_kinds = self._input_options.participant_kinds or DEFAULT_PARTICIPANT_KINDS
        if participant.kind not in accepted_kinds:
            # not an accepted participant kind, skip
            return

        self._participant_available_fut.set_result(participant)

    def _on_user_input_transcribed(self, ev: UserInputTranscribedEvent) -&gt; None:
        async def _capture_text():
            if self._user_tr_output is None:
                return

            await self._user_tr_output.capture_text(ev.transcript)
            if ev.is_final:
                # TODO(theomonnom): should we wait for the end of turn before sending the final transcript?  # noqa: E501
                self._user_tr_output.flush()

        task = asyncio.create_task(_capture_text())
        self._tasks.add(task)
        task.add_done_callback(self._tasks.discard)

    def _on_user_text_input(self, reader: rtc.TextStreamReader, participant_identity: str) -&gt; None:
        if participant_identity != self._participant_identity:
            return

        participant = self._room.remote_participants.get(participant_identity)
        if not participant:
            logger.warning(&#34;participant not found, ignoring text input&#34;)
            return

        async def _read_text():
            text = await reader.read_all()

            if self._input_options.text_input_cb:
                text_input_result = self._input_options.text_input_cb(
                    self._agent_session,
                    TextInputEvent(text=text, info=reader.info, participant=participant),
                )
                if asyncio.iscoroutine(text_input_result):
                    await text_input_result

        task = asyncio.create_task(_read_text())
        self._tasks.add(task)
        task.add_done_callback(self._tasks.discard)

    def _on_agent_state_changed(self, ev: AgentStateChangedEvent):
        @utils.log_exceptions(logger=logger)
        async def _set_state() -&gt; None:
            if self._room.isconnected():
                await self._room.local_participant.set_attributes(
                    {ATTRIBUTE_AGENT_STATE: ev.new_state}
                )

        if self._update_state_task is not None:
            self._update_state_task.cancel()

        self._update_state_task = asyncio.create_task(_set_state())

    def _create_transcription_output(
        self, is_delta_stream: bool, participant: rtc.Participant | str | None = None
    ) -&gt; _ParallelTextOutput:
        return _ParallelTextOutput(
            [
                _ParticipantLegacyTranscriptionOutput(
                    room=self._room, is_delta_stream=is_delta_stream, participant=participant
                ),
                _ParticipantTranscriptionOutput(
                    room=self._room, is_delta_stream=is_delta_stream, participant=participant
                ),
            ],
            next_in_chain=None,
        )

    def _update_transcription_output(
        self, output: _ParallelTextOutput | None, participant_identity: str | None
    ) -&gt; None:
        if output is None:
            return

        for sink in output._sinks:
            if isinstance(
                sink, (_ParticipantLegacyTranscriptionOutput, _ParticipantTranscriptionOutput)
            ):
                sink.set_participant(participant_identity)</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.RoomIO.audio_input"><code class="name">prop <span class="ident">audio_input</span> : AudioInput | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def audio_input(self) -&gt; AudioInput | None:
    return self._audio_input</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.RoomIO.audio_output"><code class="name">prop <span class="ident">audio_output</span> : AudioOutput | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def audio_output(self) -&gt; AudioOutput | None:
    if self._tr_synchronizer:
        return self._tr_synchronizer.audio_output

    return self._audio_output</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.RoomIO.linked_participant"><code class="name">prop <span class="ident">linked_participant</span> : rtc.RemoteParticipant | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def linked_participant(self) -&gt; rtc.RemoteParticipant | None:
    if not self._participant_available_fut.done():
        return None
    return self._participant_available_fut.result()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.RoomIO.transcription_output"><code class="name">prop <span class="ident">transcription_output</span> : TextOutput | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def transcription_output(self) -&gt; TextOutput | None:
    if self._tr_synchronizer:
        return self._tr_synchronizer.text_output

    return self._agent_tr_output</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.RoomIO.video_input"><code class="name">prop <span class="ident">video_input</span> : VideoInput | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def video_input(self) -&gt; VideoInput | None:
    return self._video_input</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.RoomIO.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self) -&gt; None:
    self._room.off(&#34;participant_connected&#34;, self._on_participant_connected)
    self._room.off(&#34;connection_state_changed&#34;, self._on_connection_state_changed)

    if self._init_atask:
        await utils.aio.cancel_and_wait(self._init_atask)

    if self._audio_input:
        await self._audio_input.aclose()
    if self._video_input:
        await self._video_input.aclose()

    if self._tr_synchronizer:
        await self._tr_synchronizer.aclose()

    # cancel and wait for all pending tasks
    await utils.aio.cancel_and_wait(*self._tasks)
    self._tasks.clear()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.RoomIO.set_participant"><code class="name flex">
<span>def <span class="ident">set_participant</span></span>(<span>self, participant_identity: str | None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_participant(self, participant_identity: str | None) -&gt; None:
    &#34;&#34;&#34;Switch audio and video streams to specified participant&#34;&#34;&#34;
    if participant_identity is None:
        self.unset_participant()
        return

    if (
        self._participant_identity is not None
        and self._participant_identity != participant_identity
    ):
        # reset future if switching to a different participant
        self._participant_available_fut = asyncio.Future[rtc.RemoteParticipant]()

        # check if new participant is already connected
        for participant in self._room.remote_participants.values():
            if participant.identity == participant_identity:
                self._participant_available_fut.set_result(participant)
                break

    # update participant identity and handlers
    self._participant_identity = participant_identity
    if self._audio_input:
        self._audio_input.set_participant(participant_identity)
    if self._video_input:
        self._video_input.set_participant(participant_identity)

    self._update_transcription_output(self._user_tr_output, participant_identity)</code></pre>
</details>
<div class="desc"><p>Switch audio and video streams to specified participant</p></div>
</dd>
<dt id="livekit.agents.RoomIO.start"><code class="name flex">
<span>async def <span class="ident">start</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start(self) -&gt; None:
    # -- create inputs --
    if self._input_options.text_enabled:
        try:
            self._room.register_text_stream_handler(TOPIC_CHAT, self._on_user_text_input)
        except ValueError:
            logger.warning(
                f&#34;text stream handler for topic &#39;{TOPIC_CHAT}&#39; already set, ignoring&#34;
            )

    if self._input_options.video_enabled:
        self._video_input = _ParticipantVideoInputStream(self._room)

    if self._input_options.audio_enabled:
        self._audio_input = _ParticipantAudioInputStream(
            self._room,
            sample_rate=self._input_options.audio_sample_rate,
            num_channels=self._input_options.audio_num_channels,
            noise_cancellation=self._input_options.noise_cancellation,
        )

    # -- create outputs --
    if self._output_options.audio_enabled:
        self._audio_output = _ParticipantAudioOutput(
            self._room,
            sample_rate=self._output_options.audio_sample_rate,
            num_channels=self._output_options.audio_num_channels,
            track_publish_options=self._output_options.audio_publish_options,
        )

    if self._output_options.transcription_enabled:
        self._user_tr_output = self._create_transcription_output(
            is_delta_stream=False, participant=self._participant_identity
        )
        # TODO(long): add next in the chain for session.output.transcription
        self._agent_tr_output = self._create_transcription_output(
            is_delta_stream=True, participant=None
        )

        # use the RoomIO&#39;s audio output if available, otherwise use the agent&#39;s audio output
        # (e.g the audio output isn&#39;t using RoomIO with our avatar datastream impl)
        sync_transcription = True
        if utils.is_given(self._output_options.sync_transcription):
            sync_transcription = self._output_options.sync_transcription

        if sync_transcription and (
            audio_output := self._audio_output or self._agent_session.output.audio
        ):
            self._tr_synchronizer = TranscriptSynchronizer(
                next_in_chain_audio=audio_output, next_in_chain_text=self._agent_tr_output
            )

    # -- set the room event handlers --
    self._room.on(&#34;participant_connected&#34;, self._on_participant_connected)
    self._room.on(&#34;connection_state_changed&#34;, self._on_connection_state_changed)
    if self._room.isconnected():
        self._on_connection_state_changed(rtc.ConnectionState.CONN_CONNECTED)

    self._init_atask = asyncio.create_task(self._init_task())

    # -- attach to the agent session --
    if self.audio_input:
        self._agent_session.input.audio = self.audio_input

    if self.video_input:
        self._agent_session.input.video = self.video_input

    if self.audio_output:
        self._agent_session.output.audio = self.audio_output

    if self.transcription_output:
        self._agent_session.output.transcription = self.transcription_output

    self._agent_session.on(&#34;agent_state_changed&#34;, self._on_agent_state_changed)
    self._agent_session.on(&#34;user_input_transcribed&#34;, self._on_user_input_transcribed)
    self._agent_session._room_io = self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.RoomIO.unset_participant"><code class="name flex">
<span>def <span class="ident">unset_participant</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unset_participant(self) -&gt; None:
    self._participant_identity = None
    self._participant_available_fut = asyncio.Future[rtc.RemoteParticipant]()
    if self._audio_input:
        self._audio_input.set_participant(None)
    if self._video_input:
        self._video_input.set_participant(None)
    self._update_transcription_output(self._user_tr_output, None)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.RoomInputOptions"><code class="flex name class">
<span>class <span class="ident">RoomInputOptions</span></span>
<span>(</span><span>text_enabled: bool = True,<br>audio_enabled: bool = True,<br>video_enabled: bool = False,<br>audio_sample_rate: int = 24000,<br>audio_num_channels: int = 1,<br>noise_cancellation: rtc.NoiseCancellationOptions | None = None,<br>text_input_cb: TextInputCallback = &lt;function _default_text_input_cb&gt;,<br>participant_kinds: NotGivenOr[list[rtc.ParticipantKind.ValueType]] = NOT_GIVEN,<br>participant_identity: NotGivenOr[str] = NOT_GIVEN)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RoomInputOptions:
    text_enabled: bool = True
    audio_enabled: bool = True
    video_enabled: bool = False
    audio_sample_rate: int = 24000
    audio_num_channels: int = 1
    noise_cancellation: rtc.NoiseCancellationOptions | None = None
    text_input_cb: TextInputCallback = _default_text_input_cb
    participant_kinds: NotGivenOr[list[rtc.ParticipantKind.ValueType]] = NOT_GIVEN
    &#34;&#34;&#34;Participant kinds accepted for auto subscription. If not provided,
    accept `DEFAULT_PARTICIPANT_KINDS`.&#34;&#34;&#34;
    participant_identity: NotGivenOr[str] = NOT_GIVEN
    &#34;&#34;&#34;The participant to link to. If not provided, link to the first participant.
    Can be overridden by the `participant` argument of RoomIO constructor or `set_participant`.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>RoomInputOptions(text_enabled: 'bool' = True, audio_enabled: 'bool' = True, video_enabled: 'bool' = False, audio_sample_rate: 'int' = 24000, audio_num_channels: 'int' = 1, noise_cancellation: 'rtc.NoiseCancellationOptions | None' = None, text_input_cb: 'TextInputCallback' = <function _default_text_input_cb at 0x120054ae0>, participant_kinds: 'NotGivenOr[list[rtc.ParticipantKind.ValueType]]' = NOT_GIVEN, participant_identity: 'NotGivenOr[str]' = NOT_GIVEN)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.RoomInputOptions.audio_enabled"><code class="name">var <span class="ident">audio_enabled</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.RoomInputOptions.audio_num_channels"><code class="name">var <span class="ident">audio_num_channels</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.RoomInputOptions.audio_sample_rate"><code class="name">var <span class="ident">audio_sample_rate</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.RoomInputOptions.noise_cancellation"><code class="name">var <span class="ident">noise_cancellation</span> : rtc.NoiseCancellationOptions | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.RoomInputOptions.participant_identity"><code class="name">var <span class="ident">participant_identity</span> : NotGivenOr[str]</code></dt>
<dd>
<div class="desc"><p>The participant to link to. If not provided, link to the first participant.
Can be overridden by the <code>participant</code> argument of RoomIO constructor or <code>set_participant</code>.</p></div>
</dd>
<dt id="livekit.agents.RoomInputOptions.participant_kinds"><code class="name">var <span class="ident">participant_kinds</span> : NotGivenOr[list[rtc.ParticipantKind.ValueType]]</code></dt>
<dd>
<div class="desc"><p>Participant kinds accepted for auto subscription. If not provided,
accept <code>DEFAULT_PARTICIPANT_KINDS</code>.</p></div>
</dd>
<dt id="livekit.agents.RoomInputOptions.text_enabled"><code class="name">var <span class="ident">text_enabled</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.RoomInputOptions.video_enabled"><code class="name">var <span class="ident">video_enabled</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.RoomInputOptions.text_input_cb"><code class="name flex">
<span>def <span class="ident">text_input_cb</span></span>(<span>sess: <a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a>,<br>ev: TextInputEvent) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _default_text_input_cb(sess: AgentSession, ev: TextInputEvent) -&gt; None:
    sess.interrupt()
    sess.generate_reply(user_input=ev.text)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.RoomOutputOptions"><code class="flex name class">
<span>class <span class="ident">RoomOutputOptions</span></span>
<span>(</span><span>transcription_enabled: bool = True,<br>audio_enabled: bool = True,<br>audio_sample_rate: int = 24000,<br>audio_num_channels: int = 1,<br>audio_publish_options: rtc.TrackPublishOptions = &lt;factory&gt;,<br>sync_transcription: NotGivenOr[bool] = NOT_GIVEN)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RoomOutputOptions:
    transcription_enabled: bool = True
    audio_enabled: bool = True
    audio_sample_rate: int = 24000
    audio_num_channels: int = 1
    audio_publish_options: rtc.TrackPublishOptions = field(
        default_factory=lambda: rtc.TrackPublishOptions(source=rtc.TrackSource.SOURCE_MICROPHONE)
    )
    sync_transcription: NotGivenOr[bool] = NOT_GIVEN
    &#34;&#34;&#34;False to disable transcription synchronization with audio output.
    Otherwise, transcription is emitted as quickly as available.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>RoomOutputOptions(transcription_enabled: 'bool' = True, audio_enabled: 'bool' = True, audio_sample_rate: 'int' = 24000, audio_num_channels: 'int' = 1, audio_publish_options: 'rtc.TrackPublishOptions' = <factory>, sync_transcription: 'NotGivenOr[bool]' = NOT_GIVEN)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.RoomOutputOptions.audio_enabled"><code class="name">var <span class="ident">audio_enabled</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.RoomOutputOptions.audio_num_channels"><code class="name">var <span class="ident">audio_num_channels</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.RoomOutputOptions.audio_publish_options"><code class="name">var <span class="ident">audio_publish_options</span> : room_pb2.TrackPublishOptions</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.RoomOutputOptions.audio_sample_rate"><code class="name">var <span class="ident">audio_sample_rate</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.RoomOutputOptions.sync_transcription"><code class="name">var <span class="ident">sync_transcription</span> : bool | <a title="livekit.agents.types.NotGiven" href="types.html#livekit.agents.types.NotGiven">NotGiven</a></code></dt>
<dd>
<div class="desc"><p>False to disable transcription synchronization with audio output.
Otherwise, transcription is emitted as quickly as available.</p></div>
</dd>
<dt id="livekit.agents.RoomOutputOptions.transcription_enabled"><code class="name">var <span class="ident">transcription_enabled</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.RunContext"><code class="flex name class">
<span>class <span class="ident">RunContext</span></span>
<span>(</span><span>*,<br>session: <a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a>,<br>speech_handle: SpeechHandle,<br>function_call: <a title="livekit.agents.FunctionCall" href="#livekit.agents.FunctionCall">FunctionCall</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RunContext(Generic[Userdata_T]):
    # private ctor
    def __init__(
        self,
        *,
        session: AgentSession,
        speech_handle: SpeechHandle,
        function_call: FunctionCall,
    ) -&gt; None:
        self._session = session
        self._speech_handle = speech_handle
        self._function_call = function_call

    @property
    def session(self) -&gt; AgentSession[Userdata_T]:
        return self._session

    @property
    def speech_handle(self) -&gt; SpeechHandle:
        return self._speech_handle

    @property
    def function_call(self) -&gt; FunctionCall:
        return self._function_call

    @property
    def userdata(self) -&gt; Userdata_T:
        return self.session.userdata</code></pre>
</details>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::</p>
<pre><code>class Mapping[KT, VT]:
    def __getitem__(self, key: KT) -&gt; VT:
        ...
    # Etc.
</code></pre>
<p>On older versions of Python, however, generic classes have to
explicitly inherit from Generic.</p>
<p>After a class has been declared to be generic, it can then be used as
follows::</p>
<pre><code>def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
    try:
        return mapping[key]
    except KeyError:
        return default
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.RunContext.function_call"><code class="name">prop <span class="ident">function_call</span> : <a title="livekit.agents.FunctionCall" href="#livekit.agents.FunctionCall">FunctionCall</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def function_call(self) -&gt; FunctionCall:
    return self._function_call</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.RunContext.session"><code class="name">prop <span class="ident">session</span> : <a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a>[Userdata_T]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def session(self) -&gt; AgentSession[Userdata_T]:
    return self._session</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.RunContext.speech_handle"><code class="name">prop <span class="ident">speech_handle</span> : SpeechHandle</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def speech_handle(self) -&gt; SpeechHandle:
    return self._speech_handle</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.RunContext.userdata"><code class="name">prop <span class="ident">userdata</span> : Userdata_T</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def userdata(self) -&gt; Userdata_T:
    return self.session.userdata</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.SimulateJobInfo"><code class="flex name class">
<span>class <span class="ident">SimulateJobInfo</span></span>
<span>(</span><span>room: str, participant_identity: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class SimulateJobInfo:
    room: str
    participant_identity: str | None = None</code></pre>
</details>
<div class="desc"><p>SimulateJobInfo(room: 'str', participant_identity: 'str | None' = None)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.SimulateJobInfo.participant_identity"><code class="name">var <span class="ident">participant_identity</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.SimulateJobInfo.room"><code class="name">var <span class="ident">room</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.SpeechCreatedEvent"><code class="flex name class">
<span>class <span class="ident">SpeechCreatedEvent</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpeechCreatedEvent(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)

    type: Literal[&#34;speech_created&#34;] = &#34;speech_created&#34;
    user_initiated: bool
    &#34;&#34;&#34;True if the speech was created using public methods like `say` or `generate_reply`&#34;&#34;&#34;
    source: Literal[&#34;say&#34;, &#34;generate_reply&#34;, &#34;tool_response&#34;]
    &#34;&#34;&#34;Source indicating how the speech handle was created&#34;&#34;&#34;
    speech_handle: SpeechHandle = Field(..., exclude=True)
    &#34;&#34;&#34;The speech handle that was created&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.SpeechCreatedEvent.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.SpeechCreatedEvent.source"><code class="name">var <span class="ident">source</span> : Literal['say', 'generate_reply', 'tool_response']</code></dt>
<dd>
<div class="desc"><p>Source indicating how the speech handle was created</p></div>
</dd>
<dt id="livekit.agents.SpeechCreatedEvent.speech_handle"><code class="name">var <span class="ident">speech_handle</span> : livekit.agents.voice.speech_handle.SpeechHandle</code></dt>
<dd>
<div class="desc"><p>The speech handle that was created</p></div>
</dd>
<dt id="livekit.agents.SpeechCreatedEvent.type"><code class="name">var <span class="ident">type</span> : Literal['speech_created']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.SpeechCreatedEvent.user_initiated"><code class="name">var <span class="ident">user_initiated</span> : bool</code></dt>
<dd>
<div class="desc"><p>True if the speech was created using public methods like <code>say</code> or <code>generate_reply</code></p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.StopResponse"><code class="flex name class">
<span>class <span class="ident">StopResponse</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StopResponse(Exception):
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Exception raised within AI functions.

        This exception can be raised by the user to indicate that
        the agent should not generate a response for the current
        function call.
        &#34;&#34;&#34;
        super().__init__()</code></pre>
</details>
<div class="desc"><p>Common base class for all non-exit exceptions.</p>
<p>Exception raised within AI functions.</p>
<p>This exception can be raised by the user to indicate that
the agent should not generate a response for the current
function call.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="livekit.agents.ToolError"><code class="flex name class">
<span>class <span class="ident">ToolError</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ToolError(Exception):
    def __init__(self, message: str) -&gt; None:
        &#34;&#34;&#34;
        Exception raised within AI functions.

        This exception should be raised by users when an error occurs
        in the context of AI operations. The provided message will be
        visible to the LLM, allowing it to understand the context of
        the error during FunctionOutput generation.
        &#34;&#34;&#34;
        super().__init__(message)
        self._message = message

    @property
    def message(self) -&gt; str:
        return self._message</code></pre>
</details>
<div class="desc"><p>Common base class for all non-exit exceptions.</p>
<p>Exception raised within AI functions.</p>
<p>This exception should be raised by users when an error occurs
in the context of AI operations. The provided message will be
visible to the LLM, allowing it to understand the context of
the error during FunctionOutput generation.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.ToolError.message"><code class="name">prop <span class="ident">message</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def message(self) -&gt; str:
    return self._message</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.UserInputTranscribedEvent"><code class="flex name class">
<span>class <span class="ident">UserInputTranscribedEvent</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserInputTranscribedEvent(BaseModel):
    type: Literal[&#34;user_input_transcribed&#34;] = &#34;user_input_transcribed&#34;
    transcript: str
    is_final: bool</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.UserInputTranscribedEvent.is_final"><code class="name">var <span class="ident">is_final</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.UserInputTranscribedEvent.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.UserInputTranscribedEvent.transcript"><code class="name">var <span class="ident">transcript</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.UserInputTranscribedEvent.type"><code class="name">var <span class="ident">type</span> : Literal['user_input_transcribed']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.UserStateChangedEvent"><code class="flex name class">
<span>class <span class="ident">UserStateChangedEvent</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserStateChangedEvent(BaseModel):
    type: Literal[&#34;user_state_changed&#34;] = &#34;user_state_changed&#34;
    old_state: UserState
    new_state: UserState</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.UserStateChangedEvent.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.UserStateChangedEvent.new_state"><code class="name">var <span class="ident">new_state</span> : Literal['speaking', 'listening', 'away']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.UserStateChangedEvent.old_state"><code class="name">var <span class="ident">old_state</span> : Literal['speaking', 'listening', 'away']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.UserStateChangedEvent.type"><code class="name">var <span class="ident">type</span> : Literal['user_state_changed']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.Worker"><code class="flex name class">
<span>class <span class="ident">Worker</span></span>
<span>(</span><span>opts: <a title="livekit.agents.WorkerOptions" href="#livekit.agents.WorkerOptions">WorkerOptions</a>,<br>*,<br>devmode: bool = True,<br>register: bool = True,<br>loop: asyncio.AbstractEventLoop | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Worker(utils.EventEmitter[EventTypes]):
    def __init__(
        self,
        opts: WorkerOptions,
        *,
        devmode: bool = True,
        register: bool = True,
        loop: asyncio.AbstractEventLoop | None = None,
    ) -&gt; None:
        super().__init__()
        opts.ws_url = opts.ws_url or os.environ.get(&#34;LIVEKIT_URL&#34;) or &#34;&#34;
        opts.api_key = opts.api_key or os.environ.get(&#34;LIVEKIT_API_KEY&#34;) or &#34;&#34;
        opts.api_secret = opts.api_secret or os.environ.get(&#34;LIVEKIT_API_SECRET&#34;) or &#34;&#34;

        if not opts.ws_url:
            raise ValueError(&#34;ws_url is required, or add LIVEKIT_URL in your environment&#34;)

        if not opts.api_key:
            raise ValueError(&#34;api_key is required, or add LIVEKIT_API_KEY in your environment&#34;)

        if not opts.api_secret:
            raise ValueError(
                &#34;api_secret is required, or add LIVEKIT_API_SECRET in your environment&#34;
            )

        if opts.job_memory_limit_mb &gt; 0 and opts.job_executor_type != JobExecutorType.PROCESS:
            logger.warning(
                &#34;max_job_memory_usage is only supported for process-based job executors, &#34;
                &#34;ignoring max_job_memory_usage&#34;
            )

        if not is_given(opts.http_proxy):
            opts.http_proxy = os.environ.get(&#34;HTTPS_PROXY&#34;) or os.environ.get(&#34;HTTP_PROXY&#34;)

        self._opts = opts
        self._loop = loop or asyncio.get_event_loop()

        self._id = &#34;unregistered&#34;
        self._closed, self._draining, self._connecting = True, False, False
        self._tasks = set[asyncio.Task[Any]]()
        self._pending_assignments: dict[str, asyncio.Future[agent.JobAssignment]] = {}
        self._close_future: asyncio.Future[None] | None = None
        self._msg_chan = utils.aio.Chan[agent.WorkerMessage](128, loop=self._loop)
        self._devmode = devmode
        self._register = register

        # using spawn context for all platforms. We may have further optimizations for
        # Linux with forkserver, but for now, this is the safest option
        mp_ctx = mp.get_context(&#34;spawn&#34;)

        self._inference_executor: ipc.inference_proc_executor.InferenceProcExecutor | None = None
        if len(_InferenceRunner.registered_runners) &gt; 0:
            self._inference_executor = ipc.inference_proc_executor.InferenceProcExecutor(
                runners=_InferenceRunner.registered_runners,
                initialize_timeout=30,
                close_timeout=5,
                memory_warn_mb=2000,
                memory_limit_mb=0,  # no limit
                ping_interval=5,
                ping_timeout=60,
                high_ping_threshold=2.5,
                mp_ctx=mp_ctx,
                loop=self._loop,
                http_proxy=opts.http_proxy or None,
            )

        self._proc_pool = ipc.proc_pool.ProcPool(
            initialize_process_fnc=opts.prewarm_fnc,
            job_entrypoint_fnc=opts.entrypoint_fnc,
            num_idle_processes=_WorkerEnvOption.getvalue(opts.num_idle_processes, self._devmode),
            loop=self._loop,
            job_executor_type=opts.job_executor_type,
            inference_executor=self._inference_executor,
            mp_ctx=mp_ctx,
            initialize_timeout=opts.initialize_process_timeout,
            close_timeout=opts.shutdown_process_timeout,
            memory_warn_mb=opts.job_memory_warn_mb,
            memory_limit_mb=opts.job_memory_limit_mb,
            http_proxy=opts.http_proxy or None,
        )

        self._previous_status = agent.WorkerStatus.WS_AVAILABLE

        self._api: api.LiveKitAPI | None = None
        self._http_session: aiohttp.ClientSession | None = None
        self._http_server = http_server.HttpServer(
            opts.host,
            _WorkerEnvOption.getvalue(opts.port, self._devmode),
            loop=self._loop,
        )

        async def health_check(_: Any):
            return web.Response(text=&#34;OK&#34;)

        async def worker(_: Any):
            body = json.dumps(
                {
                    &#34;agent_name&#34;: self._opts.agent_name,
                    &#34;worker_type&#34;: agent.JobType.Name(self._opts.worker_type.value),
                    &#34;active_jobs&#34;: len(self.active_jobs),
                }
            )
            return web.Response(body=body, content_type=&#34;application/json&#34;)

        self._http_server.app.add_routes([web.get(&#34;/&#34;, health_check)])
        self._http_server.app.add_routes([web.get(&#34;/worker&#34;, worker)])
        self._http_server.app.add_subapp(&#34;/debug&#34;, tracing._create_tracing_app(self))

        self._conn_task: asyncio.Task[None] | None = None
        self._load_task: asyncio.Task[None] | None = None

        self._worker_load: float = 0.0
        self._worker_load_graph = tracing.Tracing.add_graph(
            title=&#34;worker_load&#34;,
            x_label=&#34;time&#34;,
            y_label=&#34;load&#34;,
            x_type=&#34;time&#34;,
            y_range=(0, 1),
            max_data_points=int(1 / UPDATE_LOAD_INTERVAL * 30),
        )

        default_num_idle_processes = _WorkerEnvOption.getvalue(
            self._opts.num_idle_processes, self._devmode
        )
        self._num_idle_target_graph = tracing.Tracing.add_graph(
            title=&#34;num_idle_processes_target&#34;,
            x_label=&#34;time&#34;,
            y_label=&#34;target&#34;,
            x_type=&#34;time&#34;,
            y_range=(0, default_num_idle_processes),
            max_data_points=int(1 / UPDATE_LOAD_INTERVAL * 30),
        )

        self._num_idle_process_graph = tracing.Tracing.add_graph(
            title=&#34;num_idle_processes&#34;,
            x_label=&#34;time&#34;,
            y_label=&#34;idle&#34;,
            x_type=&#34;time&#34;,
            y_range=(0, default_num_idle_processes),
            max_data_points=int(1 / UPDATE_LOAD_INTERVAL * 30),
        )

    @property
    def worker_info(self) -&gt; WorkerInfo:
        return WorkerInfo(http_port=self._http_server.port)

    async def run(self):
        if not self._closed:
            raise Exception(&#34;worker is already running&#34;)

        logger.info(
            &#34;starting worker&#34;,
            extra={&#34;version&#34;: __version__, &#34;rtc-version&#34;: rtc.__version__},
        )

        if self._inference_executor is not None:
            logger.info(&#34;starting inference executor&#34;)
            await self._inference_executor.start()
            await self._inference_executor.initialize()

        self._closed = False

        def _update_job_status(proc: ipc.job_executor.JobExecutor) -&gt; None:
            t = self._loop.create_task(self._update_job_status(proc))
            self._tasks.add(t)
            t.add_done_callback(self._tasks.discard)

        await self._http_server.start()

        self._proc_pool.on(&#34;process_started&#34;, _update_job_status)
        self._proc_pool.on(&#34;process_closed&#34;, _update_job_status)
        self._proc_pool.on(&#34;process_job_launched&#34;, _update_job_status)
        await self._proc_pool.start()

        self._http_session = aiohttp.ClientSession(proxy=self._opts.http_proxy or None)
        self._api = api.LiveKitAPI(
            self._opts.ws_url, self._opts.api_key, self._opts.api_secret, session=self._http_session
        )
        self._close_future = asyncio.Future(loop=self._loop)

        @utils.log_exceptions(logger=logger)
        async def _load_task():
            &#34;&#34;&#34;periodically check load&#34;&#34;&#34;
            interval = utils.aio.interval(UPDATE_LOAD_INTERVAL)
            while True:
                await interval.tick()

                def load_fnc():
                    signature = inspect.signature(self._opts.load_fnc)
                    parameters = list(signature.parameters.values())
                    if len(parameters) == 0:
                        return self._opts.load_fnc()  # type: ignore

                    return self._opts.load_fnc(self)  # type: ignore

                self._worker_load = await asyncio.get_event_loop().run_in_executor(None, load_fnc)

                load_threshold = _WorkerEnvOption.getvalue(self._opts.load_threshold, self._devmode)
                default_num_idle_processes = _WorkerEnvOption.getvalue(
                    self._opts.num_idle_processes, self._devmode
                )

                if not math.isinf(load_threshold):
                    active_jobs = len(self.active_jobs)
                    if active_jobs &gt; 0:
                        job_load = self._worker_load / len(self.active_jobs)
                        if job_load &gt; 0.0:
                            available_load = max(load_threshold - self._worker_load, 0.0)
                            available_job = min(
                                math.ceil(available_load / job_load), default_num_idle_processes
                            )
                            self._proc_pool.set_target_idle_processes(available_job)
                    else:
                        self._proc_pool.set_target_idle_processes(default_num_idle_processes)

                self._num_idle_target_graph.plot(time.time(), self._proc_pool.target_idle_processes)
                self._num_idle_process_graph.plot(
                    time.time(), self._proc_pool._warmed_proc_queue.qsize()
                )
                self._worker_load_graph.plot(time.time(), self._worker_load)

        tasks = []
        self._load_task = asyncio.create_task(_load_task(), name=&#34;load_task&#34;)
        tasks.append(self._load_task)

        if self._register:
            self._conn_task = asyncio.create_task(self._connection_task(), name=&#34;worker_conn_task&#34;)
            tasks.append(self._conn_task)

        self.emit(&#34;worker_started&#34;)

        try:
            await asyncio.gather(*tasks)
        finally:
            await utils.aio.cancel_and_wait(*tasks)
            if not self._close_future.done():
                self._close_future.set_result(None)

    @property
    def id(self) -&gt; str:
        return self._id

    @property
    def active_jobs(self) -&gt; list[RunningJobInfo]:
        return [proc.running_job for proc in self._proc_pool.processes if proc.running_job]

    async def drain(self, timeout: int | None = None) -&gt; None:
        &#34;&#34;&#34;When timeout isn&#39;t None, it will raise asyncio.TimeoutError if the processes didn&#39;t finish in time.&#34;&#34;&#34;  # noqa: E501
        if self._draining:
            return

        logger.info(&#34;draining worker&#34;, extra={&#34;id&#34;: self.id, &#34;timeout&#34;: timeout})
        self._draining = True
        await self._update_worker_status()

        async def _join_jobs():
            for proc in self._proc_pool.processes:
                if proc.running_job:
                    await proc.join()

        if timeout:
            await asyncio.wait_for(_join_jobs(), timeout)  # raises asyncio.TimeoutError on timeout
        else:
            await _join_jobs()

    async def simulate_job(
        self,
        info: SimulateJobInfo | str,
    ) -&gt; None:
        &#34;&#34;&#34;
        Simulate a job by creating a room and participant.

        Args:
            info: SimulateJobInfo or a join token for an existing room
        &#34;&#34;&#34;
        assert self._api is not None
        # TODO(theomonnom): some fake information can still be found in the token

        from livekit.protocol.models import Room

        room = info.room if isinstance(info, SimulateJobInfo) else &#34;unknown-room&#34;
        participant_identity = (
            info.participant_identity
            if isinstance(info, SimulateJobInfo)
            else &#34;unknown-participant&#34;
        )
        agent_id = utils.shortuuid(&#34;simulated-agent-&#34;)

        room_info = Room(sid=utils.shortuuid(&#34;RM_&#34;), name=room)
        participant_info = None

        if isinstance(info, SimulateJobInfo):
            from .cli import cli

            if cli.CLI_ARGUMENTS is None or not cli.CLI_ARGUMENTS.console:
                room_info = await self._api.room.create_room(api.CreateRoomRequest(name=room))
                if participant_identity:
                    participant_info = await self._api.room.get_participant(
                        api.RoomParticipantIdentity(room=room, identity=participant_identity)
                    )

            token = (
                api.AccessToken(self._opts.api_key, self._opts.api_secret)
                .with_identity(agent_id)
                .with_kind(&#34;agent&#34;)
                .with_grants(api.VideoGrants(room_join=True, room=room, agent=True))
                .to_jwt()
            )
        else:
            token = info

        job = agent.Job(
            id=utils.shortuuid(&#34;simulated-job-&#34;),
            room=room_info,
            type=agent.JobType.JT_ROOM,
            participant=participant_info,
        )

        running_info = RunningJobInfo(
            worker_id=self._id,
            accept_arguments=JobAcceptArguments(identity=agent_id, name=&#34;&#34;, metadata=&#34;&#34;),
            job=job,
            url=self._opts.ws_url,
            token=token,
        )

        await self._proc_pool.launch_job(running_info)

    async def aclose(self) -&gt; None:
        if self._closed:
            if self._close_future is not None:
                await self._close_future
            return

        logger.info(&#34;shutting down worker&#34;, extra={&#34;id&#34;: self.id})

        assert self._close_future is not None
        assert self._http_session is not None
        assert self._api is not None

        self._closed = True

        if self._conn_task is not None:
            await utils.aio.cancel_and_wait(self._conn_task)

        if self._load_task is not None:
            await utils.aio.cancel_and_wait(self._load_task)

        await self._proc_pool.aclose()

        if self._inference_executor is not None:
            await self._inference_executor.aclose()

        await self._http_session.close()
        await self._http_server.aclose()
        await self._api.aclose()

        await asyncio.gather(*self._tasks, return_exceptions=True)

        # await asyncio.sleep(0.25)  # see https://github.com/aio-libs/aiohttp/issues/1925
        self._msg_chan.close()
        await self._close_future

    async def _queue_msg(self, msg: agent.WorkerMessage) -&gt; None:
        &#34;&#34;&#34;_queue_msg raises aio.ChanClosed when the worker is closing/closed&#34;&#34;&#34;
        if self._connecting:
            which = msg.WhichOneof(&#34;message&#34;)
            if which == &#34;update_worker&#34;:
                return
            elif which == &#34;ping&#34;:
                return

        await self._msg_chan.send(msg)

    @utils.log_exceptions(logger=logger)
    async def _connection_task(self) -&gt; None:
        assert self._http_session is not None

        retry_count = 0
        ws: aiohttp.ClientWebSocketResponse | None = None
        while not self._closed:
            try:
                self._connecting = True
                join_jwt = (
                    api.AccessToken(self._opts.api_key, self._opts.api_secret)
                    .with_grants(api.VideoGrants(agent=True))
                    .to_jwt()
                )

                headers = {&#34;Authorization&#34;: f&#34;Bearer {join_jwt}&#34;}

                parse = urlparse(self._opts.ws_url)
                scheme = parse.scheme
                if scheme.startswith(&#34;http&#34;):
                    scheme = scheme.replace(&#34;http&#34;, &#34;ws&#34;)

                path_parts = [f&#34;{scheme}://{parse.netloc}&#34;, parse.path, &#34;/agent&#34;]
                agent_url = reduce(urljoin, path_parts)

                ws = await self._http_session.ws_connect(
                    agent_url, headers=headers, autoping=True, proxy=self._opts.http_proxy or None
                )

                retry_count = 0

                # register the worker
                req = agent.WorkerMessage()
                req.register.type = self._opts.worker_type.value
                req.register.allowed_permissions.CopyFrom(
                    models.ParticipantPermission(
                        can_publish=self._opts.permissions.can_publish,
                        can_subscribe=self._opts.permissions.can_subscribe,
                        can_publish_data=self._opts.permissions.can_publish_data,
                        can_update_metadata=self._opts.permissions.can_update_metadata,
                        can_publish_sources=self._opts.permissions.can_publish_sources,
                        hidden=self._opts.permissions.hidden,
                        agent=True,
                    )
                )
                req.register.agent_name = self._opts.agent_name
                req.register.version = __version__
                await ws.send_bytes(req.SerializeToString())

                # wait for the register response before running this connection
                first_msg_b = await ws.receive_bytes()
                msg = agent.ServerMessage()
                msg.ParseFromString(first_msg_b)

                if not msg.HasField(&#34;register&#34;):
                    raise Exception(&#34;expected register response as first message&#34;)

                self._handle_register(msg.register)
                self._connecting = False

                await self._run_ws(ws)
            except Exception as e:
                if self._closed:
                    break

                if retry_count &gt;= self._opts.max_retry:
                    raise RuntimeError(
                        f&#34;failed to connect to livekit after {retry_count} attempts&#34;,
                    ) from None

                retry_delay = min(retry_count * 2, 10)
                retry_count += 1

                logger.warning(
                    f&#34;failed to connect to livekit, retrying in {retry_delay}s&#34;, exc_info=e
                )
                await asyncio.sleep(retry_delay)
            finally:
                if ws is not None:
                    await ws.close()

    async def _run_ws(self, ws: aiohttp.ClientWebSocketResponse):
        closing_ws = False

        async def _load_task():
            &#34;&#34;&#34;periodically update worker status&#34;&#34;&#34;
            interval = utils.aio.interval(UPDATE_STATUS_INTERVAL)
            while True:
                await interval.tick()
                await self._update_worker_status()

        async def _send_task():
            nonlocal closing_ws
            while True:
                try:
                    msg = await self._msg_chan.recv()
                    await ws.send_bytes(msg.SerializeToString())
                except utils.aio.ChanClosed:
                    closing_ws = True
                    return

        async def _recv_task():
            nonlocal closing_ws
            while True:
                msg = await ws.receive()
                if msg.type in (
                    aiohttp.WSMsgType.CLOSE,
                    aiohttp.WSMsgType.CLOSED,
                    aiohttp.WSMsgType.CLOSING,
                ):
                    if closing_ws:
                        return

                    raise Exception(&#34;worker connection closed unexpectedly&#34;)

                if msg.type != aiohttp.WSMsgType.BINARY:
                    logger.warning(&#34;unexpected message type: %s&#34;, msg.type)
                    continue

                data = msg.data
                msg = agent.ServerMessage()
                msg.ParseFromString(data)
                which = msg.WhichOneof(&#34;message&#34;)
                if which == &#34;availability&#34;:
                    self._handle_availability(msg.availability)
                elif which == &#34;assignment&#34;:
                    self._handle_assignment(msg.assignment)
                elif which == &#34;termination&#34;:
                    user_task = self._loop.create_task(
                        self._handle_termination(msg.termination),
                        name=&#34;agent_job_termination&#34;,
                    )
                    self._tasks.add(user_task)
                    user_task.add_done_callback(self._tasks.discard)

        tasks = [
            asyncio.create_task(_load_task()),
            asyncio.create_task(_send_task()),
            asyncio.create_task(_recv_task()),
        ]
        try:
            await asyncio.gather(*tasks)
        finally:
            await utils.aio.cancel_and_wait(*tasks)

    async def _reload_jobs(self, jobs: list[RunningJobInfo]) -&gt; None:
        if not self._opts.api_secret:
            raise RuntimeError(&#34;api_secret is required to reload jobs&#34;)

        for aj in jobs:
            logger.log(
                DEV_LEVEL,
                &#34;reloading job&#34;,
                extra={&#34;job_id&#34;: aj.job.id, &#34;agent_name&#34;: aj.job.agent_name},
            )

            # take the original jwt token and extend it while keeping all the same data that was generated  # noqa: E501
            # by the SFU for the original join token.
            original_token = aj.token
            decoded = jwt.decode(original_token, self._opts.api_secret, algorithms=[&#34;HS256&#34;])
            decoded[&#34;exp&#34;] = int(datetime.datetime.now(datetime.timezone.utc).timestamp()) + 3600
            running_info = RunningJobInfo(
                accept_arguments=aj.accept_arguments,
                job=aj.job,
                url=self._opts.ws_url,
                token=jwt.encode(decoded, self._opts.api_secret, algorithm=&#34;HS256&#34;),
                worker_id=aj.worker_id,
            )
            await self._proc_pool.launch_job(running_info)

    def _handle_register(self, reg: agent.RegisterWorkerResponse):
        self._id = reg.worker_id
        logger.info(
            &#34;registered worker&#34;,
            extra={
                &#34;id&#34;: reg.worker_id,
                &#34;url&#34;: self._opts.ws_url,
                &#34;region&#34;: reg.server_info.region,
                &#34;protocol&#34;: reg.server_info.protocol,
            },
        )
        self.emit(&#34;worker_registered&#34;, reg.worker_id, reg.server_info)

    def _handle_availability(self, msg: agent.AvailabilityRequest):
        task = self._loop.create_task(self._answer_availability(msg))
        self._tasks.add(task)
        task.add_done_callback(self._tasks.discard)

    async def _answer_availability(self, msg: agent.AvailabilityRequest):
        &#34;&#34;&#34;Ask the user if they want to accept this job and forward the answer to the server.
        If we get the job assigned, we start a new process.&#34;&#34;&#34;

        answered = False

        async def _on_reject() -&gt; None:
            nonlocal answered
            answered = True

            availability_resp = agent.WorkerMessage()
            availability_resp.availability.job_id = msg.job.id
            availability_resp.availability.available = False
            await self._queue_msg(availability_resp)

        async def _on_accept(args: JobAcceptArguments) -&gt; None:
            nonlocal answered
            answered = True

            availability_resp = agent.WorkerMessage()
            availability_resp.availability.job_id = msg.job.id
            availability_resp.availability.available = True
            availability_resp.availability.participant_identity = args.identity
            availability_resp.availability.participant_name = args.name
            availability_resp.availability.participant_metadata = args.metadata
            if args.attributes:
                availability_resp.availability.participant_attributes.update(args.attributes)
            await self._queue_msg(availability_resp)

            wait_assignment = asyncio.Future[agent.JobAssignment]()
            self._pending_assignments[job_req.id] = wait_assignment

            # the job was accepted by the user, wait for the server assignment
            try:
                await asyncio.wait_for(wait_assignment, ASSIGNMENT_TIMEOUT)
            except asyncio.TimeoutError:
                logger.warning(
                    f&#34;assignment for job {job_req.id} timed out&#34;,
                    extra={&#34;job_request&#34;: job_req, &#34;agent_name&#34;: self._opts.agent_name},
                )
                raise AssignmentTimeoutError() from None

            job_assign = wait_assignment.result()
            running_info = RunningJobInfo(
                accept_arguments=args,
                job=msg.job,
                url=job_assign.url or self._opts.ws_url,
                token=job_assign.token,
                worker_id=self._id,
            )

            await self._proc_pool.launch_job(running_info)

        job_req = JobRequest(job=msg.job, on_reject=_on_reject, on_accept=_on_accept)

        logger.info(
            &#34;received job request&#34;,
            extra={
                &#34;job_id&#34;: msg.job.id,
                &#34;dispatch_id&#34;: msg.job.dispatch_id,
                &#34;room_name&#34;: msg.job.room.name,
                &#34;agent_name&#34;: self._opts.agent_name,
                &#34;resuming&#34;: msg.resuming,
            },
        )

        @utils.log_exceptions(logger=logger)
        async def _job_request_task():
            try:
                await self._opts.request_fnc(job_req)
            except Exception:
                logger.exception(
                    &#34;job_request_fnc failed&#34;,
                    extra={&#34;job_request&#34;: job_req, &#34;agent_name&#34;: self._opts.agent_name},
                )

            if not answered:
                logger.warning(
                    &#34;no answer was given inside the job_request_fnc, automatically rejecting the job&#34;,  # noqa: E501
                    extra={&#34;job_request&#34;: job_req, &#34;agent_name&#34;: self._opts.agent_name},
                )
                await _on_reject()

        user_task = self._loop.create_task(_job_request_task(), name=&#34;job_request&#34;)
        self._tasks.add(user_task)
        user_task.add_done_callback(self._tasks.discard)

    def _handle_assignment(self, assignment: agent.JobAssignment):
        if assignment.job.id in self._pending_assignments:
            with contextlib.suppress(asyncio.InvalidStateError):
                fut = self._pending_assignments.pop(assignment.job.id)
                fut.set_result(assignment)
        else:
            logger.warning(
                &#34;received assignment for an unknown job&#34;,
                extra={&#34;job&#34;: assignment.job, &#34;agent_name&#34;: self._opts.agent_name},
            )

    async def _handle_termination(self, msg: agent.JobTermination):
        proc = self._proc_pool.get_by_job_id(msg.job_id)
        if not proc:
            # safe to ignore
            return
        await proc.aclose()

    async def _update_worker_status(self):
        job_cnt = len(self.active_jobs)
        if self._draining:
            update = agent.UpdateWorkerStatus(status=agent.WorkerStatus.WS_FULL, job_count=job_cnt)
            msg = agent.WorkerMessage(update_worker=update)
            await self._queue_msg(msg)
            return

        load_threshold = _WorkerEnvOption.getvalue(self._opts.load_threshold, self._devmode)
        is_full = self._worker_load &gt;= load_threshold
        currently_available = not is_full and not self._draining

        status = (
            agent.WorkerStatus.WS_AVAILABLE if currently_available else agent.WorkerStatus.WS_FULL
        )

        update = agent.UpdateWorkerStatus(load=self._worker_load, status=status, job_count=job_cnt)

        # only log if status has changed
        if self._previous_status != status and not self._draining:
            self._previous_status = status
            extra = {
                &#34;load&#34;: self._worker_load,
                &#34;threshold&#34;: self._opts.load_threshold,
            }
            if is_full:
                logger.info(
                    &#34;worker is at full capacity, marking as unavailable&#34;,
                    extra=extra,
                )
            else:
                logger.info(
                    &#34;worker is below capacity, marking as available&#34;,
                    extra=extra,
                )

        msg = agent.WorkerMessage(update_worker=update)
        with contextlib.suppress(utils.aio.ChanClosed):
            await self._queue_msg(msg)

    async def _update_job_status(self, proc: ipc.job_executor.JobExecutor) -&gt; None:
        job_info = proc.running_job
        if job_info is None:
            return

        status: agent.JobStatus = agent.JobStatus.JS_RUNNING
        if proc.status == ipc.job_executor.JobStatus.FAILED:
            status = agent.JobStatus.JS_FAILED
        elif proc.status == ipc.job_executor.JobStatus.SUCCESS:
            status = agent.JobStatus.JS_SUCCESS
        elif proc.status == ipc.job_executor.JobStatus.RUNNING:
            status = agent.JobStatus.JS_RUNNING

        update = agent.UpdateJobStatus(job_id=job_info.job.id, status=status, error=&#34;&#34;)
        msg = agent.WorkerMessage(update_job=update)
        await self._queue_msg(msg)</code></pre>
</details>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::</p>
<pre><code>class Mapping[KT, VT]:
    def __getitem__(self, key: KT) -&gt; VT:
        ...
    # Etc.
</code></pre>
<p>On older versions of Python, however, generic classes have to
explicitly inherit from Generic.</p>
<p>After a class has been declared to be generic, it can then be used as
follows::</p>
<pre><code>def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
    try:
        return mapping[key]
    except KeyError:
        return default
</code></pre>
<p>Initialize a new instance of EventEmitter.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.rtc.event_emitter.EventEmitter" href="../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a></li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.Worker.active_jobs"><code class="name">prop <span class="ident">active_jobs</span> : list[RunningJobInfo]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def active_jobs(self) -&gt; list[RunningJobInfo]:
    return [proc.running_job for proc in self._proc_pool.processes if proc.running_job]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.Worker.id"><code class="name">prop <span class="ident">id</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self) -&gt; str:
    return self._id</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.Worker.worker_info"><code class="name">prop <span class="ident">worker_info</span> : WorkerInfo</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def worker_info(self) -&gt; WorkerInfo:
    return WorkerInfo(http_port=self._http_server.port)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.Worker.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self) -&gt; None:
    if self._closed:
        if self._close_future is not None:
            await self._close_future
        return

    logger.info(&#34;shutting down worker&#34;, extra={&#34;id&#34;: self.id})

    assert self._close_future is not None
    assert self._http_session is not None
    assert self._api is not None

    self._closed = True

    if self._conn_task is not None:
        await utils.aio.cancel_and_wait(self._conn_task)

    if self._load_task is not None:
        await utils.aio.cancel_and_wait(self._load_task)

    await self._proc_pool.aclose()

    if self._inference_executor is not None:
        await self._inference_executor.aclose()

    await self._http_session.close()
    await self._http_server.aclose()
    await self._api.aclose()

    await asyncio.gather(*self._tasks, return_exceptions=True)

    # await asyncio.sleep(0.25)  # see https://github.com/aio-libs/aiohttp/issues/1925
    self._msg_chan.close()
    await self._close_future</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.Worker.drain"><code class="name flex">
<span>async def <span class="ident">drain</span></span>(<span>self, timeout: int | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def drain(self, timeout: int | None = None) -&gt; None:
    &#34;&#34;&#34;When timeout isn&#39;t None, it will raise asyncio.TimeoutError if the processes didn&#39;t finish in time.&#34;&#34;&#34;  # noqa: E501
    if self._draining:
        return

    logger.info(&#34;draining worker&#34;, extra={&#34;id&#34;: self.id, &#34;timeout&#34;: timeout})
    self._draining = True
    await self._update_worker_status()

    async def _join_jobs():
        for proc in self._proc_pool.processes:
            if proc.running_job:
                await proc.join()

    if timeout:
        await asyncio.wait_for(_join_jobs(), timeout)  # raises asyncio.TimeoutError on timeout
    else:
        await _join_jobs()</code></pre>
</details>
<div class="desc"><p>When timeout isn't None, it will raise asyncio.TimeoutError if the processes didn't finish in time.</p></div>
</dd>
<dt id="livekit.agents.Worker.run"><code class="name flex">
<span>async def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def run(self):
    if not self._closed:
        raise Exception(&#34;worker is already running&#34;)

    logger.info(
        &#34;starting worker&#34;,
        extra={&#34;version&#34;: __version__, &#34;rtc-version&#34;: rtc.__version__},
    )

    if self._inference_executor is not None:
        logger.info(&#34;starting inference executor&#34;)
        await self._inference_executor.start()
        await self._inference_executor.initialize()

    self._closed = False

    def _update_job_status(proc: ipc.job_executor.JobExecutor) -&gt; None:
        t = self._loop.create_task(self._update_job_status(proc))
        self._tasks.add(t)
        t.add_done_callback(self._tasks.discard)

    await self._http_server.start()

    self._proc_pool.on(&#34;process_started&#34;, _update_job_status)
    self._proc_pool.on(&#34;process_closed&#34;, _update_job_status)
    self._proc_pool.on(&#34;process_job_launched&#34;, _update_job_status)
    await self._proc_pool.start()

    self._http_session = aiohttp.ClientSession(proxy=self._opts.http_proxy or None)
    self._api = api.LiveKitAPI(
        self._opts.ws_url, self._opts.api_key, self._opts.api_secret, session=self._http_session
    )
    self._close_future = asyncio.Future(loop=self._loop)

    @utils.log_exceptions(logger=logger)
    async def _load_task():
        &#34;&#34;&#34;periodically check load&#34;&#34;&#34;
        interval = utils.aio.interval(UPDATE_LOAD_INTERVAL)
        while True:
            await interval.tick()

            def load_fnc():
                signature = inspect.signature(self._opts.load_fnc)
                parameters = list(signature.parameters.values())
                if len(parameters) == 0:
                    return self._opts.load_fnc()  # type: ignore

                return self._opts.load_fnc(self)  # type: ignore

            self._worker_load = await asyncio.get_event_loop().run_in_executor(None, load_fnc)

            load_threshold = _WorkerEnvOption.getvalue(self._opts.load_threshold, self._devmode)
            default_num_idle_processes = _WorkerEnvOption.getvalue(
                self._opts.num_idle_processes, self._devmode
            )

            if not math.isinf(load_threshold):
                active_jobs = len(self.active_jobs)
                if active_jobs &gt; 0:
                    job_load = self._worker_load / len(self.active_jobs)
                    if job_load &gt; 0.0:
                        available_load = max(load_threshold - self._worker_load, 0.0)
                        available_job = min(
                            math.ceil(available_load / job_load), default_num_idle_processes
                        )
                        self._proc_pool.set_target_idle_processes(available_job)
                else:
                    self._proc_pool.set_target_idle_processes(default_num_idle_processes)

            self._num_idle_target_graph.plot(time.time(), self._proc_pool.target_idle_processes)
            self._num_idle_process_graph.plot(
                time.time(), self._proc_pool._warmed_proc_queue.qsize()
            )
            self._worker_load_graph.plot(time.time(), self._worker_load)

    tasks = []
    self._load_task = asyncio.create_task(_load_task(), name=&#34;load_task&#34;)
    tasks.append(self._load_task)

    if self._register:
        self._conn_task = asyncio.create_task(self._connection_task(), name=&#34;worker_conn_task&#34;)
        tasks.append(self._conn_task)

    self.emit(&#34;worker_started&#34;)

    try:
        await asyncio.gather(*tasks)
    finally:
        await utils.aio.cancel_and_wait(*tasks)
        if not self._close_future.done():
            self._close_future.set_result(None)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.Worker.simulate_job"><code class="name flex">
<span>async def <span class="ident">simulate_job</span></span>(<span>self,<br>info: <a title="livekit.agents.SimulateJobInfo" href="#livekit.agents.SimulateJobInfo">SimulateJobInfo</a> | str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def simulate_job(
    self,
    info: SimulateJobInfo | str,
) -&gt; None:
    &#34;&#34;&#34;
    Simulate a job by creating a room and participant.

    Args:
        info: SimulateJobInfo or a join token for an existing room
    &#34;&#34;&#34;
    assert self._api is not None
    # TODO(theomonnom): some fake information can still be found in the token

    from livekit.protocol.models import Room

    room = info.room if isinstance(info, SimulateJobInfo) else &#34;unknown-room&#34;
    participant_identity = (
        info.participant_identity
        if isinstance(info, SimulateJobInfo)
        else &#34;unknown-participant&#34;
    )
    agent_id = utils.shortuuid(&#34;simulated-agent-&#34;)

    room_info = Room(sid=utils.shortuuid(&#34;RM_&#34;), name=room)
    participant_info = None

    if isinstance(info, SimulateJobInfo):
        from .cli import cli

        if cli.CLI_ARGUMENTS is None or not cli.CLI_ARGUMENTS.console:
            room_info = await self._api.room.create_room(api.CreateRoomRequest(name=room))
            if participant_identity:
                participant_info = await self._api.room.get_participant(
                    api.RoomParticipantIdentity(room=room, identity=participant_identity)
                )

        token = (
            api.AccessToken(self._opts.api_key, self._opts.api_secret)
            .with_identity(agent_id)
            .with_kind(&#34;agent&#34;)
            .with_grants(api.VideoGrants(room_join=True, room=room, agent=True))
            .to_jwt()
        )
    else:
        token = info

    job = agent.Job(
        id=utils.shortuuid(&#34;simulated-job-&#34;),
        room=room_info,
        type=agent.JobType.JT_ROOM,
        participant=participant_info,
    )

    running_info = RunningJobInfo(
        worker_id=self._id,
        accept_arguments=JobAcceptArguments(identity=agent_id, name=&#34;&#34;, metadata=&#34;&#34;),
        job=job,
        url=self._opts.ws_url,
        token=token,
    )

    await self._proc_pool.launch_job(running_info)</code></pre>
</details>
<div class="desc"><p>Simulate a job by creating a room and participant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>info</code></strong></dt>
<dd>SimulateJobInfo or a join token for an existing room</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livekit.rtc.event_emitter.EventEmitter" href="../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a></b></code>:
<ul class="hlist">
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.emit" href="../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.emit">emit</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.off" href="../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.off">off</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.on" href="../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.on">on</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.once" href="../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.once">once</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livekit.agents.WorkerOptions"><code class="flex name class">
<span>class <span class="ident">WorkerOptions</span></span>
<span>(</span><span>entrypoint_fnc: Callable[[<a title="livekit.agents.JobContext" href="#livekit.agents.JobContext">JobContext</a>], Awaitable[None]],<br>request_fnc: Callable[[<a title="livekit.agents.JobRequest" href="#livekit.agents.JobRequest">JobRequest</a>], Awaitable[None]] = &lt;function _default_request_fnc&gt;,<br>prewarm_fnc: Callable[[<a title="livekit.agents.JobProcess" href="#livekit.agents.JobProcess">JobProcess</a>], Any] = &lt;function _default_initialize_process_fnc&gt;,<br>load_fnc: Callable[[<a title="livekit.agents.Worker" href="#livekit.agents.Worker">Worker</a>], float] | Callable[[], float] = &lt;bound method _DefaultLoadCalc.get_load of &lt;class &#x27;livekit.agents.worker._DefaultLoadCalc&#x27;&gt;&gt;,<br>job_executor_type: <a title="livekit.agents.JobExecutorType" href="#livekit.agents.JobExecutorType">JobExecutorType</a> = JobExecutorType.PROCESS,<br>load_threshold: float | _WorkerEnvOption[float] = _WorkerEnvOption(dev_default=inf, prod_default=0.75),<br>job_memory_warn_mb: float = 500,<br>job_memory_limit_mb: float = 0,<br>num_idle_processes: int | _WorkerEnvOption[int] = _WorkerEnvOption(dev_default=0, prod_default=12),<br>shutdown_process_timeout: float = 60.0,<br>initialize_process_timeout: float = 10.0,<br>permissions: <a title="livekit.agents.WorkerPermissions" href="#livekit.agents.WorkerPermissions">WorkerPermissions</a> = &lt;factory&gt;,<br>agent_name: str = '',<br>worker_type: <a title="livekit.agents.WorkerType" href="#livekit.agents.WorkerType">WorkerType</a> = WorkerType.ROOM,<br>max_retry: int = 16,<br>ws_url: str = 'ws://localhost:7880',<br>api_key: str | None = None,<br>api_secret: str | None = None,<br>host: str = '',<br>port: int | _WorkerEnvOption[int] = _WorkerEnvOption(dev_default=0, prod_default=8081),<br>http_proxy: NotGivenOr[str | None] = NOT_GIVEN)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class WorkerOptions:
    entrypoint_fnc: Callable[[JobContext], Awaitable[None]]
    &#34;&#34;&#34;Entrypoint function that will be called when a job is assigned to this worker.&#34;&#34;&#34;
    request_fnc: Callable[[JobRequest], Awaitable[None]] = _default_request_fnc
    &#34;&#34;&#34;Inspect the request and decide if the current worker should handle it.

    When left empty, all jobs are accepted.&#34;&#34;&#34;
    prewarm_fnc: Callable[[JobProcess], Any] = _default_initialize_process_fnc
    &#34;&#34;&#34;A function to perform any necessary initialization before the job starts.&#34;&#34;&#34;
    load_fnc: Callable[[Worker], float] | Callable[[], float] = _DefaultLoadCalc.get_load
    &#34;&#34;&#34;Called to determine the current load of the worker. Should return a value between 0 and 1.&#34;&#34;&#34;
    job_executor_type: JobExecutorType = _default_job_executor_type
    &#34;&#34;&#34;Which executor to use to run jobs. (currently thread or process are supported)&#34;&#34;&#34;
    load_threshold: float | _WorkerEnvOption[float] = _WorkerEnvOption(
        dev_default=math.inf, prod_default=0.75
    )
    &#34;&#34;&#34;When the load exceeds this threshold, the worker will be marked as unavailable.

    Defaults to 0.75 on &#34;production&#34; mode, and is disabled in &#34;development&#34; mode.
    &#34;&#34;&#34;

    job_memory_warn_mb: float = 500
    &#34;&#34;&#34;Memory warning threshold in MB. If the job process exceeds this limit, a warning will be logged.&#34;&#34;&#34;  # noqa: E501
    job_memory_limit_mb: float = 0
    &#34;&#34;&#34;Maximum memory usage for a job in MB, the job process will be killed if it exceeds this limit.
    Defaults to 0 (disabled).
    &#34;&#34;&#34;  # noqa: E501

    &#34;&#34;&#34;Number of idle processes to keep warm.&#34;&#34;&#34;
    num_idle_processes: int | _WorkerEnvOption[int] = _WorkerEnvOption(
        dev_default=0, prod_default=math.ceil(get_cpu_monitor().cpu_count())
    )
    &#34;&#34;&#34;Number of idle processes to keep warm.&#34;&#34;&#34;
    shutdown_process_timeout: float = 60.0
    &#34;&#34;&#34;Maximum amount of time to wait for a job to shut down gracefully&#34;&#34;&#34;
    initialize_process_timeout: float = 10.0
    &#34;&#34;&#34;Maximum amount of time to wait for a process to initialize/prewarm&#34;&#34;&#34;
    permissions: WorkerPermissions = field(default_factory=WorkerPermissions)
    &#34;&#34;&#34;Permissions that the agent should join the room with.&#34;&#34;&#34;
    agent_name: str = &#34;&#34;
    &#34;&#34;&#34;Set agent_name to enable explicit dispatch. When explicit dispatch is enabled, jobs will not be dispatched to rooms automatically. Instead, you can either specify the agent(s) to be dispatched in the end-user&#39;s token, or use the AgentDispatch.createDispatch API&#34;&#34;&#34;  # noqa: E501
    worker_type: WorkerType = WorkerType.ROOM
    &#34;&#34;&#34;Whether to spin up an agent for each room or publisher.&#34;&#34;&#34;
    max_retry: int = 16
    &#34;&#34;&#34;Maximum number of times to retry connecting to LiveKit.&#34;&#34;&#34;
    ws_url: str = &#34;ws://localhost:7880&#34;
    &#34;&#34;&#34;URL to connect to the LiveKit server.

    By default it uses ``LIVEKIT_URL`` from environment&#34;&#34;&#34;
    api_key: str | None = None
    &#34;&#34;&#34;API key to authenticate with LiveKit.

    By default it uses ``LIVEKIT_API_KEY`` from environment&#34;&#34;&#34;
    api_secret: str | None = None
    &#34;&#34;&#34;API secret to authenticate with LiveKit.

    By default it uses ``LIVEKIT_API_SECRET`` from environment&#34;&#34;&#34;
    host: str = &#34;&#34;  # default to all interfaces
    port: int | _WorkerEnvOption[int] = _WorkerEnvOption(dev_default=0, prod_default=8081)
    &#34;&#34;&#34;Port for local HTTP server to listen on.

    The HTTP server is used as a health check endpoint.
    &#34;&#34;&#34;

    http_proxy: NotGivenOr[str | None] = NOT_GIVEN
    &#34;&#34;&#34;HTTP proxy used to connect to the LiveKit server.

    By default it uses ``HTTP_PROXY`` or ``HTTPS_PROXY`` from environment
    &#34;&#34;&#34;

    def validate_config(self, devmode: bool):
        load_threshold = _WorkerEnvOption.getvalue(self.load_threshold, devmode)
        if load_threshold &gt; 1 and not devmode:
            logger.warning(
                f&#34;load_threshold in prod env must be less than 1, current value: {load_threshold}&#34;
            )</code></pre>
</details>
<div class="desc"><p>WorkerOptions(entrypoint_fnc: 'Callable[[JobContext], Awaitable[None]]', request_fnc: 'Callable[[JobRequest], Awaitable[None]]' = <function _default_request_fnc at 0x113acb9c0>, prewarm_fnc: 'Callable[[JobProcess], Any]' = <function _default_initialize_process_fnc at 0x1137fd1c0>, load_fnc: 'Callable[[Worker], float] | Callable[[], float]' = <bound method _DefaultLoadCalc.get_load of \<class 'livekit.agents.worker._DefaultLoadCalc'>>, job_executor_type: 'JobExecutorType' = <JobExecutorType.PROCESS: 'process'>, load_threshold: 'float | _WorkerEnvOption[float]' = _WorkerEnvOption(dev_default=inf, prod_default=0.75), job_memory_warn_mb: 'float' = 500, job_memory_limit_mb: 'float' = 0, num_idle_processes: 'int | _WorkerEnvOption[int]' = _WorkerEnvOption(dev_default=0, prod_default=12), shutdown_process_timeout: 'float' = 60.0, initialize_process_timeout: 'float' = 10.0, permissions: 'WorkerPermissions' = <factory>, agent_name: 'str' = '', worker_type: 'WorkerType' = <WorkerType.ROOM: 0>, max_retry: 'int' = 16, ws_url: 'str' = 'ws://localhost:7880', api_key: 'str | None' = None, api_secret: 'str | None' = None, host: 'str' = '', port: 'int | _WorkerEnvOption[int]' = _WorkerEnvOption(dev_default=0, prod_default=8081), http_proxy: 'NotGivenOr[str | None]' = NOT_GIVEN)</p></div>
<h3>Static methods</h3>
<dl>
<dt id="livekit.agents.WorkerOptions.load_fnc"><code class="name flex">
<span>def <span class="ident">load_fnc</span></span>(<span>worker: <a title="livekit.agents.Worker" href="#livekit.agents.Worker">Worker</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.WorkerOptions.agent_name"><code class="name">var <span class="ident">agent_name</span> : str</code></dt>
<dd>
<div class="desc"><p>Set agent_name to enable explicit dispatch. When explicit dispatch is enabled, jobs will not be dispatched to rooms automatically. Instead, you can either specify the agent(s) to be dispatched in the end-user's token, or use the AgentDispatch.createDispatch API</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.api_key"><code class="name">var <span class="ident">api_key</span> : str | None</code></dt>
<dd>
<div class="desc"><p>API key to authenticate with LiveKit.</p>
<p>By default it uses <code>LIVEKIT_API_KEY</code> from environment</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.api_secret"><code class="name">var <span class="ident">api_secret</span> : str | None</code></dt>
<dd>
<div class="desc"><p>API secret to authenticate with LiveKit.</p>
<p>By default it uses <code>LIVEKIT_API_SECRET</code> from environment</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.entrypoint_fnc"><code class="name">var <span class="ident">entrypoint_fnc</span> : Callable[[<a title="livekit.agents.job.JobContext" href="job.html#livekit.agents.job.JobContext">JobContext</a>], Awaitable[None]]</code></dt>
<dd>
<div class="desc"><p>Entrypoint function that will be called when a job is assigned to this worker.</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.host"><code class="name">var <span class="ident">host</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.http_proxy"><code class="name">var <span class="ident">http_proxy</span> : str | <a title="livekit.agents.types.NotGiven" href="types.html#livekit.agents.types.NotGiven">NotGiven</a> | None</code></dt>
<dd>
<div class="desc"><p>HTTP proxy used to connect to the LiveKit server.</p>
<p>By default it uses <code>HTTP_PROXY</code> or <code>HTTPS_PROXY</code> from environment</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.initialize_process_timeout"><code class="name">var <span class="ident">initialize_process_timeout</span> : float</code></dt>
<dd>
<div class="desc"><p>Maximum amount of time to wait for a process to initialize/prewarm</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.job_executor_type"><code class="name">var <span class="ident">job_executor_type</span> : <a title="livekit.agents.job.JobExecutorType" href="job.html#livekit.agents.job.JobExecutorType">JobExecutorType</a></code></dt>
<dd>
<div class="desc"><p>Which executor to use to run jobs. (currently thread or process are supported)</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.job_memory_limit_mb"><code class="name">var <span class="ident">job_memory_limit_mb</span> : float</code></dt>
<dd>
<div class="desc"><p>Maximum memory usage for a job in MB, the job process will be killed if it exceeds this limit.
Defaults to 0 (disabled).</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.job_memory_warn_mb"><code class="name">var <span class="ident">job_memory_warn_mb</span> : float</code></dt>
<dd>
<div class="desc"><p>Memory warning threshold in MB. If the job process exceeds this limit, a warning will be logged.</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.load_threshold"><code class="name">var <span class="ident">load_threshold</span> : float | livekit.agents.worker._WorkerEnvOption[float]</code></dt>
<dd>
<div class="desc"><p>When the load exceeds this threshold, the worker will be marked as unavailable.</p>
<p>Defaults to 0.75 on "production" mode, and is disabled in "development" mode.</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.max_retry"><code class="name">var <span class="ident">max_retry</span> : int</code></dt>
<dd>
<div class="desc"><p>Maximum number of times to retry connecting to LiveKit.</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.num_idle_processes"><code class="name">var <span class="ident">num_idle_processes</span> : int | livekit.agents.worker._WorkerEnvOption[int]</code></dt>
<dd>
<div class="desc"><p>Number of idle processes to keep warm.</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.permissions"><code class="name">var <span class="ident">permissions</span> : <a title="livekit.agents.worker.WorkerPermissions" href="worker.html#livekit.agents.worker.WorkerPermissions">WorkerPermissions</a></code></dt>
<dd>
<div class="desc"><p>Permissions that the agent should join the room with.</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.port"><code class="name">var <span class="ident">port</span> : int | livekit.agents.worker._WorkerEnvOption[int]</code></dt>
<dd>
<div class="desc"><p>Port for local HTTP server to listen on.</p>
<p>The HTTP server is used as a health check endpoint.</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.shutdown_process_timeout"><code class="name">var <span class="ident">shutdown_process_timeout</span> : float</code></dt>
<dd>
<div class="desc"><p>Maximum amount of time to wait for a job to shut down gracefully</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.worker_type"><code class="name">var <span class="ident">worker_type</span> : <a title="livekit.agents.worker.WorkerType" href="worker.html#livekit.agents.worker.WorkerType">WorkerType</a></code></dt>
<dd>
<div class="desc"><p>Whether to spin up an agent for each room or publisher.</p></div>
</dd>
<dt id="livekit.agents.WorkerOptions.ws_url"><code class="name">var <span class="ident">ws_url</span> : str</code></dt>
<dd>
<div class="desc"><p>URL to connect to the LiveKit server.</p>
<p>By default it uses <code>LIVEKIT_URL</code> from environment</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.WorkerOptions.prewarm_fnc"><code class="name flex">
<span>def <span class="ident">prewarm_fnc</span></span>(<span>proc: <a title="livekit.agents.JobProcess" href="#livekit.agents.JobProcess">JobProcess</a>) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _default_initialize_process_fnc(proc: JobProcess) -&gt; Any:
    return</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.WorkerOptions.request_fnc"><code class="name flex">
<span>async def <span class="ident">request_fnc</span></span>(<span>ctx: <a title="livekit.agents.JobRequest" href="#livekit.agents.JobRequest">JobRequest</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def _default_request_fnc(ctx: JobRequest) -&gt; None:
    await ctx.accept()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.WorkerOptions.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, devmode: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, devmode: bool):
    load_threshold = _WorkerEnvOption.getvalue(self.load_threshold, devmode)
    if load_threshold &gt; 1 and not devmode:
        logger.warning(
            f&#34;load_threshold in prod env must be less than 1, current value: {load_threshold}&#34;
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.WorkerPermissions"><code class="flex name class">
<span>class <span class="ident">WorkerPermissions</span></span>
<span>(</span><span>can_publish: bool = True,<br>can_subscribe: bool = True,<br>can_publish_data: bool = True,<br>can_update_metadata: bool = True,<br>can_publish_sources: list[models.TrackSource] = &lt;factory&gt;,<br>hidden: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class WorkerPermissions:
    can_publish: bool = True
    can_subscribe: bool = True
    can_publish_data: bool = True
    can_update_metadata: bool = True
    can_publish_sources: list[models.TrackSource] = field(default_factory=list)
    hidden: bool = False</code></pre>
</details>
<div class="desc"><p>WorkerPermissions(can_publish: 'bool' = True, can_subscribe: 'bool' = True, can_publish_data: 'bool' = True, can_update_metadata: 'bool' = True, can_publish_sources: 'list[models.TrackSource]' = <factory>, hidden: 'bool' = False)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.WorkerPermissions.can_publish"><code class="name">var <span class="ident">can_publish</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.WorkerPermissions.can_publish_data"><code class="name">var <span class="ident">can_publish_data</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.WorkerPermissions.can_publish_sources"><code class="name">var <span class="ident">can_publish_sources</span> : list[<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x10497a250>]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.WorkerPermissions.can_subscribe"><code class="name">var <span class="ident">can_subscribe</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.WorkerPermissions.can_update_metadata"><code class="name">var <span class="ident">can_update_metadata</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.WorkerPermissions.hidden"><code class="name">var <span class="ident">hidden</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.WorkerType"><code class="flex name class">
<span>class <span class="ident">WorkerType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WorkerType(Enum):
    ROOM = agent.JobType.JT_ROOM
    PUBLISHER = agent.JobType.JT_PUBLISHER</code></pre>
</details>
<div class="desc"><p>Create a collection of name/value pairs.</p>
<p>Example enumeration:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     BLUE = 2
...     GREEN = 3
</code></pre>
<p>Access them by:</p>
<ul>
<li>attribute access:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color.RED
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>value lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color(1)
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>name lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color['RED']
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<p>Enumerations can be iterated over, and know how many members they have:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len(Color)
3
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</code></pre>
<p>Methods can be added to enumerations, and members can have their own
attributes &ndash; see the documentation for details.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.WorkerType.PUBLISHER"><code class="name">var <span class="ident">PUBLISHER</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.WorkerType.ROOM"><code class="name">var <span class="ident">ROOM</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="livekit" href="../index.html">livekit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="livekit.agents.cli" href="cli/index.html">livekit.agents.cli</a></code></li>
<li><code><a title="livekit.agents.debug" href="debug/index.html">livekit.agents.debug</a></code></li>
<li><code><a title="livekit.agents.http_server" href="http_server.html">livekit.agents.http_server</a></code></li>
<li><code><a title="livekit.agents.inference_runner" href="inference_runner.html">livekit.agents.inference_runner</a></code></li>
<li><code><a title="livekit.agents.ipc" href="ipc/index.html">livekit.agents.ipc</a></code></li>
<li><code><a title="livekit.agents.job" href="job.html">livekit.agents.job</a></code></li>
<li><code><a title="livekit.agents.jupyter" href="jupyter.html">livekit.agents.jupyter</a></code></li>
<li><code><a title="livekit.agents.llm" href="llm/index.html">livekit.agents.llm</a></code></li>
<li><code><a title="livekit.agents.log" href="log.html">livekit.agents.log</a></code></li>
<li><code><a title="livekit.agents.metrics" href="metrics/index.html">livekit.agents.metrics</a></code></li>
<li><code><a title="livekit.agents.plugin" href="plugin.html">livekit.agents.plugin</a></code></li>
<li><code><a title="livekit.agents.resources" href="resources/index.html">livekit.agents.resources</a></code></li>
<li><code><a title="livekit.agents.stt" href="stt/index.html">livekit.agents.stt</a></code></li>
<li><code><a title="livekit.agents.tokenize" href="tokenize/index.html">livekit.agents.tokenize</a></code></li>
<li><code><a title="livekit.agents.tts" href="tts/index.html">livekit.agents.tts</a></code></li>
<li><code><a title="livekit.agents.types" href="types.html">livekit.agents.types</a></code></li>
<li><code><a title="livekit.agents.utils" href="utils/index.html">livekit.agents.utils</a></code></li>
<li><code><a title="livekit.agents.vad" href="vad.html">livekit.agents.vad</a></code></li>
<li><code><a title="livekit.agents.version" href="version.html">livekit.agents.version</a></code></li>
<li><code><a title="livekit.agents.voice" href="voice/index.html">livekit.agents.voice</a></code></li>
<li><code><a title="livekit.agents.worker" href="worker.html">livekit.agents.worker</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="livekit.agents.function_tool" href="#livekit.agents.function_tool">function_tool</a></code></li>
<li><code><a title="livekit.agents.get_job_context" href="#livekit.agents.get_job_context">get_job_context</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="livekit.agents.APIConnectOptions" href="#livekit.agents.APIConnectOptions">APIConnectOptions</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.APIConnectOptions.max_retry" href="#livekit.agents.APIConnectOptions.max_retry">max_retry</a></code></li>
<li><code><a title="livekit.agents.APIConnectOptions.retry_interval" href="#livekit.agents.APIConnectOptions.retry_interval">retry_interval</a></code></li>
<li><code><a title="livekit.agents.APIConnectOptions.timeout" href="#livekit.agents.APIConnectOptions.timeout">timeout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.APIConnectionError" href="#livekit.agents.APIConnectionError">APIConnectionError</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.APIError" href="#livekit.agents.APIError">APIError</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.APIError.body" href="#livekit.agents.APIError.body">body</a></code></li>
<li><code><a title="livekit.agents.APIError.message" href="#livekit.agents.APIError.message">message</a></code></li>
<li><code><a title="livekit.agents.APIError.retryable" href="#livekit.agents.APIError.retryable">retryable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.APIStatusError" href="#livekit.agents.APIStatusError">APIStatusError</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.APIStatusError.request_id" href="#livekit.agents.APIStatusError.request_id">request_id</a></code></li>
<li><code><a title="livekit.agents.APIStatusError.status_code" href="#livekit.agents.APIStatusError.status_code">status_code</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.APITimeoutError" href="#livekit.agents.APITimeoutError">APITimeoutError</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.Agent" href="#livekit.agents.Agent">Agent</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.Agent.allow_interruptions" href="#livekit.agents.Agent.allow_interruptions">allow_interruptions</a></code></li>
<li><code><a title="livekit.agents.Agent.chat_ctx" href="#livekit.agents.Agent.chat_ctx">chat_ctx</a></code></li>
<li><code><a title="livekit.agents.Agent.default" href="#livekit.agents.Agent.default">default</a></code></li>
<li><code><a title="livekit.agents.Agent.instructions" href="#livekit.agents.Agent.instructions">instructions</a></code></li>
<li><code><a title="livekit.agents.Agent.llm" href="#livekit.agents.Agent.llm">llm</a></code></li>
<li><code><a title="livekit.agents.Agent.llm_node" href="#livekit.agents.Agent.llm_node">llm_node</a></code></li>
<li><code><a title="livekit.agents.Agent.on_enter" href="#livekit.agents.Agent.on_enter">on_enter</a></code></li>
<li><code><a title="livekit.agents.Agent.on_exit" href="#livekit.agents.Agent.on_exit">on_exit</a></code></li>
<li><code><a title="livekit.agents.Agent.on_user_turn_completed" href="#livekit.agents.Agent.on_user_turn_completed">on_user_turn_completed</a></code></li>
<li><code><a title="livekit.agents.Agent.realtime_audio_output_node" href="#livekit.agents.Agent.realtime_audio_output_node">realtime_audio_output_node</a></code></li>
<li><code><a title="livekit.agents.Agent.realtime_llm_session" href="#livekit.agents.Agent.realtime_llm_session">realtime_llm_session</a></code></li>
<li><code><a title="livekit.agents.Agent.session" href="#livekit.agents.Agent.session">session</a></code></li>
<li><code><a title="livekit.agents.Agent.stt" href="#livekit.agents.Agent.stt">stt</a></code></li>
<li><code><a title="livekit.agents.Agent.stt_node" href="#livekit.agents.Agent.stt_node">stt_node</a></code></li>
<li><code><a title="livekit.agents.Agent.tools" href="#livekit.agents.Agent.tools">tools</a></code></li>
<li><code><a title="livekit.agents.Agent.transcription_node" href="#livekit.agents.Agent.transcription_node">transcription_node</a></code></li>
<li><code><a title="livekit.agents.Agent.tts" href="#livekit.agents.Agent.tts">tts</a></code></li>
<li><code><a title="livekit.agents.Agent.tts_node" href="#livekit.agents.Agent.tts_node">tts_node</a></code></li>
<li><code><a title="livekit.agents.Agent.turn_detection" href="#livekit.agents.Agent.turn_detection">turn_detection</a></code></li>
<li><code><a title="livekit.agents.Agent.update_chat_ctx" href="#livekit.agents.Agent.update_chat_ctx">update_chat_ctx</a></code></li>
<li><code><a title="livekit.agents.Agent.update_instructions" href="#livekit.agents.Agent.update_instructions">update_instructions</a></code></li>
<li><code><a title="livekit.agents.Agent.update_tools" href="#livekit.agents.Agent.update_tools">update_tools</a></code></li>
<li><code><a title="livekit.agents.Agent.vad" href="#livekit.agents.Agent.vad">vad</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.AgentSession" href="#livekit.agents.AgentSession">AgentSession</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.AgentSession.aclose" href="#livekit.agents.AgentSession.aclose">aclose</a></code></li>
<li><code><a title="livekit.agents.AgentSession.agent_state" href="#livekit.agents.AgentSession.agent_state">agent_state</a></code></li>
<li><code><a title="livekit.agents.AgentSession.clear_user_turn" href="#livekit.agents.AgentSession.clear_user_turn">clear_user_turn</a></code></li>
<li><code><a title="livekit.agents.AgentSession.commit_user_turn" href="#livekit.agents.AgentSession.commit_user_turn">commit_user_turn</a></code></li>
<li><code><a title="livekit.agents.AgentSession.current_agent" href="#livekit.agents.AgentSession.current_agent">current_agent</a></code></li>
<li><code><a title="livekit.agents.AgentSession.current_speech" href="#livekit.agents.AgentSession.current_speech">current_speech</a></code></li>
<li><code><a title="livekit.agents.AgentSession.drain" href="#livekit.agents.AgentSession.drain">drain</a></code></li>
<li><code><a title="livekit.agents.AgentSession.generate_reply" href="#livekit.agents.AgentSession.generate_reply">generate_reply</a></code></li>
<li><code><a title="livekit.agents.AgentSession.history" href="#livekit.agents.AgentSession.history">history</a></code></li>
<li><code><a title="livekit.agents.AgentSession.input" href="#livekit.agents.AgentSession.input">input</a></code></li>
<li><code><a title="livekit.agents.AgentSession.interrupt" href="#livekit.agents.AgentSession.interrupt">interrupt</a></code></li>
<li><code><a title="livekit.agents.AgentSession.llm" href="#livekit.agents.AgentSession.llm">llm</a></code></li>
<li><code><a title="livekit.agents.AgentSession.options" href="#livekit.agents.AgentSession.options">options</a></code></li>
<li><code><a title="livekit.agents.AgentSession.output" href="#livekit.agents.AgentSession.output">output</a></code></li>
<li><code><a title="livekit.agents.AgentSession.say" href="#livekit.agents.AgentSession.say">say</a></code></li>
<li><code><a title="livekit.agents.AgentSession.start" href="#livekit.agents.AgentSession.start">start</a></code></li>
<li><code><a title="livekit.agents.AgentSession.stt" href="#livekit.agents.AgentSession.stt">stt</a></code></li>
<li><code><a title="livekit.agents.AgentSession.tts" href="#livekit.agents.AgentSession.tts">tts</a></code></li>
<li><code><a title="livekit.agents.AgentSession.turn_detection" href="#livekit.agents.AgentSession.turn_detection">turn_detection</a></code></li>
<li><code><a title="livekit.agents.AgentSession.update_agent" href="#livekit.agents.AgentSession.update_agent">update_agent</a></code></li>
<li><code><a title="livekit.agents.AgentSession.update_options" href="#livekit.agents.AgentSession.update_options">update_options</a></code></li>
<li><code><a title="livekit.agents.AgentSession.user_state" href="#livekit.agents.AgentSession.user_state">user_state</a></code></li>
<li><code><a title="livekit.agents.AgentSession.userdata" href="#livekit.agents.AgentSession.userdata">userdata</a></code></li>
<li><code><a title="livekit.agents.AgentSession.vad" href="#livekit.agents.AgentSession.vad">vad</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.AgentStateChangedEvent" href="#livekit.agents.AgentStateChangedEvent">AgentStateChangedEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.AgentStateChangedEvent.model_config" href="#livekit.agents.AgentStateChangedEvent.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.AgentStateChangedEvent.new_state" href="#livekit.agents.AgentStateChangedEvent.new_state">new_state</a></code></li>
<li><code><a title="livekit.agents.AgentStateChangedEvent.old_state" href="#livekit.agents.AgentStateChangedEvent.old_state">old_state</a></code></li>
<li><code><a title="livekit.agents.AgentStateChangedEvent.type" href="#livekit.agents.AgentStateChangedEvent.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.AssignmentTimeoutError" href="#livekit.agents.AssignmentTimeoutError">AssignmentTimeoutError</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.AudioConfig" href="#livekit.agents.AudioConfig">AudioConfig</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.AudioConfig.probability" href="#livekit.agents.AudioConfig.probability">probability</a></code></li>
<li><code><a title="livekit.agents.AudioConfig.source" href="#livekit.agents.AudioConfig.source">source</a></code></li>
<li><code><a title="livekit.agents.AudioConfig.volume" href="#livekit.agents.AudioConfig.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.AutoSubscribe" href="#livekit.agents.AutoSubscribe">AutoSubscribe</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.AutoSubscribe.AUDIO_ONLY" href="#livekit.agents.AutoSubscribe.AUDIO_ONLY">AUDIO_ONLY</a></code></li>
<li><code><a title="livekit.agents.AutoSubscribe.SUBSCRIBE_ALL" href="#livekit.agents.AutoSubscribe.SUBSCRIBE_ALL">SUBSCRIBE_ALL</a></code></li>
<li><code><a title="livekit.agents.AutoSubscribe.SUBSCRIBE_NONE" href="#livekit.agents.AutoSubscribe.SUBSCRIBE_NONE">SUBSCRIBE_NONE</a></code></li>
<li><code><a title="livekit.agents.AutoSubscribe.VIDEO_ONLY" href="#livekit.agents.AutoSubscribe.VIDEO_ONLY">VIDEO_ONLY</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.BackgroundAudioPlayer" href="#livekit.agents.BackgroundAudioPlayer">BackgroundAudioPlayer</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.BackgroundAudioPlayer.aclose" href="#livekit.agents.BackgroundAudioPlayer.aclose">aclose</a></code></li>
<li><code><a title="livekit.agents.BackgroundAudioPlayer.play" href="#livekit.agents.BackgroundAudioPlayer.play">play</a></code></li>
<li><code><a title="livekit.agents.BackgroundAudioPlayer.start" href="#livekit.agents.BackgroundAudioPlayer.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.BuiltinAudioClip" href="#livekit.agents.BuiltinAudioClip">BuiltinAudioClip</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.BuiltinAudioClip.KEYBOARD_TYPING" href="#livekit.agents.BuiltinAudioClip.KEYBOARD_TYPING">KEYBOARD_TYPING</a></code></li>
<li><code><a title="livekit.agents.BuiltinAudioClip.KEYBOARD_TYPING2" href="#livekit.agents.BuiltinAudioClip.KEYBOARD_TYPING2">KEYBOARD_TYPING2</a></code></li>
<li><code><a title="livekit.agents.BuiltinAudioClip.OFFICE_AMBIENCE" href="#livekit.agents.BuiltinAudioClip.OFFICE_AMBIENCE">OFFICE_AMBIENCE</a></code></li>
<li><code><a title="livekit.agents.BuiltinAudioClip.path" href="#livekit.agents.BuiltinAudioClip.path">path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.ChatContext" href="#livekit.agents.ChatContext">ChatContext</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.ChatContext.add_message" href="#livekit.agents.ChatContext.add_message">add_message</a></code></li>
<li><code><a title="livekit.agents.ChatContext.copy" href="#livekit.agents.ChatContext.copy">copy</a></code></li>
<li><code><a title="livekit.agents.ChatContext.empty" href="#livekit.agents.ChatContext.empty">empty</a></code></li>
<li><code><a title="livekit.agents.ChatContext.find_insertion_index" href="#livekit.agents.ChatContext.find_insertion_index">find_insertion_index</a></code></li>
<li><code><a title="livekit.agents.ChatContext.from_dict" href="#livekit.agents.ChatContext.from_dict">from_dict</a></code></li>
<li><code><a title="livekit.agents.ChatContext.get_by_id" href="#livekit.agents.ChatContext.get_by_id">get_by_id</a></code></li>
<li><code><a title="livekit.agents.ChatContext.index_by_id" href="#livekit.agents.ChatContext.index_by_id">index_by_id</a></code></li>
<li><code><a title="livekit.agents.ChatContext.items" href="#livekit.agents.ChatContext.items">items</a></code></li>
<li><code><a title="livekit.agents.ChatContext.readonly" href="#livekit.agents.ChatContext.readonly">readonly</a></code></li>
<li><code><a title="livekit.agents.ChatContext.to_dict" href="#livekit.agents.ChatContext.to_dict">to_dict</a></code></li>
<li><code><a title="livekit.agents.ChatContext.truncate" href="#livekit.agents.ChatContext.truncate">truncate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.ChatMessage" href="#livekit.agents.ChatMessage">ChatMessage</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.ChatMessage.content" href="#livekit.agents.ChatMessage.content">content</a></code></li>
<li><code><a title="livekit.agents.ChatMessage.created_at" href="#livekit.agents.ChatMessage.created_at">created_at</a></code></li>
<li><code><a title="livekit.agents.ChatMessage.hash" href="#livekit.agents.ChatMessage.hash">hash</a></code></li>
<li><code><a title="livekit.agents.ChatMessage.id" href="#livekit.agents.ChatMessage.id">id</a></code></li>
<li><code><a title="livekit.agents.ChatMessage.interrupted" href="#livekit.agents.ChatMessage.interrupted">interrupted</a></code></li>
<li><code><a title="livekit.agents.ChatMessage.model_config" href="#livekit.agents.ChatMessage.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.ChatMessage.role" href="#livekit.agents.ChatMessage.role">role</a></code></li>
<li><code><a title="livekit.agents.ChatMessage.text_content" href="#livekit.agents.ChatMessage.text_content">text_content</a></code></li>
<li><code><a title="livekit.agents.ChatMessage.type" href="#livekit.agents.ChatMessage.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.CloseEvent" href="#livekit.agents.CloseEvent">CloseEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.CloseEvent.error" href="#livekit.agents.CloseEvent.error">error</a></code></li>
<li><code><a title="livekit.agents.CloseEvent.model_config" href="#livekit.agents.CloseEvent.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.CloseEvent.type" href="#livekit.agents.CloseEvent.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.ConversationItemAddedEvent" href="#livekit.agents.ConversationItemAddedEvent">ConversationItemAddedEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.ConversationItemAddedEvent.item" href="#livekit.agents.ConversationItemAddedEvent.item">item</a></code></li>
<li><code><a title="livekit.agents.ConversationItemAddedEvent.model_config" href="#livekit.agents.ConversationItemAddedEvent.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.ConversationItemAddedEvent.type" href="#livekit.agents.ConversationItemAddedEvent.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.ErrorEvent" href="#livekit.agents.ErrorEvent">ErrorEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.ErrorEvent.error" href="#livekit.agents.ErrorEvent.error">error</a></code></li>
<li><code><a title="livekit.agents.ErrorEvent.model_config" href="#livekit.agents.ErrorEvent.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.ErrorEvent.source" href="#livekit.agents.ErrorEvent.source">source</a></code></li>
<li><code><a title="livekit.agents.ErrorEvent.type" href="#livekit.agents.ErrorEvent.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.FunctionCall" href="#livekit.agents.FunctionCall">FunctionCall</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.FunctionCall.arguments" href="#livekit.agents.FunctionCall.arguments">arguments</a></code></li>
<li><code><a title="livekit.agents.FunctionCall.call_id" href="#livekit.agents.FunctionCall.call_id">call_id</a></code></li>
<li><code><a title="livekit.agents.FunctionCall.id" href="#livekit.agents.FunctionCall.id">id</a></code></li>
<li><code><a title="livekit.agents.FunctionCall.model_config" href="#livekit.agents.FunctionCall.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.FunctionCall.name" href="#livekit.agents.FunctionCall.name">name</a></code></li>
<li><code><a title="livekit.agents.FunctionCall.type" href="#livekit.agents.FunctionCall.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.FunctionCallOutput" href="#livekit.agents.FunctionCallOutput">FunctionCallOutput</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.FunctionCallOutput.call_id" href="#livekit.agents.FunctionCallOutput.call_id">call_id</a></code></li>
<li><code><a title="livekit.agents.FunctionCallOutput.id" href="#livekit.agents.FunctionCallOutput.id">id</a></code></li>
<li><code><a title="livekit.agents.FunctionCallOutput.is_error" href="#livekit.agents.FunctionCallOutput.is_error">is_error</a></code></li>
<li><code><a title="livekit.agents.FunctionCallOutput.model_config" href="#livekit.agents.FunctionCallOutput.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.FunctionCallOutput.name" href="#livekit.agents.FunctionCallOutput.name">name</a></code></li>
<li><code><a title="livekit.agents.FunctionCallOutput.output" href="#livekit.agents.FunctionCallOutput.output">output</a></code></li>
<li><code><a title="livekit.agents.FunctionCallOutput.type" href="#livekit.agents.FunctionCallOutput.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.FunctionTool" href="#livekit.agents.FunctionTool">FunctionTool</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.JobContext" href="#livekit.agents.JobContext">JobContext</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.JobContext.add_participant_entrypoint" href="#livekit.agents.JobContext.add_participant_entrypoint">add_participant_entrypoint</a></code></li>
<li><code><a title="livekit.agents.JobContext.add_shutdown_callback" href="#livekit.agents.JobContext.add_shutdown_callback">add_shutdown_callback</a></code></li>
<li><code><a title="livekit.agents.JobContext.add_sip_participant" href="#livekit.agents.JobContext.add_sip_participant">add_sip_participant</a></code></li>
<li><code><a title="livekit.agents.JobContext.add_tracing_callback" href="#livekit.agents.JobContext.add_tracing_callback">add_tracing_callback</a></code></li>
<li><code><a title="livekit.agents.JobContext.agent" href="#livekit.agents.JobContext.agent">agent</a></code></li>
<li><code><a title="livekit.agents.JobContext.api" href="#livekit.agents.JobContext.api">api</a></code></li>
<li><code><a title="livekit.agents.JobContext.connect" href="#livekit.agents.JobContext.connect">connect</a></code></li>
<li><code><a title="livekit.agents.JobContext.delete_room" href="#livekit.agents.JobContext.delete_room">delete_room</a></code></li>
<li><code><a title="livekit.agents.JobContext.inference_executor" href="#livekit.agents.JobContext.inference_executor">inference_executor</a></code></li>
<li><code><a title="livekit.agents.JobContext.job" href="#livekit.agents.JobContext.job">job</a></code></li>
<li><code><a title="livekit.agents.JobContext.log_context_fields" href="#livekit.agents.JobContext.log_context_fields">log_context_fields</a></code></li>
<li><code><a title="livekit.agents.JobContext.proc" href="#livekit.agents.JobContext.proc">proc</a></code></li>
<li><code><a title="livekit.agents.JobContext.room" href="#livekit.agents.JobContext.room">room</a></code></li>
<li><code><a title="livekit.agents.JobContext.shutdown" href="#livekit.agents.JobContext.shutdown">shutdown</a></code></li>
<li><code><a title="livekit.agents.JobContext.transfer_sip_participant" href="#livekit.agents.JobContext.transfer_sip_participant">transfer_sip_participant</a></code></li>
<li><code><a title="livekit.agents.JobContext.wait_for_participant" href="#livekit.agents.JobContext.wait_for_participant">wait_for_participant</a></code></li>
<li><code><a title="livekit.agents.JobContext.worker_id" href="#livekit.agents.JobContext.worker_id">worker_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.JobExecutorType" href="#livekit.agents.JobExecutorType">JobExecutorType</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.JobExecutorType.PROCESS" href="#livekit.agents.JobExecutorType.PROCESS">PROCESS</a></code></li>
<li><code><a title="livekit.agents.JobExecutorType.THREAD" href="#livekit.agents.JobExecutorType.THREAD">THREAD</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.JobProcess" href="#livekit.agents.JobProcess">JobProcess</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.JobProcess.executor_type" href="#livekit.agents.JobProcess.executor_type">executor_type</a></code></li>
<li><code><a title="livekit.agents.JobProcess.http_proxy" href="#livekit.agents.JobProcess.http_proxy">http_proxy</a></code></li>
<li><code><a title="livekit.agents.JobProcess.pid" href="#livekit.agents.JobProcess.pid">pid</a></code></li>
<li><code><a title="livekit.agents.JobProcess.user_arguments" href="#livekit.agents.JobProcess.user_arguments">user_arguments</a></code></li>
<li><code><a title="livekit.agents.JobProcess.userdata" href="#livekit.agents.JobProcess.userdata">userdata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.JobRequest" href="#livekit.agents.JobRequest">JobRequest</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.JobRequest.accept" href="#livekit.agents.JobRequest.accept">accept</a></code></li>
<li><code><a title="livekit.agents.JobRequest.agent_name" href="#livekit.agents.JobRequest.agent_name">agent_name</a></code></li>
<li><code><a title="livekit.agents.JobRequest.id" href="#livekit.agents.JobRequest.id">id</a></code></li>
<li><code><a title="livekit.agents.JobRequest.job" href="#livekit.agents.JobRequest.job">job</a></code></li>
<li><code><a title="livekit.agents.JobRequest.publisher" href="#livekit.agents.JobRequest.publisher">publisher</a></code></li>
<li><code><a title="livekit.agents.JobRequest.reject" href="#livekit.agents.JobRequest.reject">reject</a></code></li>
<li><code><a title="livekit.agents.JobRequest.room" href="#livekit.agents.JobRequest.room">room</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.MetricsCollectedEvent" href="#livekit.agents.MetricsCollectedEvent">MetricsCollectedEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.MetricsCollectedEvent.metrics" href="#livekit.agents.MetricsCollectedEvent.metrics">metrics</a></code></li>
<li><code><a title="livekit.agents.MetricsCollectedEvent.model_config" href="#livekit.agents.MetricsCollectedEvent.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.MetricsCollectedEvent.type" href="#livekit.agents.MetricsCollectedEvent.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.ModelSettings" href="#livekit.agents.ModelSettings">ModelSettings</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.ModelSettings.tool_choice" href="#livekit.agents.ModelSettings.tool_choice">tool_choice</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.NotGiven" href="#livekit.agents.NotGiven">NotGiven</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.Plugin" href="#livekit.agents.Plugin">Plugin</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.Plugin.download_files" href="#livekit.agents.Plugin.download_files">download_files</a></code></li>
<li><code><a title="livekit.agents.Plugin.emitter" href="#livekit.agents.Plugin.emitter">emitter</a></code></li>
<li><code><a title="livekit.agents.Plugin.logger" href="#livekit.agents.Plugin.logger">logger</a></code></li>
<li><code><a title="livekit.agents.Plugin.package" href="#livekit.agents.Plugin.package">package</a></code></li>
<li><code><a title="livekit.agents.Plugin.register_plugin" href="#livekit.agents.Plugin.register_plugin">register_plugin</a></code></li>
<li><code><a title="livekit.agents.Plugin.registered_plugins" href="#livekit.agents.Plugin.registered_plugins">registered_plugins</a></code></li>
<li><code><a title="livekit.agents.Plugin.title" href="#livekit.agents.Plugin.title">title</a></code></li>
<li><code><a title="livekit.agents.Plugin.version" href="#livekit.agents.Plugin.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.RoomIO" href="#livekit.agents.RoomIO">RoomIO</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.RoomIO.aclose" href="#livekit.agents.RoomIO.aclose">aclose</a></code></li>
<li><code><a title="livekit.agents.RoomIO.audio_input" href="#livekit.agents.RoomIO.audio_input">audio_input</a></code></li>
<li><code><a title="livekit.agents.RoomIO.audio_output" href="#livekit.agents.RoomIO.audio_output">audio_output</a></code></li>
<li><code><a title="livekit.agents.RoomIO.linked_participant" href="#livekit.agents.RoomIO.linked_participant">linked_participant</a></code></li>
<li><code><a title="livekit.agents.RoomIO.set_participant" href="#livekit.agents.RoomIO.set_participant">set_participant</a></code></li>
<li><code><a title="livekit.agents.RoomIO.start" href="#livekit.agents.RoomIO.start">start</a></code></li>
<li><code><a title="livekit.agents.RoomIO.transcription_output" href="#livekit.agents.RoomIO.transcription_output">transcription_output</a></code></li>
<li><code><a title="livekit.agents.RoomIO.unset_participant" href="#livekit.agents.RoomIO.unset_participant">unset_participant</a></code></li>
<li><code><a title="livekit.agents.RoomIO.video_input" href="#livekit.agents.RoomIO.video_input">video_input</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.RoomInputOptions" href="#livekit.agents.RoomInputOptions">RoomInputOptions</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.RoomInputOptions.audio_enabled" href="#livekit.agents.RoomInputOptions.audio_enabled">audio_enabled</a></code></li>
<li><code><a title="livekit.agents.RoomInputOptions.audio_num_channels" href="#livekit.agents.RoomInputOptions.audio_num_channels">audio_num_channels</a></code></li>
<li><code><a title="livekit.agents.RoomInputOptions.audio_sample_rate" href="#livekit.agents.RoomInputOptions.audio_sample_rate">audio_sample_rate</a></code></li>
<li><code><a title="livekit.agents.RoomInputOptions.noise_cancellation" href="#livekit.agents.RoomInputOptions.noise_cancellation">noise_cancellation</a></code></li>
<li><code><a title="livekit.agents.RoomInputOptions.participant_identity" href="#livekit.agents.RoomInputOptions.participant_identity">participant_identity</a></code></li>
<li><code><a title="livekit.agents.RoomInputOptions.participant_kinds" href="#livekit.agents.RoomInputOptions.participant_kinds">participant_kinds</a></code></li>
<li><code><a title="livekit.agents.RoomInputOptions.text_enabled" href="#livekit.agents.RoomInputOptions.text_enabled">text_enabled</a></code></li>
<li><code><a title="livekit.agents.RoomInputOptions.text_input_cb" href="#livekit.agents.RoomInputOptions.text_input_cb">text_input_cb</a></code></li>
<li><code><a title="livekit.agents.RoomInputOptions.video_enabled" href="#livekit.agents.RoomInputOptions.video_enabled">video_enabled</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.RoomOutputOptions" href="#livekit.agents.RoomOutputOptions">RoomOutputOptions</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.RoomOutputOptions.audio_enabled" href="#livekit.agents.RoomOutputOptions.audio_enabled">audio_enabled</a></code></li>
<li><code><a title="livekit.agents.RoomOutputOptions.audio_num_channels" href="#livekit.agents.RoomOutputOptions.audio_num_channels">audio_num_channels</a></code></li>
<li><code><a title="livekit.agents.RoomOutputOptions.audio_publish_options" href="#livekit.agents.RoomOutputOptions.audio_publish_options">audio_publish_options</a></code></li>
<li><code><a title="livekit.agents.RoomOutputOptions.audio_sample_rate" href="#livekit.agents.RoomOutputOptions.audio_sample_rate">audio_sample_rate</a></code></li>
<li><code><a title="livekit.agents.RoomOutputOptions.sync_transcription" href="#livekit.agents.RoomOutputOptions.sync_transcription">sync_transcription</a></code></li>
<li><code><a title="livekit.agents.RoomOutputOptions.transcription_enabled" href="#livekit.agents.RoomOutputOptions.transcription_enabled">transcription_enabled</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.RunContext" href="#livekit.agents.RunContext">RunContext</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.RunContext.function_call" href="#livekit.agents.RunContext.function_call">function_call</a></code></li>
<li><code><a title="livekit.agents.RunContext.session" href="#livekit.agents.RunContext.session">session</a></code></li>
<li><code><a title="livekit.agents.RunContext.speech_handle" href="#livekit.agents.RunContext.speech_handle">speech_handle</a></code></li>
<li><code><a title="livekit.agents.RunContext.userdata" href="#livekit.agents.RunContext.userdata">userdata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.SimulateJobInfo" href="#livekit.agents.SimulateJobInfo">SimulateJobInfo</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.SimulateJobInfo.participant_identity" href="#livekit.agents.SimulateJobInfo.participant_identity">participant_identity</a></code></li>
<li><code><a title="livekit.agents.SimulateJobInfo.room" href="#livekit.agents.SimulateJobInfo.room">room</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.SpeechCreatedEvent" href="#livekit.agents.SpeechCreatedEvent">SpeechCreatedEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.SpeechCreatedEvent.model_config" href="#livekit.agents.SpeechCreatedEvent.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.SpeechCreatedEvent.source" href="#livekit.agents.SpeechCreatedEvent.source">source</a></code></li>
<li><code><a title="livekit.agents.SpeechCreatedEvent.speech_handle" href="#livekit.agents.SpeechCreatedEvent.speech_handle">speech_handle</a></code></li>
<li><code><a title="livekit.agents.SpeechCreatedEvent.type" href="#livekit.agents.SpeechCreatedEvent.type">type</a></code></li>
<li><code><a title="livekit.agents.SpeechCreatedEvent.user_initiated" href="#livekit.agents.SpeechCreatedEvent.user_initiated">user_initiated</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.StopResponse" href="#livekit.agents.StopResponse">StopResponse</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.ToolError" href="#livekit.agents.ToolError">ToolError</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.ToolError.message" href="#livekit.agents.ToolError.message">message</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.UserInputTranscribedEvent" href="#livekit.agents.UserInputTranscribedEvent">UserInputTranscribedEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.UserInputTranscribedEvent.is_final" href="#livekit.agents.UserInputTranscribedEvent.is_final">is_final</a></code></li>
<li><code><a title="livekit.agents.UserInputTranscribedEvent.model_config" href="#livekit.agents.UserInputTranscribedEvent.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.UserInputTranscribedEvent.transcript" href="#livekit.agents.UserInputTranscribedEvent.transcript">transcript</a></code></li>
<li><code><a title="livekit.agents.UserInputTranscribedEvent.type" href="#livekit.agents.UserInputTranscribedEvent.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.UserStateChangedEvent" href="#livekit.agents.UserStateChangedEvent">UserStateChangedEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.UserStateChangedEvent.model_config" href="#livekit.agents.UserStateChangedEvent.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.UserStateChangedEvent.new_state" href="#livekit.agents.UserStateChangedEvent.new_state">new_state</a></code></li>
<li><code><a title="livekit.agents.UserStateChangedEvent.old_state" href="#livekit.agents.UserStateChangedEvent.old_state">old_state</a></code></li>
<li><code><a title="livekit.agents.UserStateChangedEvent.type" href="#livekit.agents.UserStateChangedEvent.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.Worker" href="#livekit.agents.Worker">Worker</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.Worker.aclose" href="#livekit.agents.Worker.aclose">aclose</a></code></li>
<li><code><a title="livekit.agents.Worker.active_jobs" href="#livekit.agents.Worker.active_jobs">active_jobs</a></code></li>
<li><code><a title="livekit.agents.Worker.drain" href="#livekit.agents.Worker.drain">drain</a></code></li>
<li><code><a title="livekit.agents.Worker.id" href="#livekit.agents.Worker.id">id</a></code></li>
<li><code><a title="livekit.agents.Worker.run" href="#livekit.agents.Worker.run">run</a></code></li>
<li><code><a title="livekit.agents.Worker.simulate_job" href="#livekit.agents.Worker.simulate_job">simulate_job</a></code></li>
<li><code><a title="livekit.agents.Worker.worker_info" href="#livekit.agents.Worker.worker_info">worker_info</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.WorkerOptions" href="#livekit.agents.WorkerOptions">WorkerOptions</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.WorkerOptions.agent_name" href="#livekit.agents.WorkerOptions.agent_name">agent_name</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.api_key" href="#livekit.agents.WorkerOptions.api_key">api_key</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.api_secret" href="#livekit.agents.WorkerOptions.api_secret">api_secret</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.entrypoint_fnc" href="#livekit.agents.WorkerOptions.entrypoint_fnc">entrypoint_fnc</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.host" href="#livekit.agents.WorkerOptions.host">host</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.http_proxy" href="#livekit.agents.WorkerOptions.http_proxy">http_proxy</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.initialize_process_timeout" href="#livekit.agents.WorkerOptions.initialize_process_timeout">initialize_process_timeout</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.job_executor_type" href="#livekit.agents.WorkerOptions.job_executor_type">job_executor_type</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.job_memory_limit_mb" href="#livekit.agents.WorkerOptions.job_memory_limit_mb">job_memory_limit_mb</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.job_memory_warn_mb" href="#livekit.agents.WorkerOptions.job_memory_warn_mb">job_memory_warn_mb</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.load_fnc" href="#livekit.agents.WorkerOptions.load_fnc">load_fnc</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.load_threshold" href="#livekit.agents.WorkerOptions.load_threshold">load_threshold</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.max_retry" href="#livekit.agents.WorkerOptions.max_retry">max_retry</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.num_idle_processes" href="#livekit.agents.WorkerOptions.num_idle_processes">num_idle_processes</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.permissions" href="#livekit.agents.WorkerOptions.permissions">permissions</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.port" href="#livekit.agents.WorkerOptions.port">port</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.prewarm_fnc" href="#livekit.agents.WorkerOptions.prewarm_fnc">prewarm_fnc</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.request_fnc" href="#livekit.agents.WorkerOptions.request_fnc">request_fnc</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.shutdown_process_timeout" href="#livekit.agents.WorkerOptions.shutdown_process_timeout">shutdown_process_timeout</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.validate_config" href="#livekit.agents.WorkerOptions.validate_config">validate_config</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.worker_type" href="#livekit.agents.WorkerOptions.worker_type">worker_type</a></code></li>
<li><code><a title="livekit.agents.WorkerOptions.ws_url" href="#livekit.agents.WorkerOptions.ws_url">ws_url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.WorkerPermissions" href="#livekit.agents.WorkerPermissions">WorkerPermissions</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.WorkerPermissions.can_publish" href="#livekit.agents.WorkerPermissions.can_publish">can_publish</a></code></li>
<li><code><a title="livekit.agents.WorkerPermissions.can_publish_data" href="#livekit.agents.WorkerPermissions.can_publish_data">can_publish_data</a></code></li>
<li><code><a title="livekit.agents.WorkerPermissions.can_publish_sources" href="#livekit.agents.WorkerPermissions.can_publish_sources">can_publish_sources</a></code></li>
<li><code><a title="livekit.agents.WorkerPermissions.can_subscribe" href="#livekit.agents.WorkerPermissions.can_subscribe">can_subscribe</a></code></li>
<li><code><a title="livekit.agents.WorkerPermissions.can_update_metadata" href="#livekit.agents.WorkerPermissions.can_update_metadata">can_update_metadata</a></code></li>
<li><code><a title="livekit.agents.WorkerPermissions.hidden" href="#livekit.agents.WorkerPermissions.hidden">hidden</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.WorkerType" href="#livekit.agents.WorkerType">WorkerType</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.WorkerType.PUBLISHER" href="#livekit.agents.WorkerType.PUBLISHER">PUBLISHER</a></code></li>
<li><code><a title="livekit.agents.WorkerType.ROOM" href="#livekit.agents.WorkerType.ROOM">ROOM</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
