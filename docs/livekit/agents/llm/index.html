<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>livekit.agents.llm API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>livekit.agents.llm</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="livekit.agents.llm.chat_context" href="chat_context.html">livekit.agents.llm.chat_context</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.llm.fallback_adapter" href="fallback_adapter.html">livekit.agents.llm.fallback_adapter</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.llm.llm" href="llm.html">livekit.agents.llm.llm</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.llm.realtime" href="realtime.html">livekit.agents.llm.realtime</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.llm.remote_chat_context" href="remote_chat_context.html">livekit.agents.llm.remote_chat_context</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.llm.tool_context" href="tool_context.html">livekit.agents.llm.tool_context</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="livekit.agents.llm.utils" href="utils.html">livekit.agents.llm.utils</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="livekit.agents.llm.find_function_tools"><code class="name flex">
<span>def <span class="ident">find_function_tools</span></span>(<span>cls_or_obj: Any) ‑> list[<a title="livekit.agents.llm.tool_context.FunctionTool" href="tool_context.html#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.tool_context.RawFunctionTool" href="tool_context.html#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_function_tools(cls_or_obj: Any) -&gt; list[FunctionTool | RawFunctionTool]:
    methods: list[FunctionTool | RawFunctionTool] = []
    for _, member in inspect.getmembers(cls_or_obj):
        if is_function_tool(member) or is_raw_function_tool(member):
            methods.append(member)
    return methods</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.function_tool"><code class="name flex">
<span>def <span class="ident">function_tool</span></span>(<span>f: F | Raw_F | None = None,<br>*,<br>name: str | None = None,<br>description: str | None = None,<br>raw_schema: RawFunctionDescription | dict | None = None) ‑> <a title="livekit.agents.llm.tool_context.FunctionTool" href="tool_context.html#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.tool_context.RawFunctionTool" href="tool_context.html#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a> | Callable[[~F | ~Raw_F], <a title="livekit.agents.llm.tool_context.FunctionTool" href="tool_context.html#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.tool_context.RawFunctionTool" href="tool_context.html#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_tool(
    f: F | Raw_F | None = None,
    *,
    name: str | None = None,
    description: str | None = None,
    raw_schema: RawFunctionDescription | dict | None = None,
) -&gt; FunctionTool | RawFunctionTool | Callable[[F | Raw_F], FunctionTool | RawFunctionTool]:
    def deco(func: F | Raw_F) -&gt; RawFunctionTool | FunctionTool:
        if raw_schema is not None:
            if not raw_schema.get(&#34;name&#34;) or not raw_schema.get(&#34;parameters&#34;):
                raise ValueError(&#34;raw function description must contain a name and parameters key&#34;)

            info = _RawFunctionToolInfo(raw_schema={**raw_schema}, name=raw_schema[&#34;name&#34;])
            setattr(func, &#34;__livekit_raw_tool_info&#34;, info)
            return cast(RawFunctionTool, func)
        else:
            from docstring_parser import parse_from_object

            docstring = parse_from_object(func)
            info = _FunctionToolInfo(
                name=name or func.__name__,
                description=description or docstring.description,
            )
            setattr(func, &#34;__livekit_tool_info&#34;, info)
            return cast(FunctionTool, func)

    if f is not None:
        return deco(f)

    return deco</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.is_function_tool"><code class="name flex">
<span>def <span class="ident">is_function_tool</span></span>(<span>f: Callable) ‑> TypeGuard[<a title="livekit.agents.llm.tool_context.FunctionTool" href="tool_context.html#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_function_tool(f: Callable) -&gt; TypeGuard[FunctionTool]:
    return hasattr(f, &#34;__livekit_tool_info&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.is_raw_function_tool"><code class="name flex">
<span>def <span class="ident">is_raw_function_tool</span></span>(<span>f: Callable) ‑> TypeGuard[<a title="livekit.agents.llm.tool_context.RawFunctionTool" href="tool_context.html#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_raw_function_tool(f: Callable) -&gt; TypeGuard[RawFunctionTool]:
    return hasattr(f, &#34;__livekit_raw_tool_info&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="livekit.agents.llm.AudioContent"><code class="flex name class">
<span>class <span class="ident">AudioContent</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioContent(BaseModel):
    type: Literal[&#34;audio_content&#34;] = Field(default=&#34;audio_content&#34;)
    frame: list[rtc.AudioFrame]
    transcript: str | None = None</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.AudioContent.frame"><code class="name">var <span class="ident">frame</span> : list[<a title="livekit.rtc.audio_frame.AudioFrame" href="../../rtc/audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.AudioContent.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.AudioContent.transcript"><code class="name">var <span class="ident">transcript</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.AudioContent.type"><code class="name">var <span class="ident">type</span> : Literal['audio_content']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.AvailabilityChangedEvent"><code class="flex name class">
<span>class <span class="ident">AvailabilityChangedEvent</span></span>
<span>(</span><span>llm: <a title="livekit.agents.llm.LLM" href="#livekit.agents.llm.LLM">LLM</a>,<br>available: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class AvailabilityChangedEvent:
    llm: LLM
    available: bool</code></pre>
</details>
<div class="desc"><p>AvailabilityChangedEvent(llm: 'LLM', available: 'bool')</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.AvailabilityChangedEvent.available"><code class="name">var <span class="ident">available</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.AvailabilityChangedEvent.llm"><code class="name">var <span class="ident">llm</span> : <a title="livekit.agents.llm.llm.LLM" href="llm.html#livekit.agents.llm.llm.LLM">LLM</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.ChatChunk"><code class="flex name class">
<span>class <span class="ident">ChatChunk</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChatChunk(BaseModel):
    id: str
    delta: ChoiceDelta | None = None
    usage: CompletionUsage | None = None</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.ChatChunk.delta"><code class="name">var <span class="ident">delta</span> : <a title="livekit.agents.llm.llm.ChoiceDelta" href="llm.html#livekit.agents.llm.llm.ChoiceDelta">ChoiceDelta</a> | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ChatChunk.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ChatChunk.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ChatChunk.usage"><code class="name">var <span class="ident">usage</span> : <a title="livekit.agents.llm.llm.CompletionUsage" href="llm.html#livekit.agents.llm.llm.CompletionUsage">CompletionUsage</a> | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.ChatContext"><code class="flex name class">
<span>class <span class="ident">ChatContext</span></span>
<span>(</span><span>items: NotGivenOr[list[ChatItem]] = NOT_GIVEN)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChatContext:
    def __init__(self, items: NotGivenOr[list[ChatItem]] = NOT_GIVEN):
        self._items: list[ChatItem] = items if is_given(items) else []

    @classmethod
    def empty(cls) -&gt; ChatContext:
        return cls([])

    @property
    def items(self) -&gt; list[ChatItem]:
        return self._items

    @items.setter
    def items(self, items: list[ChatItem]):
        self._items = items

    def add_message(
        self,
        *,
        role: ChatRole,
        content: list[ChatContent] | str,
        id: NotGivenOr[str] = NOT_GIVEN,
        interrupted: NotGivenOr[bool] = NOT_GIVEN,
        created_at: NotGivenOr[float] = NOT_GIVEN,
    ) -&gt; ChatMessage:
        kwargs = {}
        if is_given(id):
            kwargs[&#34;id&#34;] = id
        if is_given(interrupted):
            kwargs[&#34;interrupted&#34;] = interrupted
        if is_given(created_at):
            kwargs[&#34;created_at&#34;] = created_at

        if isinstance(content, str):
            message = ChatMessage(role=role, content=[content], **kwargs)
        else:
            message = ChatMessage(role=role, content=content, **kwargs)

        self._items.append(message)
        return message

    def get_by_id(self, item_id: str) -&gt; ChatItem | None:
        return next((item for item in self.items if item.id == item_id), None)

    def index_by_id(self, item_id: str) -&gt; int | None:
        return next((i for i, item in enumerate(self.items) if item.id == item_id), None)

    def copy(
        self,
        *,
        exclude_function_call: bool = False,
        exclude_instructions: bool = False,
        tools: NotGivenOr[list[FunctionTool | RawFunctionTool | str | Any]] = NOT_GIVEN,
    ) -&gt; ChatContext:
        items = []

        from .tool_context import (
            get_function_info,
            get_raw_function_info,
            is_function_tool,
            is_raw_function_tool,
        )

        valid_tools = set()
        if is_given(tools):
            for tool in tools:
                if isinstance(tool, str):
                    valid_tools.add(tool)
                elif is_function_tool(tool):
                    valid_tools.add(get_function_info(tool).name)
                elif is_raw_function_tool(tool):
                    valid_tools.add(get_raw_function_info(tool).name)
                # TODO(theomonnom): other tools

        for item in self.items:
            if exclude_function_call and item.type in [
                &#34;function_call&#34;,
                &#34;function_call_output&#34;,
            ]:
                continue

            if (
                exclude_instructions
                and item.type == &#34;message&#34;
                and item.role in [&#34;system&#34;, &#34;developer&#34;]
            ):
                continue

            if (
                is_given(tools)
                and item.type in [&#34;function_call&#34;, &#34;function_call_output&#34;]
                and item.name not in valid_tools
            ):
                continue

            items.append(item)

        return ChatContext(items)

    def truncate(self, *, max_items: int) -&gt; ChatContext:
        &#34;&#34;&#34;Truncate the chat context to the last N items in place.

        Removes leading function calls to avoid partial function outputs.
        Preserves the first system message by adding it back to the beginning.
        &#34;&#34;&#34;
        instructions = next(
            (item for item in self._items if item.type == &#34;message&#34; and item.role == &#34;system&#34;),
            None,
        )

        new_items = self._items[-max_items:]
        # chat ctx shouldn&#39;t start with function_call or function_call_output
        while new_items and new_items[0].type in [
            &#34;function_call&#34;,
            &#34;function_call_output&#34;,
        ]:
            new_items.pop(0)

        if instructions:
            new_items.insert(0, instructions)

        self._items[:] = new_items
        return self

    def to_dict(
        self,
        *,
        exclude_image: bool = True,
        exclude_audio: bool = True,
        exclude_timestamp: bool = True,
        exclude_function_call: bool = False,
    ) -&gt; dict:
        items = []
        for item in self.items:
            if exclude_function_call and item.type in [
                &#34;function_call&#34;,
                &#34;function_call_output&#34;,
            ]:
                continue

            if item.type == &#34;message&#34;:
                item = item.model_copy()
                if exclude_image:
                    item.content = [c for c in item.content if not isinstance(c, ImageContent)]
                if exclude_audio:
                    item.content = [c for c in item.content if not isinstance(c, AudioContent)]

            items.append(item)

        exclude_fields = set()
        if exclude_timestamp:
            exclude_fields.add(&#34;created_at&#34;)

        return {
            &#34;items&#34;: [
                item.model_dump(
                    mode=&#34;json&#34;,
                    exclude_none=True,
                    exclude_defaults=False,
                    exclude=exclude_fields,
                )
                for item in items
            ],
        }

    def find_insertion_index(self, *, created_at: float) -&gt; int:
        &#34;&#34;&#34;
        Returns the index to insert an item by creation time.

        Iterates in reverse, assuming items are sorted by `created_at`.
        Finds the position after the last item with `created_at &lt;=` the given timestamp.
        &#34;&#34;&#34;
        for i in reversed(range(len(self._items))):
            item = self._items[i]
            if item.type == &#34;message&#34; and item.created_at &lt;= created_at:
                return i + 1

        return 0

    @classmethod
    def from_dict(cls, data: dict) -&gt; ChatContext:
        item_adapter = TypeAdapter(list[ChatItem])
        items = item_adapter.validate_python(data[&#34;items&#34;])
        return cls(items)

    @property
    def readonly(self) -&gt; bool:
        return False</code></pre>
</details>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li>livekit.agents.llm.chat_context._ReadOnlyChatContext</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="livekit.agents.llm.ChatContext.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="livekit.agents.llm.chat_context.ChatContext" href="chat_context.html#livekit.agents.llm.chat_context.ChatContext">ChatContext</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.ChatContext.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict) ‑> <a title="livekit.agents.llm.chat_context.ChatContext" href="chat_context.html#livekit.agents.llm.chat_context.ChatContext">ChatContext</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.ChatContext.items"><code class="name">prop <span class="ident">items</span> : list[ChatItem]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def items(self) -&gt; list[ChatItem]:
    return self._items</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.ChatContext.readonly"><code class="name">prop <span class="ident">readonly</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def readonly(self) -&gt; bool:
    return False</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.llm.ChatContext.add_message"><code class="name flex">
<span>def <span class="ident">add_message</span></span>(<span>self,<br>*,<br>role: ChatRole,<br>content: list[ChatContent] | str,<br>id: NotGivenOr[str] = NOT_GIVEN,<br>interrupted: NotGivenOr[bool] = NOT_GIVEN,<br>created_at: NotGivenOr[float] = NOT_GIVEN) ‑> <a title="livekit.agents.llm.chat_context.ChatMessage" href="chat_context.html#livekit.agents.llm.chat_context.ChatMessage">ChatMessage</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_message(
    self,
    *,
    role: ChatRole,
    content: list[ChatContent] | str,
    id: NotGivenOr[str] = NOT_GIVEN,
    interrupted: NotGivenOr[bool] = NOT_GIVEN,
    created_at: NotGivenOr[float] = NOT_GIVEN,
) -&gt; ChatMessage:
    kwargs = {}
    if is_given(id):
        kwargs[&#34;id&#34;] = id
    if is_given(interrupted):
        kwargs[&#34;interrupted&#34;] = interrupted
    if is_given(created_at):
        kwargs[&#34;created_at&#34;] = created_at

    if isinstance(content, str):
        message = ChatMessage(role=role, content=[content], **kwargs)
    else:
        message = ChatMessage(role=role, content=content, **kwargs)

    self._items.append(message)
    return message</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.ChatContext.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self,<br>*,<br>exclude_function_call: bool = False,<br>exclude_instructions: bool = False,<br>tools: NotGivenOr[list[<a title="livekit.agents.llm.FunctionTool" href="#livekit.agents.llm.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.RawFunctionTool" href="#livekit.agents.llm.RawFunctionTool">RawFunctionTool</a> | str | Any]] = NOT_GIVEN) ‑> <a title="livekit.agents.llm.ChatContext" href="#livekit.agents.llm.ChatContext">ChatContext</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(
    self,
    *,
    exclude_function_call: bool = False,
    exclude_instructions: bool = False,
    tools: NotGivenOr[list[FunctionTool | RawFunctionTool | str | Any]] = NOT_GIVEN,
) -&gt; ChatContext:
    items = []

    from .tool_context import (
        get_function_info,
        get_raw_function_info,
        is_function_tool,
        is_raw_function_tool,
    )

    valid_tools = set()
    if is_given(tools):
        for tool in tools:
            if isinstance(tool, str):
                valid_tools.add(tool)
            elif is_function_tool(tool):
                valid_tools.add(get_function_info(tool).name)
            elif is_raw_function_tool(tool):
                valid_tools.add(get_raw_function_info(tool).name)
            # TODO(theomonnom): other tools

    for item in self.items:
        if exclude_function_call and item.type in [
            &#34;function_call&#34;,
            &#34;function_call_output&#34;,
        ]:
            continue

        if (
            exclude_instructions
            and item.type == &#34;message&#34;
            and item.role in [&#34;system&#34;, &#34;developer&#34;]
        ):
            continue

        if (
            is_given(tools)
            and item.type in [&#34;function_call&#34;, &#34;function_call_output&#34;]
            and item.name not in valid_tools
        ):
            continue

        items.append(item)

    return ChatContext(items)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.ChatContext.find_insertion_index"><code class="name flex">
<span>def <span class="ident">find_insertion_index</span></span>(<span>self, *, created_at: float) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_insertion_index(self, *, created_at: float) -&gt; int:
    &#34;&#34;&#34;
    Returns the index to insert an item by creation time.

    Iterates in reverse, assuming items are sorted by `created_at`.
    Finds the position after the last item with `created_at &lt;=` the given timestamp.
    &#34;&#34;&#34;
    for i in reversed(range(len(self._items))):
        item = self._items[i]
        if item.type == &#34;message&#34; and item.created_at &lt;= created_at:
            return i + 1

    return 0</code></pre>
</details>
<div class="desc"><p>Returns the index to insert an item by creation time.</p>
<p>Iterates in reverse, assuming items are sorted by <code>created_at</code>.
Finds the position after the last item with <code>created_at &lt;=</code> the given timestamp.</p></div>
</dd>
<dt id="livekit.agents.llm.ChatContext.get_by_id"><code class="name flex">
<span>def <span class="ident">get_by_id</span></span>(<span>self, item_id: str) ‑> <a title="livekit.agents.llm.chat_context.ChatMessage" href="chat_context.html#livekit.agents.llm.chat_context.ChatMessage">ChatMessage</a> | <a title="livekit.agents.llm.chat_context.FunctionCall" href="chat_context.html#livekit.agents.llm.chat_context.FunctionCall">FunctionCall</a> | <a title="livekit.agents.llm.chat_context.FunctionCallOutput" href="chat_context.html#livekit.agents.llm.chat_context.FunctionCallOutput">FunctionCallOutput</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_id(self, item_id: str) -&gt; ChatItem | None:
    return next((item for item in self.items if item.id == item_id), None)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.ChatContext.index_by_id"><code class="name flex">
<span>def <span class="ident">index_by_id</span></span>(<span>self, item_id: str) ‑> int | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_by_id(self, item_id: str) -&gt; int | None:
    return next((i for i, item in enumerate(self.items) if item.id == item_id), None)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.ChatContext.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self,<br>*,<br>exclude_image: bool = True,<br>exclude_audio: bool = True,<br>exclude_timestamp: bool = True,<br>exclude_function_call: bool = False) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(
    self,
    *,
    exclude_image: bool = True,
    exclude_audio: bool = True,
    exclude_timestamp: bool = True,
    exclude_function_call: bool = False,
) -&gt; dict:
    items = []
    for item in self.items:
        if exclude_function_call and item.type in [
            &#34;function_call&#34;,
            &#34;function_call_output&#34;,
        ]:
            continue

        if item.type == &#34;message&#34;:
            item = item.model_copy()
            if exclude_image:
                item.content = [c for c in item.content if not isinstance(c, ImageContent)]
            if exclude_audio:
                item.content = [c for c in item.content if not isinstance(c, AudioContent)]

        items.append(item)

    exclude_fields = set()
    if exclude_timestamp:
        exclude_fields.add(&#34;created_at&#34;)

    return {
        &#34;items&#34;: [
            item.model_dump(
                mode=&#34;json&#34;,
                exclude_none=True,
                exclude_defaults=False,
                exclude=exclude_fields,
            )
            for item in items
        ],
    }</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.ChatContext.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *, max_items: int) ‑> <a title="livekit.agents.llm.chat_context.ChatContext" href="chat_context.html#livekit.agents.llm.chat_context.ChatContext">ChatContext</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def truncate(self, *, max_items: int) -&gt; ChatContext:
    &#34;&#34;&#34;Truncate the chat context to the last N items in place.

    Removes leading function calls to avoid partial function outputs.
    Preserves the first system message by adding it back to the beginning.
    &#34;&#34;&#34;
    instructions = next(
        (item for item in self._items if item.type == &#34;message&#34; and item.role == &#34;system&#34;),
        None,
    )

    new_items = self._items[-max_items:]
    # chat ctx shouldn&#39;t start with function_call or function_call_output
    while new_items and new_items[0].type in [
        &#34;function_call&#34;,
        &#34;function_call_output&#34;,
    ]:
        new_items.pop(0)

    if instructions:
        new_items.insert(0, instructions)

    self._items[:] = new_items
    return self</code></pre>
</details>
<div class="desc"><p>Truncate the chat context to the last N items in place.</p>
<p>Removes leading function calls to avoid partial function outputs.
Preserves the first system message by adding it back to the beginning.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.ChatMessage"><code class="flex name class">
<span>class <span class="ident">ChatMessage</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChatMessage(BaseModel):
    id: str = Field(default_factory=lambda: utils.shortuuid(&#34;item_&#34;))
    type: Literal[&#34;message&#34;] = &#34;message&#34;
    role: ChatRole
    content: list[ChatContent]
    interrupted: bool = False
    hash: bytes | None = None
    created_at: float = Field(default_factory=time.time)

    @property
    def text_content(self) -&gt; str | None:
        &#34;&#34;&#34;
        Returns a string of all text content in the message.

        Multiple text content items will be joined by a newline.
        &#34;&#34;&#34;
        text_parts = [c for c in self.content if isinstance(c, str)]
        if not text_parts:
            return None
        return &#34;\n&#34;.join(text_parts)</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.ChatMessage.content"><code class="name">var <span class="ident">content</span> : list[<a title="livekit.agents.llm.chat_context.ImageContent" href="chat_context.html#livekit.agents.llm.chat_context.ImageContent">ImageContent</a> | <a title="livekit.agents.llm.chat_context.AudioContent" href="chat_context.html#livekit.agents.llm.chat_context.AudioContent">AudioContent</a> | str]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ChatMessage.created_at"><code class="name">var <span class="ident">created_at</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ChatMessage.hash"><code class="name">var <span class="ident">hash</span> : bytes | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ChatMessage.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ChatMessage.interrupted"><code class="name">var <span class="ident">interrupted</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ChatMessage.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ChatMessage.role"><code class="name">var <span class="ident">role</span> : Literal['developer', 'system', 'user', 'assistant']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ChatMessage.type"><code class="name">var <span class="ident">type</span> : Literal['message']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.ChatMessage.text_content"><code class="name">prop <span class="ident">text_content</span> : str | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text_content(self) -&gt; str | None:
    &#34;&#34;&#34;
    Returns a string of all text content in the message.

    Multiple text content items will be joined by a newline.
    &#34;&#34;&#34;
    text_parts = [c for c in self.content if isinstance(c, str)]
    if not text_parts:
        return None
    return &#34;\n&#34;.join(text_parts)</code></pre>
</details>
<div class="desc"><p>Returns a string of all text content in the message.</p>
<p>Multiple text content items will be joined by a newline.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.ChoiceDelta"><code class="flex name class">
<span>class <span class="ident">ChoiceDelta</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChoiceDelta(BaseModel):
    role: ChatRole | None = None
    content: str | None = None
    tool_calls: list[FunctionToolCall] = Field(default_factory=list)</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.ChoiceDelta.content"><code class="name">var <span class="ident">content</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ChoiceDelta.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ChoiceDelta.role"><code class="name">var <span class="ident">role</span> : Literal['developer', 'system', 'user', 'assistant'] | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ChoiceDelta.tool_calls"><code class="name">var <span class="ident">tool_calls</span> : list[<a title="livekit.agents.llm.llm.FunctionToolCall" href="llm.html#livekit.agents.llm.llm.FunctionToolCall">FunctionToolCall</a>]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.CompletionUsage"><code class="flex name class">
<span>class <span class="ident">CompletionUsage</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompletionUsage(BaseModel):
    completion_tokens: int
    prompt_tokens: int
    prompt_cached_tokens: int = 0
    cache_creation_tokens: int = 0
    cache_read_tokens: int = 0
    total_tokens: int</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.CompletionUsage.cache_creation_tokens"><code class="name">var <span class="ident">cache_creation_tokens</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.CompletionUsage.cache_read_tokens"><code class="name">var <span class="ident">cache_read_tokens</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.CompletionUsage.completion_tokens"><code class="name">var <span class="ident">completion_tokens</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.CompletionUsage.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.CompletionUsage.prompt_cached_tokens"><code class="name">var <span class="ident">prompt_cached_tokens</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.CompletionUsage.prompt_tokens"><code class="name">var <span class="ident">prompt_tokens</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.CompletionUsage.total_tokens"><code class="name">var <span class="ident">total_tokens</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.FallbackAdapter"><code class="flex name class">
<span>class <span class="ident">FallbackAdapter</span></span>
<span>(</span><span>llm: list[<a title="livekit.agents.llm.LLM" href="#livekit.agents.llm.LLM">LLM</a>],<br>*,<br>attempt_timeout: float = 10.0,<br>max_retry_per_llm: int = 1,<br>retry_interval: float = 5)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FallbackAdapter(
    LLM[Literal[&#34;llm_availability_changed&#34;]],
):
    def __init__(
        self,
        llm: list[LLM],
        *,
        attempt_timeout: float = 10.0,
        max_retry_per_llm: int = 1,
        retry_interval: float = 5,
    ) -&gt; None:
        if len(llm) &lt; 1:
            raise ValueError(&#34;at least one LLM instance must be provided.&#34;)

        super().__init__()

        self._llm_instances = llm
        self._attempt_timeout = attempt_timeout
        self._max_retry_per_llm = max_retry_per_llm
        self._retry_interval = retry_interval

        self._status = [
            _LLMStatus(available=True, recovering_task=None) for _ in self._llm_instances
        ]

    def chat(
        self,
        *,
        chat_ctx: ChatContext,
        tools: list[FunctionTool] | None = None,
        conn_options: APIConnectOptions = DEFAULT_FALLBACK_API_CONNECT_OPTIONS,
        parallel_tool_calls: NotGivenOr[bool] = NOT_GIVEN,
        tool_choice: NotGivenOr[ToolChoice] = NOT_GIVEN,
        extra_kwargs: NotGivenOr[dict[str, Any]] = NOT_GIVEN,
    ) -&gt; LLMStream:
        return FallbackLLMStream(
            llm=self,
            conn_options=conn_options,
            chat_ctx=chat_ctx,
            tools=tools,
            parallel_tool_calls=parallel_tool_calls,
            tool_choice=tool_choice,
            extra_kwargs=extra_kwargs,
        )</code></pre>
</details>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livekit.agents.llm.llm.LLM" href="llm.html#livekit.agents.llm.llm.LLM">LLM</a></li>
<li>abc.ABC</li>
<li><a title="livekit.rtc.event_emitter.EventEmitter" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.llm.FallbackAdapter.chat"><code class="name flex">
<span>def <span class="ident">chat</span></span>(<span>self,<br>*,<br>chat_ctx: <a title="livekit.agents.llm.ChatContext" href="#livekit.agents.llm.ChatContext">ChatContext</a>,<br>tools: list[<a title="livekit.agents.llm.FunctionTool" href="#livekit.agents.llm.FunctionTool">FunctionTool</a>] | None = None,<br>conn_options: APIConnectOptions = APIConnectOptions(max_retry=0, retry_interval=2.0, timeout=10.0),<br>parallel_tool_calls: NotGivenOr[bool] = NOT_GIVEN,<br>tool_choice: NotGivenOr[ToolChoice] = NOT_GIVEN,<br>extra_kwargs: NotGivenOr[dict[str, Any]] = NOT_GIVEN) ‑> <a title="livekit.agents.llm.llm.LLMStream" href="llm.html#livekit.agents.llm.llm.LLMStream">LLMStream</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chat(
    self,
    *,
    chat_ctx: ChatContext,
    tools: list[FunctionTool] | None = None,
    conn_options: APIConnectOptions = DEFAULT_FALLBACK_API_CONNECT_OPTIONS,
    parallel_tool_calls: NotGivenOr[bool] = NOT_GIVEN,
    tool_choice: NotGivenOr[ToolChoice] = NOT_GIVEN,
    extra_kwargs: NotGivenOr[dict[str, Any]] = NOT_GIVEN,
) -&gt; LLMStream:
    return FallbackLLMStream(
        llm=self,
        conn_options=conn_options,
        chat_ctx=chat_ctx,
        tools=tools,
        parallel_tool_calls=parallel_tool_calls,
        tool_choice=tool_choice,
        extra_kwargs=extra_kwargs,
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livekit.agents.llm.llm.LLM" href="llm.html#livekit.agents.llm.llm.LLM">LLM</a></b></code>:
<ul class="hlist">
<li><code><a title="livekit.agents.llm.llm.LLM.emit" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.emit">emit</a></code></li>
<li><code><a title="livekit.agents.llm.llm.LLM.off" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.off">off</a></code></li>
<li><code><a title="livekit.agents.llm.llm.LLM.on" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.on">on</a></code></li>
<li><code><a title="livekit.agents.llm.llm.LLM.once" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.once">once</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livekit.agents.llm.FunctionCall"><code class="flex name class">
<span>class <span class="ident">FunctionCall</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FunctionCall(BaseModel):
    id: str = Field(default_factory=lambda: utils.shortuuid(&#34;item_&#34;))
    type: Literal[&#34;function_call&#34;] = &#34;function_call&#34;
    call_id: str
    arguments: str
    name: str</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.FunctionCall.arguments"><code class="name">var <span class="ident">arguments</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionCall.call_id"><code class="name">var <span class="ident">call_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionCall.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionCall.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionCall.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionCall.type"><code class="name">var <span class="ident">type</span> : Literal['function_call']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.FunctionCallOutput"><code class="flex name class">
<span>class <span class="ident">FunctionCallOutput</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FunctionCallOutput(BaseModel):
    id: str = Field(default_factory=lambda: utils.shortuuid(&#34;item_&#34;))
    name: str = Field(default=&#34;&#34;)
    type: Literal[&#34;function_call_output&#34;] = Field(default=&#34;function_call_output&#34;)
    call_id: str
    output: str
    is_error: bool</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.FunctionCallOutput.call_id"><code class="name">var <span class="ident">call_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionCallOutput.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionCallOutput.is_error"><code class="name">var <span class="ident">is_error</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionCallOutput.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionCallOutput.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionCallOutput.output"><code class="name">var <span class="ident">output</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionCallOutput.type"><code class="name">var <span class="ident">type</span> : Literal['function_call_output']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.FunctionTool"><code class="flex name class">
<span>class <span class="ident">FunctionTool</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@runtime_checkable
class FunctionTool(Protocol):
    __livekit_tool_info: _FunctionToolInfo

    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any: ...</code></pre>
</details>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing).</p>
<p>For example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto[T](Protocol):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="livekit.agents.llm.FunctionToolCall"><code class="flex name class">
<span>class <span class="ident">FunctionToolCall</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FunctionToolCall(BaseModel):
    type: Literal[&#34;function&#34;] = &#34;function&#34;
    name: str
    arguments: str
    call_id: str</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.FunctionToolCall.arguments"><code class="name">var <span class="ident">arguments</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionToolCall.call_id"><code class="name">var <span class="ident">call_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionToolCall.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionToolCall.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.FunctionToolCall.type"><code class="name">var <span class="ident">type</span> : Literal['function']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.GenerationCreatedEvent"><code class="flex name class">
<span>class <span class="ident">GenerationCreatedEvent</span></span>
<span>(</span><span>message_stream: AsyncIterable[<a title="livekit.agents.llm.MessageGeneration" href="#livekit.agents.llm.MessageGeneration">MessageGeneration</a>],<br>function_stream: AsyncIterable[<a title="livekit.agents.llm.FunctionCall" href="#livekit.agents.llm.FunctionCall">FunctionCall</a>],<br>user_initiated: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class GenerationCreatedEvent:
    message_stream: AsyncIterable[MessageGeneration]
    function_stream: AsyncIterable[FunctionCall]
    user_initiated: bool
    &#34;&#34;&#34;True if the message was generated by the user using generate_reply()&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>GenerationCreatedEvent(message_stream: 'AsyncIterable[MessageGeneration]', function_stream: 'AsyncIterable[FunctionCall]', user_initiated: 'bool')</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.GenerationCreatedEvent.function_stream"><code class="name">var <span class="ident">function_stream</span> : AsyncIterable[<a title="livekit.agents.llm.chat_context.FunctionCall" href="chat_context.html#livekit.agents.llm.chat_context.FunctionCall">FunctionCall</a>]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.GenerationCreatedEvent.message_stream"><code class="name">var <span class="ident">message_stream</span> : AsyncIterable[<a title="livekit.agents.llm.realtime.MessageGeneration" href="realtime.html#livekit.agents.llm.realtime.MessageGeneration">MessageGeneration</a>]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.GenerationCreatedEvent.user_initiated"><code class="name">var <span class="ident">user_initiated</span> : bool</code></dt>
<dd>
<div class="desc"><p>True if the message was generated by the user using generate_reply()</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.ImageContent"><code class="flex name class">
<span>class <span class="ident">ImageContent</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageContent(BaseModel):
    &#34;&#34;&#34;
    ImageContent is used to input images into the ChatContext on supported LLM providers / plugins.

    You may need to consult your LLM provider&#39;s documentation on supported URL types.

    ```python
    # Pass a VideoFrame directly, which will be automatically converted to a JPEG data URL internally
    async for event in rtc.VideoStream(video_track):
        chat_image = ImageContent(image=event.frame)
        # this instance is now available for your ChatContext

    # Encode your VideoFrame yourself for more control, and pass the result as a data URL (see EncodeOptions for more details)
    from livekit.agents.utils.images import encode, EncodeOptions, ResizeOptions

    image_bytes = encode(
        event.frame,
        EncodeOptions(
            format=&#34;PNG&#34;,
            resize_options=ResizeOptions(width=512, height=512, strategy=&#34;scale_aspect_fit&#34;),
        ),
    )
    chat_image = ImageContent(
        image=f&#34;data:image/png;base64,{base64.b64encode(image_bytes).decode(&#39;utf-8&#39;)}&#34;
    )

    # With an external URL
    chat_image = ImageContent(image=&#34;https://example.com/image.jpg&#34;)
    ```
    &#34;&#34;&#34;  # noqa: E501

    id: str = Field(default_factory=lambda: utils.shortuuid(&#34;img_&#34;))
    &#34;&#34;&#34;
    Unique identifier for the image
    &#34;&#34;&#34;

    type: Literal[&#34;image_content&#34;] = Field(default=&#34;image_content&#34;)

    image: str | rtc.VideoFrame
    &#34;&#34;&#34;
    Either a string URL or a VideoFrame object
    &#34;&#34;&#34;
    inference_width: int | None = None
    &#34;&#34;&#34;
    Resizing parameter for rtc.VideoFrame inputs (ignored for URL images)
    &#34;&#34;&#34;
    inference_height: int | None = None
    &#34;&#34;&#34;
    Resizing parameter for rtc.VideoFrame inputs (ignored for URL images)
    &#34;&#34;&#34;
    inference_detail: Literal[&#34;auto&#34;, &#34;high&#34;, &#34;low&#34;] = &#34;auto&#34;
    &#34;&#34;&#34;
    Detail parameter for LLM provider, if supported.

    Currently only supported by OpenAI (see https://platform.openai.com/docs/guides/vision?lang=node#low-or-high-fidelity-image-understanding)
    &#34;&#34;&#34;
    mime_type: str | None = None
    &#34;&#34;&#34;
    MIME type of the image
    &#34;&#34;&#34;
    _cache: dict[int, Any] = PrivateAttr(default_factory=dict)</code></pre>
</details>
<div class="desc"><p>ImageContent is used to input images into the ChatContext on supported LLM providers / plugins.</p>
<p>You may need to consult your LLM provider's documentation on supported URL types.</p>
<pre><code class="language-python"># Pass a VideoFrame directly, which will be automatically converted to a JPEG data URL internally
async for event in rtc.VideoStream(video_track):
    chat_image = ImageContent(image=event.frame)
    # this instance is now available for your ChatContext

# Encode your VideoFrame yourself for more control, and pass the result as a data URL (see EncodeOptions for more details)
from livekit.agents.utils.images import encode, EncodeOptions, ResizeOptions

image_bytes = encode(
    event.frame,
    EncodeOptions(
        format=&quot;PNG&quot;,
        resize_options=ResizeOptions(width=512, height=512, strategy=&quot;scale_aspect_fit&quot;),
    ),
)
chat_image = ImageContent(
    image=f&quot;data:image/png;base64,{base64.b64encode(image_bytes).decode('utf-8')}&quot;
)

# With an external URL
chat_image = ImageContent(image=&quot;https://example.com/image.jpg&quot;)
</code></pre>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.ImageContent.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"><p>Unique identifier for the image</p></div>
</dd>
<dt id="livekit.agents.llm.ImageContent.image"><code class="name">var <span class="ident">image</span> : str | <a title="livekit.rtc.video_frame.VideoFrame" href="../../rtc/video_frame.html#livekit.rtc.video_frame.VideoFrame">VideoFrame</a></code></dt>
<dd>
<div class="desc"><p>Either a string URL or a VideoFrame object</p></div>
</dd>
<dt id="livekit.agents.llm.ImageContent.inference_detail"><code class="name">var <span class="ident">inference_detail</span> : Literal['auto', 'high', 'low']</code></dt>
<dd>
<div class="desc"><p>Detail parameter for LLM provider, if supported.</p>
<p>Currently only supported by OpenAI (see <a href="https://platform.openai.com/docs/guides/vision?lang=node#low-or-high-fidelity-image-understanding">https://platform.openai.com/docs/guides/vision?lang=node#low-or-high-fidelity-image-understanding</a>)</p></div>
</dd>
<dt id="livekit.agents.llm.ImageContent.inference_height"><code class="name">var <span class="ident">inference_height</span> : int | None</code></dt>
<dd>
<div class="desc"><p>Resizing parameter for rtc.VideoFrame inputs (ignored for URL images)</p></div>
</dd>
<dt id="livekit.agents.llm.ImageContent.inference_width"><code class="name">var <span class="ident">inference_width</span> : int | None</code></dt>
<dd>
<div class="desc"><p>Resizing parameter for rtc.VideoFrame inputs (ignored for URL images)</p></div>
</dd>
<dt id="livekit.agents.llm.ImageContent.mime_type"><code class="name">var <span class="ident">mime_type</span> : str | None</code></dt>
<dd>
<div class="desc"><p>MIME type of the image</p></div>
</dd>
<dt id="livekit.agents.llm.ImageContent.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.ImageContent.type"><code class="name">var <span class="ident">type</span> : Literal['image_content']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.llm.ImageContent.model_post_init"><code class="name flex">
<span>def <span class="ident">model_post_init</span></span>(<span>self: BaseModel, context: Any, /) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_private_attributes(self: BaseModel, context: Any, /) -&gt; None:
    &#34;&#34;&#34;This function is meant to behave like a BaseModel method to initialise private attributes.

    It takes context as an argument since that&#39;s what pydantic-core passes when calling it.

    Args:
        self: The BaseModel instance.
        context: The context.
    &#34;&#34;&#34;
    if getattr(self, &#39;__pydantic_private__&#39;, None) is None:
        pydantic_private = {}
        for name, private_attr in self.__private_attributes__.items():
            default = private_attr.get_default()
            if default is not PydanticUndefined:
                pydantic_private[name] = default
        object_setattr(self, &#39;__pydantic_private__&#39;, pydantic_private)</code></pre>
</details>
<div class="desc"><p>This function is meant to behave like a BaseModel method to initialise private attributes.</p>
<p>It takes context as an argument since that's what pydantic-core passes when calling it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd>The BaseModel instance.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>The context.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.InputSpeechStartedEvent"><code class="flex name class">
<span>class <span class="ident">InputSpeechStartedEvent</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class InputSpeechStartedEvent:
    pass</code></pre>
</details>
<div class="desc"><p>InputSpeechStartedEvent()</p></div>
</dd>
<dt id="livekit.agents.llm.InputSpeechStoppedEvent"><code class="flex name class">
<span>class <span class="ident">InputSpeechStoppedEvent</span></span>
<span>(</span><span>user_transcription_enabled: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class InputSpeechStoppedEvent:
    user_transcription_enabled: bool</code></pre>
</details>
<div class="desc"><p>InputSpeechStoppedEvent(user_transcription_enabled: 'bool')</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.InputSpeechStoppedEvent.user_transcription_enabled"><code class="name">var <span class="ident">user_transcription_enabled</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.InputTranscriptionCompleted"><code class="flex name class">
<span>class <span class="ident">InputTranscriptionCompleted</span></span>
<span>(</span><span>item_id: str, transcript: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class InputTranscriptionCompleted:
    item_id: str
    &#34;&#34;&#34;id of the item&#34;&#34;&#34;
    transcript: str
    &#34;&#34;&#34;transcript of the input audio&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>InputTranscriptionCompleted(item_id: 'str', transcript: 'str')</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.InputTranscriptionCompleted.item_id"><code class="name">var <span class="ident">item_id</span> : str</code></dt>
<dd>
<div class="desc"><p>id of the item</p></div>
</dd>
<dt id="livekit.agents.llm.InputTranscriptionCompleted.transcript"><code class="name">var <span class="ident">transcript</span> : str</code></dt>
<dd>
<div class="desc"><p>transcript of the input audio</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.LLM"><code class="flex name class">
<span>class <span class="ident">LLM</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LLM(
    ABC,
    rtc.EventEmitter[Union[Literal[&#34;metrics_collected&#34;, &#34;error&#34;], TEvent]],
    Generic[TEvent],
):
    def __init__(self) -&gt; None:
        super().__init__()
        self._label = f&#34;{type(self).__module__}.{type(self).__name__}&#34;

    @property
    def label(self) -&gt; str:
        return self._label

    @abstractmethod
    def chat(
        self,
        *,
        chat_ctx: ChatContext,
        tools: list[FunctionTool] | None = None,
        conn_options: APIConnectOptions = DEFAULT_API_CONNECT_OPTIONS,
        parallel_tool_calls: NotGivenOr[bool] = NOT_GIVEN,
        tool_choice: NotGivenOr[ToolChoice] = NOT_GIVEN,
        extra_kwargs: NotGivenOr[dict[str, Any]] = NOT_GIVEN,
    ) -&gt; LLMStream: ...

    async def aclose(self) -&gt; None: ...

    async def __aenter__(self) -&gt; LLM:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc: BaseException | None,
        exc_tb: TracebackType | None,
    ) -&gt; None:
        await self.aclose()</code></pre>
</details>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
<li><a title="livekit.rtc.event_emitter.EventEmitter" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a></li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="livekit.agents.llm.fallback_adapter.FallbackAdapter" href="fallback_adapter.html#livekit.agents.llm.fallback_adapter.FallbackAdapter">FallbackAdapter</a></li>
<li>livekit.plugins.anthropic.llm.LLM</li>
<li><a title="livekit.plugins.aws.llm.LLM" href="../../plugins/aws/llm.html#livekit.plugins.aws.llm.LLM">LLM</a></li>
<li>livekit.plugins.google.llm.LLM</li>
<li>livekit.plugins.openai.llm.LLM</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.LLM.label"><code class="name">prop <span class="ident">label</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def label(self) -&gt; str:
    return self._label</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.llm.LLM.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self) -&gt; None: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.LLM.chat"><code class="name flex">
<span>def <span class="ident">chat</span></span>(<span>self,<br>*,<br>chat_ctx: <a title="livekit.agents.llm.ChatContext" href="#livekit.agents.llm.ChatContext">ChatContext</a>,<br>tools: list[<a title="livekit.agents.llm.FunctionTool" href="#livekit.agents.llm.FunctionTool">FunctionTool</a>] | None = None,<br>conn_options: APIConnectOptions = APIConnectOptions(max_retry=3, retry_interval=2.0, timeout=10.0),<br>parallel_tool_calls: NotGivenOr[bool] = NOT_GIVEN,<br>tool_choice: NotGivenOr[ToolChoice] = NOT_GIVEN,<br>extra_kwargs: NotGivenOr[dict[str, Any]] = NOT_GIVEN) ‑> <a title="livekit.agents.llm.llm.LLMStream" href="llm.html#livekit.agents.llm.llm.LLMStream">LLMStream</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def chat(
    self,
    *,
    chat_ctx: ChatContext,
    tools: list[FunctionTool] | None = None,
    conn_options: APIConnectOptions = DEFAULT_API_CONNECT_OPTIONS,
    parallel_tool_calls: NotGivenOr[bool] = NOT_GIVEN,
    tool_choice: NotGivenOr[ToolChoice] = NOT_GIVEN,
    extra_kwargs: NotGivenOr[dict[str, Any]] = NOT_GIVEN,
) -&gt; LLMStream: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livekit.rtc.event_emitter.EventEmitter" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a></b></code>:
<ul class="hlist">
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.emit" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.emit">emit</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.off" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.off">off</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.on" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.on">on</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.once" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.once">once</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livekit.agents.llm.LLMError"><code class="flex name class">
<span>class <span class="ident">LLMError</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LLMError(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)
    type: Literal[&#34;llm_error&#34;] = &#34;llm_error&#34;
    timestamp: float
    label: str
    error: APIError = Field(..., exclude=True)
    recoverable: bool</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.LLMError.error"><code class="name">var <span class="ident">error</span> : livekit.agents._exceptions.APIError</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.LLMError.label"><code class="name">var <span class="ident">label</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.LLMError.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.LLMError.recoverable"><code class="name">var <span class="ident">recoverable</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.LLMError.timestamp"><code class="name">var <span class="ident">timestamp</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.LLMError.type"><code class="name">var <span class="ident">type</span> : Literal['llm_error']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.LLMStream"><code class="flex name class">
<span>class <span class="ident">LLMStream</span></span>
<span>(</span><span>llm: <a title="livekit.agents.llm.LLM" href="#livekit.agents.llm.LLM">LLM</a>,<br>*,<br>chat_ctx: <a title="livekit.agents.llm.ChatContext" href="#livekit.agents.llm.ChatContext">ChatContext</a>,<br>tools: list[<a title="livekit.agents.llm.FunctionTool" href="#livekit.agents.llm.FunctionTool">FunctionTool</a>],<br>conn_options: APIConnectOptions)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LLMStream(ABC):
    def __init__(
        self,
        llm: LLM,
        *,
        chat_ctx: ChatContext,
        tools: list[FunctionTool],
        conn_options: APIConnectOptions,
    ) -&gt; None:
        self._llm = llm
        self._chat_ctx = chat_ctx
        self._tools = tools
        self._conn_options = conn_options

        self._event_ch = aio.Chan[ChatChunk]()
        self._event_aiter, monitor_aiter = aio.itertools.tee(self._event_ch, 2)
        self._current_attempt_has_error = False
        self._metrics_task = asyncio.create_task(
            self._metrics_monitor_task(monitor_aiter), name=&#34;LLM._metrics_task&#34;
        )

        self._task = asyncio.create_task(self._main_task())
        self._task.add_done_callback(lambda _: self._event_ch.close())

    @abstractmethod
    async def _run(self) -&gt; None: ...

    async def _main_task(self) -&gt; None:
        for i in range(self._conn_options.max_retry + 1):
            try:
                return await self._run()
            except APIError as e:
                if self._conn_options.max_retry == 0 or not e.retryable:
                    self._emit_error(e, recoverable=False)
                    raise
                elif i == self._conn_options.max_retry:
                    self._emit_error(e, recoverable=False)
                    raise APIConnectionError(
                        f&#34;failed to generate LLM completion after {self._conn_options.max_retry + 1} attempts&#34;,  # noqa: E501
                    ) from e

                else:
                    self._emit_error(e, recoverable=True)
                    logger.warning(
                        f&#34;failed to generate LLM completion, retrying in {self._conn_options.retry_interval}s&#34;,  # noqa: E501
                        exc_info=e,
                        extra={
                            &#34;llm&#34;: self._llm._label,
                            &#34;attempt&#34;: i + 1,
                        },
                    )

                await asyncio.sleep(self._conn_options.retry_interval)
                # Reset the flag when retrying
                self._current_attempt_has_error = False

    def _emit_error(self, api_error: APIError, recoverable: bool):
        self._current_attempt_has_error = True
        self._llm.emit(
            &#34;error&#34;,
            LLMError(
                timestamp=time.time(),
                label=self._llm._label,
                error=api_error,
                recoverable=recoverable,
            ),
        )

    @utils.log_exceptions(logger=logger)
    async def _metrics_monitor_task(self, event_aiter: AsyncIterable[ChatChunk]) -&gt; None:
        start_time = time.perf_counter()
        ttft = -1.0
        request_id = &#34;&#34;
        usage: CompletionUsage | None = None

        async for ev in event_aiter:
            request_id = ev.id
            if ttft == -1.0:
                ttft = time.perf_counter() - start_time

            if ev.usage is not None:
                usage = ev.usage

        duration = time.perf_counter() - start_time

        if self._current_attempt_has_error:
            return

        metrics = LLMMetrics(
            timestamp=time.time(),
            request_id=request_id,
            ttft=ttft,
            duration=duration,
            cancelled=self._task.cancelled(),
            label=self._llm._label,
            completion_tokens=usage.completion_tokens if usage else 0,
            prompt_tokens=usage.prompt_tokens if usage else 0,
            prompt_cached_tokens=usage.prompt_cached_tokens if usage else 0,
            total_tokens=usage.total_tokens if usage else 0,
            tokens_per_second=usage.completion_tokens / duration if usage else 0.0,
        )
        self._llm.emit(&#34;metrics_collected&#34;, metrics)

    @property
    def chat_ctx(self) -&gt; ChatContext:
        return self._chat_ctx

    @property
    def tools(self) -&gt; list[FunctionTool]:
        return self._tools

    async def aclose(self) -&gt; None:
        await aio.cancel_and_wait(self._task)
        await self._metrics_task

    async def __anext__(self) -&gt; ChatChunk:
        try:
            val = await self._event_aiter.__anext__()
        except StopAsyncIteration:
            if not self._task.cancelled() and (exc := self._task.exception()):
                raise exc  # noqa: B904

            raise StopAsyncIteration from None

        return val

    def __aiter__(self) -&gt; AsyncIterator[ChatChunk]:
        return self

    async def __aenter__(self) -&gt; LLMStream:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc: BaseException | None,
        exc_tb: TracebackType | None,
    ) -&gt; None:
        await self.aclose()

    def to_str_iterable(self) -&gt; AsyncIterable[str]:
        &#34;&#34;&#34;
        Convert the LLMStream to an async iterable of strings.
        This assumes the stream will not call any tools.
        &#34;&#34;&#34;

        async def _iterable():
            async with self:
                async for chunk in self:
                    if chunk.delta and chunk.delta.content:
                        yield chunk.delta.content

        return _iterable()</code></pre>
</details>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="livekit.agents.llm.fallback_adapter.FallbackLLMStream" href="fallback_adapter.html#livekit.agents.llm.fallback_adapter.FallbackLLMStream">FallbackLLMStream</a></li>
<li>livekit.plugins.anthropic.llm.LLMStream</li>
<li><a title="livekit.plugins.aws.llm.LLMStream" href="../../plugins/aws/llm.html#livekit.plugins.aws.llm.LLMStream">LLMStream</a></li>
<li>livekit.plugins.google.llm.LLMStream</li>
<li>livekit.plugins.openai.llm.LLMStream</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.LLMStream.chat_ctx"><code class="name">prop <span class="ident">chat_ctx</span> : <a title="livekit.agents.llm.ChatContext" href="#livekit.agents.llm.ChatContext">ChatContext</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def chat_ctx(self) -&gt; ChatContext:
    return self._chat_ctx</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.LLMStream.tools"><code class="name">prop <span class="ident">tools</span> : list[<a title="livekit.agents.llm.FunctionTool" href="#livekit.agents.llm.FunctionTool">FunctionTool</a>]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tools(self) -&gt; list[FunctionTool]:
    return self._tools</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.llm.LLMStream.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def aclose(self) -&gt; None:
    await aio.cancel_and_wait(self._task)
    await self._metrics_task</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.LLMStream.to_str_iterable"><code class="name flex">
<span>def <span class="ident">to_str_iterable</span></span>(<span>self) ‑> AsyncIterable[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_str_iterable(self) -&gt; AsyncIterable[str]:
    &#34;&#34;&#34;
    Convert the LLMStream to an async iterable of strings.
    This assumes the stream will not call any tools.
    &#34;&#34;&#34;

    async def _iterable():
        async with self:
            async for chunk in self:
                if chunk.delta and chunk.delta.content:
                    yield chunk.delta.content

    return _iterable()</code></pre>
</details>
<div class="desc"><p>Convert the LLMStream to an async iterable of strings.
This assumes the stream will not call any tools.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.MessageGeneration"><code class="flex name class">
<span>class <span class="ident">MessageGeneration</span></span>
<span>(</span><span>message_id: str,<br>text_stream: AsyncIterable[str],<br>audio_stream: AsyncIterable[rtc.AudioFrame])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class MessageGeneration:
    message_id: str
    text_stream: AsyncIterable[str]  # could be io.TimedString
    audio_stream: AsyncIterable[rtc.AudioFrame]</code></pre>
</details>
<div class="desc"><p>MessageGeneration(message_id: 'str', text_stream: 'AsyncIterable[str]', audio_stream: 'AsyncIterable[rtc.AudioFrame]')</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.MessageGeneration.audio_stream"><code class="name">var <span class="ident">audio_stream</span> : AsyncIterable[<a title="livekit.rtc.audio_frame.AudioFrame" href="../../rtc/audio_frame.html#livekit.rtc.audio_frame.AudioFrame">AudioFrame</a>]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.MessageGeneration.message_id"><code class="name">var <span class="ident">message_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.MessageGeneration.text_stream"><code class="name">var <span class="ident">text_stream</span> : AsyncIterable[str]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.RawFunctionTool"><code class="flex name class">
<span>class <span class="ident">RawFunctionTool</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@runtime_checkable
class RawFunctionTool(Protocol):
    __livekit_raw_tool_info: _RawFunctionToolInfo

    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any: ...</code></pre>
</details>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing).</p>
<p>For example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto[T](Protocol):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="livekit.agents.llm.RealtimeCapabilities"><code class="flex name class">
<span>class <span class="ident">RealtimeCapabilities</span></span>
<span>(</span><span>message_truncation: bool, turn_detection: bool, user_transcription: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RealtimeCapabilities:
    message_truncation: bool
    turn_detection: bool
    user_transcription: bool</code></pre>
</details>
<div class="desc"><p>RealtimeCapabilities(message_truncation: 'bool', turn_detection: 'bool', user_transcription: 'bool')</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.RealtimeCapabilities.message_truncation"><code class="name">var <span class="ident">message_truncation</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.RealtimeCapabilities.turn_detection"><code class="name">var <span class="ident">turn_detection</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.RealtimeCapabilities.user_transcription"><code class="name">var <span class="ident">user_transcription</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.RealtimeError"><code class="flex name class">
<span>class <span class="ident">RealtimeError</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RealtimeError(Exception):
    def __init__(self, message: str) -&gt; None:
        super().__init__(message)</code></pre>
</details>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="livekit.agents.llm.RealtimeModel"><code class="flex name class">
<span>class <span class="ident">RealtimeModel</span></span>
<span>(</span><span>*,<br>capabilities: <a title="livekit.agents.llm.RealtimeCapabilities" href="#livekit.agents.llm.RealtimeCapabilities">RealtimeCapabilities</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RealtimeModel:
    def __init__(self, *, capabilities: RealtimeCapabilities) -&gt; None:
        self._capabilities = capabilities
        self._label = f&#34;{type(self).__module__}.{type(self).__name__}&#34;

    @property
    def capabilities(self) -&gt; RealtimeCapabilities:
        return self._capabilities

    @abstractmethod
    def session(self) -&gt; RealtimeSession: ...

    @abstractmethod
    async def aclose(self) -&gt; None: ...</code></pre>
</details>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="livekit.plugins.google.beta.realtime.realtime_api.RealtimeModel" href="../../plugins/google/beta/realtime/realtime_api.html#livekit.plugins.google.beta.realtime.realtime_api.RealtimeModel">RealtimeModel</a></li>
<li><a title="livekit.plugins.openai.realtime.realtime_model.RealtimeModel" href="../../plugins/openai/realtime/realtime_model.html#livekit.plugins.openai.realtime.realtime_model.RealtimeModel">RealtimeModel</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.RealtimeModel.capabilities"><code class="name">prop <span class="ident">capabilities</span> : <a title="livekit.agents.llm.RealtimeCapabilities" href="#livekit.agents.llm.RealtimeCapabilities">RealtimeCapabilities</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def capabilities(self) -&gt; RealtimeCapabilities:
    return self._capabilities</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.llm.RealtimeModel.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
async def aclose(self) -&gt; None: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeModel.session"><code class="name flex">
<span>def <span class="ident">session</span></span>(<span>self) ‑> <a title="livekit.agents.llm.realtime.RealtimeSession" href="realtime.html#livekit.agents.llm.realtime.RealtimeSession">RealtimeSession</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def session(self) -&gt; RealtimeSession: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.RealtimeModelError"><code class="flex name class">
<span>class <span class="ident">RealtimeModelError</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RealtimeModelError(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)
    type: Literal[&#34;realtime_model_error&#34;] = &#34;realtime_model_error&#34;
    timestamp: float
    label: str
    error: APIError = Field(..., exclude=True)
    recoverable: bool</code></pre>
</details>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.10/concepts/models/">https://docs.pydantic.dev/2.10/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_fields__</code></strong></dt>
<dd>A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</dd>
<dt><strong><code>__pydantic_computed_fields__</code></strong></dt>
<dd>A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.RealtimeModelError.error"><code class="name">var <span class="ident">error</span> : livekit.agents._exceptions.APIError</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.RealtimeModelError.label"><code class="name">var <span class="ident">label</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.RealtimeModelError.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.RealtimeModelError.recoverable"><code class="name">var <span class="ident">recoverable</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.RealtimeModelError.timestamp"><code class="name">var <span class="ident">timestamp</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.RealtimeModelError.type"><code class="name">var <span class="ident">type</span> : Literal['realtime_model_error']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.RealtimeSession"><code class="flex name class">
<span>class <span class="ident">RealtimeSession</span></span>
<span>(</span><span>realtime_model: <a title="livekit.agents.llm.RealtimeModel" href="#livekit.agents.llm.RealtimeModel">RealtimeModel</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RealtimeSession(ABC, rtc.EventEmitter[Union[EventTypes, TEvent]], Generic[TEvent]):
    def __init__(self, realtime_model: RealtimeModel) -&gt; None:
        super().__init__()
        self._realtime_model = realtime_model

    @property
    def realtime_model(self) -&gt; RealtimeModel:
        return self._realtime_model

    @property
    @abstractmethod
    def chat_ctx(self) -&gt; ChatContext: ...

    @property
    @abstractmethod
    def tools(self) -&gt; ToolContext: ...

    @abstractmethod
    async def update_instructions(self, instructions: str) -&gt; None: ...

    @abstractmethod
    async def update_chat_ctx(
        self, chat_ctx: ChatContext
    ) -&gt; None: ...  # can raise RealtimeError on Timeout

    @abstractmethod
    async def update_tools(self, tools: list[FunctionTool | RawFunctionTool | Any]) -&gt; None: ...

    @abstractmethod
    def update_options(self, *, tool_choice: NotGivenOr[ToolChoice | None] = NOT_GIVEN) -&gt; None: ...

    @abstractmethod
    def push_audio(self, frame: rtc.AudioFrame) -&gt; None: ...

    @abstractmethod
    def push_video(self, frame: rtc.VideoFrame) -&gt; None: ...

    @abstractmethod
    def generate_reply(
        self,
        *,
        instructions: NotGivenOr[str] = NOT_GIVEN,
    ) -&gt; asyncio.Future[GenerationCreatedEvent]: ...  # can raise RealtimeError on Timeout

    # commit the input audio buffer to the server
    @abstractmethod
    def commit_audio(self) -&gt; None: ...

    # clear the input audio buffer to the server
    @abstractmethod
    def clear_audio(self) -&gt; None: ...

    # cancel the current generation (do nothing if no generation is in progress)
    @abstractmethod
    def interrupt(self) -&gt; None: ...

    # message_id is the ID of the message to truncate (inside the ChatCtx)
    @abstractmethod
    def truncate(self, *, message_id: str, audio_end_ms: int) -&gt; None: ...

    @abstractmethod
    async def aclose(self) -&gt; None: ...</code></pre>
</details>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
<li><a title="livekit.rtc.event_emitter.EventEmitter" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a></li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="livekit.plugins.google.beta.realtime.realtime_api.RealtimeSession" href="../../plugins/google/beta/realtime/realtime_api.html#livekit.plugins.google.beta.realtime.realtime_api.RealtimeSession">RealtimeSession</a></li>
<li><a title="livekit.plugins.openai.realtime.realtime_model.RealtimeSession" href="../../plugins/openai/realtime/realtime_model.html#livekit.plugins.openai.realtime.realtime_model.RealtimeSession">RealtimeSession</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.RealtimeSession.chat_ctx"><code class="name">prop <span class="ident">chat_ctx</span> : <a title="livekit.agents.llm.ChatContext" href="#livekit.agents.llm.ChatContext">ChatContext</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def chat_ctx(self) -&gt; ChatContext: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeSession.realtime_model"><code class="name">prop <span class="ident">realtime_model</span> : <a title="livekit.agents.llm.RealtimeModel" href="#livekit.agents.llm.RealtimeModel">RealtimeModel</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def realtime_model(self) -&gt; RealtimeModel:
    return self._realtime_model</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeSession.tools"><code class="name">prop <span class="ident">tools</span> : <a title="livekit.agents.llm.ToolContext" href="#livekit.agents.llm.ToolContext">ToolContext</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def tools(self) -&gt; ToolContext: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.llm.RealtimeSession.aclose"><code class="name flex">
<span>async def <span class="ident">aclose</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
async def aclose(self) -&gt; None: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeSession.clear_audio"><code class="name flex">
<span>def <span class="ident">clear_audio</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def clear_audio(self) -&gt; None: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeSession.commit_audio"><code class="name flex">
<span>def <span class="ident">commit_audio</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def commit_audio(self) -&gt; None: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeSession.generate_reply"><code class="name flex">
<span>def <span class="ident">generate_reply</span></span>(<span>self, *, instructions: NotGivenOr[str] = NOT_GIVEN) ‑> _asyncio.Future[<a title="livekit.agents.llm.realtime.GenerationCreatedEvent" href="realtime.html#livekit.agents.llm.realtime.GenerationCreatedEvent">GenerationCreatedEvent</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def generate_reply(
    self,
    *,
    instructions: NotGivenOr[str] = NOT_GIVEN,
) -&gt; asyncio.Future[GenerationCreatedEvent]: ...  # can raise RealtimeError on Timeout</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeSession.interrupt"><code class="name flex">
<span>def <span class="ident">interrupt</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def interrupt(self) -&gt; None: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeSession.push_audio"><code class="name flex">
<span>def <span class="ident">push_audio</span></span>(<span>self, frame: rtc.AudioFrame) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def push_audio(self, frame: rtc.AudioFrame) -&gt; None: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeSession.push_video"><code class="name flex">
<span>def <span class="ident">push_video</span></span>(<span>self, frame: rtc.VideoFrame) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def push_video(self, frame: rtc.VideoFrame) -&gt; None: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeSession.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *, message_id: str, audio_end_ms: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def truncate(self, *, message_id: str, audio_end_ms: int) -&gt; None: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeSession.update_chat_ctx"><code class="name flex">
<span>async def <span class="ident">update_chat_ctx</span></span>(<span>self,<br>chat_ctx: <a title="livekit.agents.llm.ChatContext" href="#livekit.agents.llm.ChatContext">ChatContext</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
async def update_chat_ctx(
    self, chat_ctx: ChatContext
) -&gt; None: ...  # can raise RealtimeError on Timeout</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeSession.update_instructions"><code class="name flex">
<span>async def <span class="ident">update_instructions</span></span>(<span>self, instructions: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
async def update_instructions(self, instructions: str) -&gt; None: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeSession.update_options"><code class="name flex">
<span>def <span class="ident">update_options</span></span>(<span>self, *, tool_choice: NotGivenOr[ToolChoice | None] = NOT_GIVEN) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def update_options(self, *, tool_choice: NotGivenOr[ToolChoice | None] = NOT_GIVEN) -&gt; None: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.RealtimeSession.update_tools"><code class="name flex">
<span>async def <span class="ident">update_tools</span></span>(<span>self,<br>tools: list[<a title="livekit.agents.llm.FunctionTool" href="#livekit.agents.llm.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.RawFunctionTool" href="#livekit.agents.llm.RawFunctionTool">RawFunctionTool</a> | Any]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
async def update_tools(self, tools: list[FunctionTool | RawFunctionTool | Any]) -&gt; None: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livekit.rtc.event_emitter.EventEmitter" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter">EventEmitter</a></b></code>:
<ul class="hlist">
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.emit" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.emit">emit</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.off" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.off">off</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.on" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.on">on</a></code></li>
<li><code><a title="livekit.rtc.event_emitter.EventEmitter.once" href="../../rtc/event_emitter.html#livekit.rtc.event_emitter.EventEmitter.once">once</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livekit.agents.llm.StopResponse"><code class="flex name class">
<span>class <span class="ident">StopResponse</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StopResponse(Exception):
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Exception raised within AI functions.

        This exception can be raised by the user to indicate that
        the agent should not generate a response for the current
        function call.
        &#34;&#34;&#34;
        super().__init__()</code></pre>
</details>
<div class="desc"><p>Common base class for all non-exit exceptions.</p>
<p>Exception raised within AI functions.</p>
<p>This exception can be raised by the user to indicate that
the agent should not generate a response for the current
function call.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="livekit.agents.llm.ToolContext"><code class="flex name class">
<span>class <span class="ident">ToolContext</span></span>
<span>(</span><span>tools: list[<a title="livekit.agents.llm.FunctionTool" href="#livekit.agents.llm.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.RawFunctionTool" href="#livekit.agents.llm.RawFunctionTool">RawFunctionTool</a>])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ToolContext:
    &#34;&#34;&#34;Stateless container for a set of AI functions&#34;&#34;&#34;

    def __init__(self, tools: list[FunctionTool | RawFunctionTool]) -&gt; None:
        self.update_tools(tools)

    @classmethod
    def empty(cls) -&gt; ToolContext:
        return cls([])

    @property
    def function_tools(self) -&gt; dict[str, FunctionTool | RawFunctionTool]:
        return self._tools_map.copy()

    def update_tools(self, tools: list[FunctionTool | RawFunctionTool]) -&gt; None:
        self._tools = tools.copy()

        for method in find_function_tools(self):
            tools.append(method)

        self._tools_map = {}
        for tool in tools:
            if is_raw_function_tool(tool):
                info = get_raw_function_info(tool)
            elif is_function_tool(tool):
                info = get_function_info(tool)
            else:
                # TODO(theomonnom): MCP servers &amp; other tools
                raise ValueError(f&#34;unknown tool type: {type(tool)}&#34;)

            if info.name in self._tools_map:
                raise ValueError(f&#34;duplicate function name: {info.name}&#34;)

            self._tools_map[info.name] = tool

    def copy(self) -&gt; ToolContext:
        return ToolContext(self._tools.copy())</code></pre>
</details>
<div class="desc"><p>Stateless container for a set of AI functions</p></div>
<h3>Static methods</h3>
<dl>
<dt id="livekit.agents.llm.ToolContext.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="livekit.agents.llm.tool_context.ToolContext" href="tool_context.html#livekit.agents.llm.tool_context.ToolContext">ToolContext</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.ToolContext.function_tools"><code class="name">prop <span class="ident">function_tools</span> : dict[str, <a title="livekit.agents.llm.FunctionTool" href="#livekit.agents.llm.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.RawFunctionTool" href="#livekit.agents.llm.RawFunctionTool">RawFunctionTool</a>]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def function_tools(self) -&gt; dict[str, FunctionTool | RawFunctionTool]:
    return self._tools_map.copy()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.llm.ToolContext.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) ‑> <a title="livekit.agents.llm.tool_context.ToolContext" href="tool_context.html#livekit.agents.llm.tool_context.ToolContext">ToolContext</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; ToolContext:
    return ToolContext(self._tools.copy())</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.ToolContext.update_tools"><code class="name flex">
<span>def <span class="ident">update_tools</span></span>(<span>self,<br>tools: list[<a title="livekit.agents.llm.FunctionTool" href="#livekit.agents.llm.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.RawFunctionTool" href="#livekit.agents.llm.RawFunctionTool">RawFunctionTool</a>]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_tools(self, tools: list[FunctionTool | RawFunctionTool]) -&gt; None:
    self._tools = tools.copy()

    for method in find_function_tools(self):
        tools.append(method)

    self._tools_map = {}
    for tool in tools:
        if is_raw_function_tool(tool):
            info = get_raw_function_info(tool)
        elif is_function_tool(tool):
            info = get_function_info(tool)
        else:
            # TODO(theomonnom): MCP servers &amp; other tools
            raise ValueError(f&#34;unknown tool type: {type(tool)}&#34;)

        if info.name in self._tools_map:
            raise ValueError(f&#34;duplicate function name: {info.name}&#34;)

        self._tools_map[info.name] = tool</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.ToolError"><code class="flex name class">
<span>class <span class="ident">ToolError</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ToolError(Exception):
    def __init__(self, message: str) -&gt; None:
        &#34;&#34;&#34;
        Exception raised within AI functions.

        This exception should be raised by users when an error occurs
        in the context of AI operations. The provided message will be
        visible to the LLM, allowing it to understand the context of
        the error during FunctionOutput generation.
        &#34;&#34;&#34;
        super().__init__(message)
        self._message = message

    @property
    def message(self) -&gt; str:
        return self._message</code></pre>
</details>
<div class="desc"><p>Common base class for all non-exit exceptions.</p>
<p>Exception raised within AI functions.</p>
<p>This exception should be raised by users when an error occurs
in the context of AI operations. The provided message will be
visible to the LLM, allowing it to understand the context of
the error during FunctionOutput generation.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.ToolError.message"><code class="name">prop <span class="ident">message</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def message(self) -&gt; str:
    return self._message</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="livekit.agents" href="../index.html">livekit.agents</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="livekit.agents.llm.chat_context" href="chat_context.html">livekit.agents.llm.chat_context</a></code></li>
<li><code><a title="livekit.agents.llm.fallback_adapter" href="fallback_adapter.html">livekit.agents.llm.fallback_adapter</a></code></li>
<li><code><a title="livekit.agents.llm.llm" href="llm.html">livekit.agents.llm.llm</a></code></li>
<li><code><a title="livekit.agents.llm.realtime" href="realtime.html">livekit.agents.llm.realtime</a></code></li>
<li><code><a title="livekit.agents.llm.remote_chat_context" href="remote_chat_context.html">livekit.agents.llm.remote_chat_context</a></code></li>
<li><code><a title="livekit.agents.llm.tool_context" href="tool_context.html">livekit.agents.llm.tool_context</a></code></li>
<li><code><a title="livekit.agents.llm.utils" href="utils.html">livekit.agents.llm.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="livekit.agents.llm.find_function_tools" href="#livekit.agents.llm.find_function_tools">find_function_tools</a></code></li>
<li><code><a title="livekit.agents.llm.function_tool" href="#livekit.agents.llm.function_tool">function_tool</a></code></li>
<li><code><a title="livekit.agents.llm.is_function_tool" href="#livekit.agents.llm.is_function_tool">is_function_tool</a></code></li>
<li><code><a title="livekit.agents.llm.is_raw_function_tool" href="#livekit.agents.llm.is_raw_function_tool">is_raw_function_tool</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="livekit.agents.llm.AudioContent" href="#livekit.agents.llm.AudioContent">AudioContent</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.AudioContent.frame" href="#livekit.agents.llm.AudioContent.frame">frame</a></code></li>
<li><code><a title="livekit.agents.llm.AudioContent.model_config" href="#livekit.agents.llm.AudioContent.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.llm.AudioContent.transcript" href="#livekit.agents.llm.AudioContent.transcript">transcript</a></code></li>
<li><code><a title="livekit.agents.llm.AudioContent.type" href="#livekit.agents.llm.AudioContent.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.AvailabilityChangedEvent" href="#livekit.agents.llm.AvailabilityChangedEvent">AvailabilityChangedEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.AvailabilityChangedEvent.available" href="#livekit.agents.llm.AvailabilityChangedEvent.available">available</a></code></li>
<li><code><a title="livekit.agents.llm.AvailabilityChangedEvent.llm" href="#livekit.agents.llm.AvailabilityChangedEvent.llm">llm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.ChatChunk" href="#livekit.agents.llm.ChatChunk">ChatChunk</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.ChatChunk.delta" href="#livekit.agents.llm.ChatChunk.delta">delta</a></code></li>
<li><code><a title="livekit.agents.llm.ChatChunk.id" href="#livekit.agents.llm.ChatChunk.id">id</a></code></li>
<li><code><a title="livekit.agents.llm.ChatChunk.model_config" href="#livekit.agents.llm.ChatChunk.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.llm.ChatChunk.usage" href="#livekit.agents.llm.ChatChunk.usage">usage</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.ChatContext" href="#livekit.agents.llm.ChatContext">ChatContext</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.ChatContext.add_message" href="#livekit.agents.llm.ChatContext.add_message">add_message</a></code></li>
<li><code><a title="livekit.agents.llm.ChatContext.copy" href="#livekit.agents.llm.ChatContext.copy">copy</a></code></li>
<li><code><a title="livekit.agents.llm.ChatContext.empty" href="#livekit.agents.llm.ChatContext.empty">empty</a></code></li>
<li><code><a title="livekit.agents.llm.ChatContext.find_insertion_index" href="#livekit.agents.llm.ChatContext.find_insertion_index">find_insertion_index</a></code></li>
<li><code><a title="livekit.agents.llm.ChatContext.from_dict" href="#livekit.agents.llm.ChatContext.from_dict">from_dict</a></code></li>
<li><code><a title="livekit.agents.llm.ChatContext.get_by_id" href="#livekit.agents.llm.ChatContext.get_by_id">get_by_id</a></code></li>
<li><code><a title="livekit.agents.llm.ChatContext.index_by_id" href="#livekit.agents.llm.ChatContext.index_by_id">index_by_id</a></code></li>
<li><code><a title="livekit.agents.llm.ChatContext.items" href="#livekit.agents.llm.ChatContext.items">items</a></code></li>
<li><code><a title="livekit.agents.llm.ChatContext.readonly" href="#livekit.agents.llm.ChatContext.readonly">readonly</a></code></li>
<li><code><a title="livekit.agents.llm.ChatContext.to_dict" href="#livekit.agents.llm.ChatContext.to_dict">to_dict</a></code></li>
<li><code><a title="livekit.agents.llm.ChatContext.truncate" href="#livekit.agents.llm.ChatContext.truncate">truncate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.ChatMessage" href="#livekit.agents.llm.ChatMessage">ChatMessage</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.llm.ChatMessage.content" href="#livekit.agents.llm.ChatMessage.content">content</a></code></li>
<li><code><a title="livekit.agents.llm.ChatMessage.created_at" href="#livekit.agents.llm.ChatMessage.created_at">created_at</a></code></li>
<li><code><a title="livekit.agents.llm.ChatMessage.hash" href="#livekit.agents.llm.ChatMessage.hash">hash</a></code></li>
<li><code><a title="livekit.agents.llm.ChatMessage.id" href="#livekit.agents.llm.ChatMessage.id">id</a></code></li>
<li><code><a title="livekit.agents.llm.ChatMessage.interrupted" href="#livekit.agents.llm.ChatMessage.interrupted">interrupted</a></code></li>
<li><code><a title="livekit.agents.llm.ChatMessage.model_config" href="#livekit.agents.llm.ChatMessage.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.llm.ChatMessage.role" href="#livekit.agents.llm.ChatMessage.role">role</a></code></li>
<li><code><a title="livekit.agents.llm.ChatMessage.text_content" href="#livekit.agents.llm.ChatMessage.text_content">text_content</a></code></li>
<li><code><a title="livekit.agents.llm.ChatMessage.type" href="#livekit.agents.llm.ChatMessage.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.ChoiceDelta" href="#livekit.agents.llm.ChoiceDelta">ChoiceDelta</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.ChoiceDelta.content" href="#livekit.agents.llm.ChoiceDelta.content">content</a></code></li>
<li><code><a title="livekit.agents.llm.ChoiceDelta.model_config" href="#livekit.agents.llm.ChoiceDelta.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.llm.ChoiceDelta.role" href="#livekit.agents.llm.ChoiceDelta.role">role</a></code></li>
<li><code><a title="livekit.agents.llm.ChoiceDelta.tool_calls" href="#livekit.agents.llm.ChoiceDelta.tool_calls">tool_calls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.CompletionUsage" href="#livekit.agents.llm.CompletionUsage">CompletionUsage</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.CompletionUsage.cache_creation_tokens" href="#livekit.agents.llm.CompletionUsage.cache_creation_tokens">cache_creation_tokens</a></code></li>
<li><code><a title="livekit.agents.llm.CompletionUsage.cache_read_tokens" href="#livekit.agents.llm.CompletionUsage.cache_read_tokens">cache_read_tokens</a></code></li>
<li><code><a title="livekit.agents.llm.CompletionUsage.completion_tokens" href="#livekit.agents.llm.CompletionUsage.completion_tokens">completion_tokens</a></code></li>
<li><code><a title="livekit.agents.llm.CompletionUsage.model_config" href="#livekit.agents.llm.CompletionUsage.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.llm.CompletionUsage.prompt_cached_tokens" href="#livekit.agents.llm.CompletionUsage.prompt_cached_tokens">prompt_cached_tokens</a></code></li>
<li><code><a title="livekit.agents.llm.CompletionUsage.prompt_tokens" href="#livekit.agents.llm.CompletionUsage.prompt_tokens">prompt_tokens</a></code></li>
<li><code><a title="livekit.agents.llm.CompletionUsage.total_tokens" href="#livekit.agents.llm.CompletionUsage.total_tokens">total_tokens</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.FallbackAdapter" href="#livekit.agents.llm.FallbackAdapter">FallbackAdapter</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.FallbackAdapter.chat" href="#livekit.agents.llm.FallbackAdapter.chat">chat</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.FunctionCall" href="#livekit.agents.llm.FunctionCall">FunctionCall</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.llm.FunctionCall.arguments" href="#livekit.agents.llm.FunctionCall.arguments">arguments</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionCall.call_id" href="#livekit.agents.llm.FunctionCall.call_id">call_id</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionCall.id" href="#livekit.agents.llm.FunctionCall.id">id</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionCall.model_config" href="#livekit.agents.llm.FunctionCall.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionCall.name" href="#livekit.agents.llm.FunctionCall.name">name</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionCall.type" href="#livekit.agents.llm.FunctionCall.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.FunctionCallOutput" href="#livekit.agents.llm.FunctionCallOutput">FunctionCallOutput</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.llm.FunctionCallOutput.call_id" href="#livekit.agents.llm.FunctionCallOutput.call_id">call_id</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionCallOutput.id" href="#livekit.agents.llm.FunctionCallOutput.id">id</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionCallOutput.is_error" href="#livekit.agents.llm.FunctionCallOutput.is_error">is_error</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionCallOutput.model_config" href="#livekit.agents.llm.FunctionCallOutput.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionCallOutput.name" href="#livekit.agents.llm.FunctionCallOutput.name">name</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionCallOutput.output" href="#livekit.agents.llm.FunctionCallOutput.output">output</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionCallOutput.type" href="#livekit.agents.llm.FunctionCallOutput.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.FunctionTool" href="#livekit.agents.llm.FunctionTool">FunctionTool</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.llm.FunctionToolCall" href="#livekit.agents.llm.FunctionToolCall">FunctionToolCall</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.FunctionToolCall.arguments" href="#livekit.agents.llm.FunctionToolCall.arguments">arguments</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionToolCall.call_id" href="#livekit.agents.llm.FunctionToolCall.call_id">call_id</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionToolCall.model_config" href="#livekit.agents.llm.FunctionToolCall.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionToolCall.name" href="#livekit.agents.llm.FunctionToolCall.name">name</a></code></li>
<li><code><a title="livekit.agents.llm.FunctionToolCall.type" href="#livekit.agents.llm.FunctionToolCall.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.GenerationCreatedEvent" href="#livekit.agents.llm.GenerationCreatedEvent">GenerationCreatedEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.GenerationCreatedEvent.function_stream" href="#livekit.agents.llm.GenerationCreatedEvent.function_stream">function_stream</a></code></li>
<li><code><a title="livekit.agents.llm.GenerationCreatedEvent.message_stream" href="#livekit.agents.llm.GenerationCreatedEvent.message_stream">message_stream</a></code></li>
<li><code><a title="livekit.agents.llm.GenerationCreatedEvent.user_initiated" href="#livekit.agents.llm.GenerationCreatedEvent.user_initiated">user_initiated</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.ImageContent" href="#livekit.agents.llm.ImageContent">ImageContent</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.llm.ImageContent.id" href="#livekit.agents.llm.ImageContent.id">id</a></code></li>
<li><code><a title="livekit.agents.llm.ImageContent.image" href="#livekit.agents.llm.ImageContent.image">image</a></code></li>
<li><code><a title="livekit.agents.llm.ImageContent.inference_detail" href="#livekit.agents.llm.ImageContent.inference_detail">inference_detail</a></code></li>
<li><code><a title="livekit.agents.llm.ImageContent.inference_height" href="#livekit.agents.llm.ImageContent.inference_height">inference_height</a></code></li>
<li><code><a title="livekit.agents.llm.ImageContent.inference_width" href="#livekit.agents.llm.ImageContent.inference_width">inference_width</a></code></li>
<li><code><a title="livekit.agents.llm.ImageContent.mime_type" href="#livekit.agents.llm.ImageContent.mime_type">mime_type</a></code></li>
<li><code><a title="livekit.agents.llm.ImageContent.model_config" href="#livekit.agents.llm.ImageContent.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.llm.ImageContent.model_post_init" href="#livekit.agents.llm.ImageContent.model_post_init">model_post_init</a></code></li>
<li><code><a title="livekit.agents.llm.ImageContent.type" href="#livekit.agents.llm.ImageContent.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.InputSpeechStartedEvent" href="#livekit.agents.llm.InputSpeechStartedEvent">InputSpeechStartedEvent</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.llm.InputSpeechStoppedEvent" href="#livekit.agents.llm.InputSpeechStoppedEvent">InputSpeechStoppedEvent</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.InputSpeechStoppedEvent.user_transcription_enabled" href="#livekit.agents.llm.InputSpeechStoppedEvent.user_transcription_enabled">user_transcription_enabled</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.InputTranscriptionCompleted" href="#livekit.agents.llm.InputTranscriptionCompleted">InputTranscriptionCompleted</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.InputTranscriptionCompleted.item_id" href="#livekit.agents.llm.InputTranscriptionCompleted.item_id">item_id</a></code></li>
<li><code><a title="livekit.agents.llm.InputTranscriptionCompleted.transcript" href="#livekit.agents.llm.InputTranscriptionCompleted.transcript">transcript</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.LLM" href="#livekit.agents.llm.LLM">LLM</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.LLM.aclose" href="#livekit.agents.llm.LLM.aclose">aclose</a></code></li>
<li><code><a title="livekit.agents.llm.LLM.chat" href="#livekit.agents.llm.LLM.chat">chat</a></code></li>
<li><code><a title="livekit.agents.llm.LLM.label" href="#livekit.agents.llm.LLM.label">label</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.LLMError" href="#livekit.agents.llm.LLMError">LLMError</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.llm.LLMError.error" href="#livekit.agents.llm.LLMError.error">error</a></code></li>
<li><code><a title="livekit.agents.llm.LLMError.label" href="#livekit.agents.llm.LLMError.label">label</a></code></li>
<li><code><a title="livekit.agents.llm.LLMError.model_config" href="#livekit.agents.llm.LLMError.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.llm.LLMError.recoverable" href="#livekit.agents.llm.LLMError.recoverable">recoverable</a></code></li>
<li><code><a title="livekit.agents.llm.LLMError.timestamp" href="#livekit.agents.llm.LLMError.timestamp">timestamp</a></code></li>
<li><code><a title="livekit.agents.llm.LLMError.type" href="#livekit.agents.llm.LLMError.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.LLMStream" href="#livekit.agents.llm.LLMStream">LLMStream</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.LLMStream.aclose" href="#livekit.agents.llm.LLMStream.aclose">aclose</a></code></li>
<li><code><a title="livekit.agents.llm.LLMStream.chat_ctx" href="#livekit.agents.llm.LLMStream.chat_ctx">chat_ctx</a></code></li>
<li><code><a title="livekit.agents.llm.LLMStream.to_str_iterable" href="#livekit.agents.llm.LLMStream.to_str_iterable">to_str_iterable</a></code></li>
<li><code><a title="livekit.agents.llm.LLMStream.tools" href="#livekit.agents.llm.LLMStream.tools">tools</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.MessageGeneration" href="#livekit.agents.llm.MessageGeneration">MessageGeneration</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.MessageGeneration.audio_stream" href="#livekit.agents.llm.MessageGeneration.audio_stream">audio_stream</a></code></li>
<li><code><a title="livekit.agents.llm.MessageGeneration.message_id" href="#livekit.agents.llm.MessageGeneration.message_id">message_id</a></code></li>
<li><code><a title="livekit.agents.llm.MessageGeneration.text_stream" href="#livekit.agents.llm.MessageGeneration.text_stream">text_stream</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.RawFunctionTool" href="#livekit.agents.llm.RawFunctionTool">RawFunctionTool</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.llm.RealtimeCapabilities" href="#livekit.agents.llm.RealtimeCapabilities">RealtimeCapabilities</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.RealtimeCapabilities.message_truncation" href="#livekit.agents.llm.RealtimeCapabilities.message_truncation">message_truncation</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeCapabilities.turn_detection" href="#livekit.agents.llm.RealtimeCapabilities.turn_detection">turn_detection</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeCapabilities.user_transcription" href="#livekit.agents.llm.RealtimeCapabilities.user_transcription">user_transcription</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.RealtimeError" href="#livekit.agents.llm.RealtimeError">RealtimeError</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.llm.RealtimeModel" href="#livekit.agents.llm.RealtimeModel">RealtimeModel</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.RealtimeModel.aclose" href="#livekit.agents.llm.RealtimeModel.aclose">aclose</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeModel.capabilities" href="#livekit.agents.llm.RealtimeModel.capabilities">capabilities</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeModel.session" href="#livekit.agents.llm.RealtimeModel.session">session</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.RealtimeModelError" href="#livekit.agents.llm.RealtimeModelError">RealtimeModelError</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.llm.RealtimeModelError.error" href="#livekit.agents.llm.RealtimeModelError.error">error</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeModelError.label" href="#livekit.agents.llm.RealtimeModelError.label">label</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeModelError.model_config" href="#livekit.agents.llm.RealtimeModelError.model_config">model_config</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeModelError.recoverable" href="#livekit.agents.llm.RealtimeModelError.recoverable">recoverable</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeModelError.timestamp" href="#livekit.agents.llm.RealtimeModelError.timestamp">timestamp</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeModelError.type" href="#livekit.agents.llm.RealtimeModelError.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.RealtimeSession" href="#livekit.agents.llm.RealtimeSession">RealtimeSession</a></code></h4>
<ul class="two-column">
<li><code><a title="livekit.agents.llm.RealtimeSession.aclose" href="#livekit.agents.llm.RealtimeSession.aclose">aclose</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.chat_ctx" href="#livekit.agents.llm.RealtimeSession.chat_ctx">chat_ctx</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.clear_audio" href="#livekit.agents.llm.RealtimeSession.clear_audio">clear_audio</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.commit_audio" href="#livekit.agents.llm.RealtimeSession.commit_audio">commit_audio</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.generate_reply" href="#livekit.agents.llm.RealtimeSession.generate_reply">generate_reply</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.interrupt" href="#livekit.agents.llm.RealtimeSession.interrupt">interrupt</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.push_audio" href="#livekit.agents.llm.RealtimeSession.push_audio">push_audio</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.push_video" href="#livekit.agents.llm.RealtimeSession.push_video">push_video</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.realtime_model" href="#livekit.agents.llm.RealtimeSession.realtime_model">realtime_model</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.tools" href="#livekit.agents.llm.RealtimeSession.tools">tools</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.truncate" href="#livekit.agents.llm.RealtimeSession.truncate">truncate</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.update_chat_ctx" href="#livekit.agents.llm.RealtimeSession.update_chat_ctx">update_chat_ctx</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.update_instructions" href="#livekit.agents.llm.RealtimeSession.update_instructions">update_instructions</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.update_options" href="#livekit.agents.llm.RealtimeSession.update_options">update_options</a></code></li>
<li><code><a title="livekit.agents.llm.RealtimeSession.update_tools" href="#livekit.agents.llm.RealtimeSession.update_tools">update_tools</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.StopResponse" href="#livekit.agents.llm.StopResponse">StopResponse</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.llm.ToolContext" href="#livekit.agents.llm.ToolContext">ToolContext</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.ToolContext.copy" href="#livekit.agents.llm.ToolContext.copy">copy</a></code></li>
<li><code><a title="livekit.agents.llm.ToolContext.empty" href="#livekit.agents.llm.ToolContext.empty">empty</a></code></li>
<li><code><a title="livekit.agents.llm.ToolContext.function_tools" href="#livekit.agents.llm.ToolContext.function_tools">function_tools</a></code></li>
<li><code><a title="livekit.agents.llm.ToolContext.update_tools" href="#livekit.agents.llm.ToolContext.update_tools">update_tools</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.ToolError" href="#livekit.agents.llm.ToolError">ToolError</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.ToolError.message" href="#livekit.agents.llm.ToolError.message">message</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
