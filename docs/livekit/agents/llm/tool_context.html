<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>livekit.agents.llm.tool_context API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>livekit.agents.llm.tool_context</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="livekit.agents.llm.tool_context.find_function_tools"><code class="name flex">
<span>def <span class="ident">find_function_tools</span></span>(<span>cls_or_obj: Any) ‑> list[<a title="livekit.agents.llm.tool_context.FunctionTool" href="#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.tool_context.RawFunctionTool" href="#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_function_tools(cls_or_obj: Any) -&gt; list[FunctionTool | RawFunctionTool]:
    methods: list[FunctionTool | RawFunctionTool] = []
    for _, member in inspect.getmembers(cls_or_obj):
        if is_function_tool(member) or is_raw_function_tool(member):
            methods.append(member)
    return methods</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.tool_context.function_tool"><code class="name flex">
<span>def <span class="ident">function_tool</span></span>(<span>f: F | Raw_F | None = None,<br>*,<br>name: str | None = None,<br>description: str | None = None,<br>raw_schema: <a title="livekit.agents.llm.tool_context.RawFunctionDescription" href="#livekit.agents.llm.tool_context.RawFunctionDescription">RawFunctionDescription</a> | dict | None = None) ‑> <a title="livekit.agents.llm.tool_context.FunctionTool" href="#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.tool_context.RawFunctionTool" href="#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a> | Callable[[~F | ~Raw_F], <a title="livekit.agents.llm.tool_context.FunctionTool" href="#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.tool_context.RawFunctionTool" href="#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_tool(
    f: F | Raw_F | None = None,
    *,
    name: str | None = None,
    description: str | None = None,
    raw_schema: RawFunctionDescription | dict | None = None,
) -&gt; FunctionTool | RawFunctionTool | Callable[[F | Raw_F], FunctionTool | RawFunctionTool]:
    def deco(func: F | Raw_F) -&gt; RawFunctionTool | FunctionTool:
        if raw_schema is not None:
            if not raw_schema.get(&#34;name&#34;) or not raw_schema.get(&#34;parameters&#34;):
                raise ValueError(&#34;raw function description must contain a name and parameters key&#34;)

            info = _RawFunctionToolInfo(raw_schema={**raw_schema}, name=raw_schema[&#34;name&#34;])
            setattr(func, &#34;__livekit_raw_tool_info&#34;, info)
            return cast(RawFunctionTool, func)
        else:
            from docstring_parser import parse_from_object

            docstring = parse_from_object(func)
            info = _FunctionToolInfo(
                name=name or func.__name__,
                description=description or docstring.description,
            )
            setattr(func, &#34;__livekit_tool_info&#34;, info)
            return cast(FunctionTool, func)

    if f is not None:
        return deco(f)

    return deco</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.tool_context.get_function_info"><code class="name flex">
<span>def <span class="ident">get_function_info</span></span>(<span>f: <a title="livekit.agents.llm.tool_context.FunctionTool" href="#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a>) ‑> livekit.agents.llm.tool_context._FunctionToolInfo</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_info(f: FunctionTool) -&gt; _FunctionToolInfo:
    return getattr(f, &#34;__livekit_tool_info&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.tool_context.get_raw_function_info"><code class="name flex">
<span>def <span class="ident">get_raw_function_info</span></span>(<span>f: <a title="livekit.agents.llm.tool_context.RawFunctionTool" href="#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a>) ‑> livekit.agents.llm.tool_context._RawFunctionToolInfo</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raw_function_info(f: RawFunctionTool) -&gt; _RawFunctionToolInfo:
    return getattr(f, &#34;__livekit_raw_tool_info&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.tool_context.is_function_tool"><code class="name flex">
<span>def <span class="ident">is_function_tool</span></span>(<span>f: Callable) ‑> TypeGuard[<a title="livekit.agents.llm.tool_context.FunctionTool" href="#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_function_tool(f: Callable) -&gt; TypeGuard[FunctionTool]:
    return hasattr(f, &#34;__livekit_tool_info&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.tool_context.is_raw_function_tool"><code class="name flex">
<span>def <span class="ident">is_raw_function_tool</span></span>(<span>f: Callable) ‑> TypeGuard[<a title="livekit.agents.llm.tool_context.RawFunctionTool" href="#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_raw_function_tool(f: Callable) -&gt; TypeGuard[RawFunctionTool]:
    return hasattr(f, &#34;__livekit_raw_tool_info&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="livekit.agents.llm.tool_context.Function"><code class="flex name class">
<span>class <span class="ident">Function</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Function(TypedDict, total=False):
    name: Required[str]</code></pre>
</details>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.tool_context.Function.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.tool_context.FunctionTool"><code class="flex name class">
<span>class <span class="ident">FunctionTool</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@runtime_checkable
class FunctionTool(Protocol):
    __livekit_tool_info: _FunctionToolInfo

    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any: ...</code></pre>
</details>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing).</p>
<p>For example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto[T](Protocol):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="livekit.agents.llm.tool_context.NamedToolChoice"><code class="flex name class">
<span>class <span class="ident">NamedToolChoice</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NamedToolChoice(TypedDict, total=False):
    type: Required[Literal[&#34;function&#34;]]
    function: Required[Function]</code></pre>
</details>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.tool_context.NamedToolChoice.function"><code class="name">var <span class="ident">function</span> : <a title="livekit.agents.llm.tool_context.Function" href="#livekit.agents.llm.tool_context.Function">Function</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.tool_context.NamedToolChoice.type"><code class="name">var <span class="ident">type</span> : Literal['function']</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.tool_context.RawFunctionDescription"><code class="flex name class">
<span>class <span class="ident">RawFunctionDescription</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RawFunctionDescription(TypedDict):
    &#34;&#34;&#34;
    Represents the raw function schema format used in LLM function calling APIs.

    This structure directly maps to OpenAI&#39;s function definition format as documented at:
    https://platform.openai.com/docs/guides/function-calling?api-mode=responses

    It is also compatible with other LLM providers that support raw JSON Schema-based
    function definitions.
    &#34;&#34;&#34;

    name: str
    description: NotRequired[str]
    parameters: dict[str, object]</code></pre>
</details>
<div class="desc"><p>Represents the raw function schema format used in LLM function calling APIs.</p>
<p>This structure directly maps to OpenAI's function definition format as documented at:
<a href="https://platform.openai.com/docs/guides/function-calling?api-mode=responses">https://platform.openai.com/docs/guides/function-calling?api-mode=responses</a></p>
<p>It is also compatible with other LLM providers that support raw JSON Schema-based
function definitions.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="livekit.agents.llm.tool_context.RawFunctionDescription.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.tool_context.RawFunctionDescription.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="livekit.agents.llm.tool_context.RawFunctionDescription.parameters"><code class="name">var <span class="ident">parameters</span> : dict[str, object]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.tool_context.RawFunctionTool"><code class="flex name class">
<span>class <span class="ident">RawFunctionTool</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@runtime_checkable
class RawFunctionTool(Protocol):
    __livekit_raw_tool_info: _RawFunctionToolInfo

    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any: ...</code></pre>
</details>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing).</p>
<p>For example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto[T](Protocol):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="livekit.agents.llm.tool_context.StopResponse"><code class="flex name class">
<span>class <span class="ident">StopResponse</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StopResponse(Exception):
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Exception raised within AI functions.

        This exception can be raised by the user to indicate that
        the agent should not generate a response for the current
        function call.
        &#34;&#34;&#34;
        super().__init__()</code></pre>
</details>
<div class="desc"><p>Common base class for all non-exit exceptions.</p>
<p>Exception raised within AI functions.</p>
<p>This exception can be raised by the user to indicate that
the agent should not generate a response for the current
function call.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="livekit.agents.llm.tool_context.ToolContext"><code class="flex name class">
<span>class <span class="ident">ToolContext</span></span>
<span>(</span><span>tools: list[<a title="livekit.agents.llm.tool_context.FunctionTool" href="#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.tool_context.RawFunctionTool" href="#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a>])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ToolContext:
    &#34;&#34;&#34;Stateless container for a set of AI functions&#34;&#34;&#34;

    def __init__(self, tools: list[FunctionTool | RawFunctionTool]) -&gt; None:
        self.update_tools(tools)

    @classmethod
    def empty(cls) -&gt; ToolContext:
        return cls([])

    @property
    def function_tools(self) -&gt; dict[str, FunctionTool | RawFunctionTool]:
        return self._tools_map.copy()

    def update_tools(self, tools: list[FunctionTool | RawFunctionTool]) -&gt; None:
        self._tools = tools.copy()

        for method in find_function_tools(self):
            tools.append(method)

        self._tools_map = {}
        for tool in tools:
            if is_raw_function_tool(tool):
                info = get_raw_function_info(tool)
            elif is_function_tool(tool):
                info = get_function_info(tool)
            else:
                # TODO(theomonnom): MCP servers &amp; other tools
                raise ValueError(f&#34;unknown tool type: {type(tool)}&#34;)

            if info.name in self._tools_map:
                raise ValueError(f&#34;duplicate function name: {info.name}&#34;)

            self._tools_map[info.name] = tool

    def copy(self) -&gt; ToolContext:
        return ToolContext(self._tools.copy())</code></pre>
</details>
<div class="desc"><p>Stateless container for a set of AI functions</p></div>
<h3>Static methods</h3>
<dl>
<dt id="livekit.agents.llm.tool_context.ToolContext.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="livekit.agents.llm.tool_context.ToolContext" href="#livekit.agents.llm.tool_context.ToolContext">ToolContext</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.tool_context.ToolContext.function_tools"><code class="name">prop <span class="ident">function_tools</span> : dict[str, <a title="livekit.agents.llm.tool_context.FunctionTool" href="#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.tool_context.RawFunctionTool" href="#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a>]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def function_tools(self) -&gt; dict[str, FunctionTool | RawFunctionTool]:
    return self._tools_map.copy()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="livekit.agents.llm.tool_context.ToolContext.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) ‑> <a title="livekit.agents.llm.tool_context.ToolContext" href="#livekit.agents.llm.tool_context.ToolContext">ToolContext</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; ToolContext:
    return ToolContext(self._tools.copy())</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="livekit.agents.llm.tool_context.ToolContext.update_tools"><code class="name flex">
<span>def <span class="ident">update_tools</span></span>(<span>self,<br>tools: list[<a title="livekit.agents.llm.tool_context.FunctionTool" href="#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a> | <a title="livekit.agents.llm.tool_context.RawFunctionTool" href="#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a>]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_tools(self, tools: list[FunctionTool | RawFunctionTool]) -&gt; None:
    self._tools = tools.copy()

    for method in find_function_tools(self):
        tools.append(method)

    self._tools_map = {}
    for tool in tools:
        if is_raw_function_tool(tool):
            info = get_raw_function_info(tool)
        elif is_function_tool(tool):
            info = get_function_info(tool)
        else:
            # TODO(theomonnom): MCP servers &amp; other tools
            raise ValueError(f&#34;unknown tool type: {type(tool)}&#34;)

        if info.name in self._tools_map:
            raise ValueError(f&#34;duplicate function name: {info.name}&#34;)

        self._tools_map[info.name] = tool</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="livekit.agents.llm.tool_context.ToolError"><code class="flex name class">
<span>class <span class="ident">ToolError</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ToolError(Exception):
    def __init__(self, message: str) -&gt; None:
        &#34;&#34;&#34;
        Exception raised within AI functions.

        This exception should be raised by users when an error occurs
        in the context of AI operations. The provided message will be
        visible to the LLM, allowing it to understand the context of
        the error during FunctionOutput generation.
        &#34;&#34;&#34;
        super().__init__(message)
        self._message = message

    @property
    def message(self) -&gt; str:
        return self._message</code></pre>
</details>
<div class="desc"><p>Common base class for all non-exit exceptions.</p>
<p>Exception raised within AI functions.</p>
<p>This exception should be raised by users when an error occurs
in the context of AI operations. The provided message will be
visible to the LLM, allowing it to understand the context of
the error during FunctionOutput generation.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="livekit.agents.llm.tool_context.ToolError.message"><code class="name">prop <span class="ident">message</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def message(self) -&gt; str:
    return self._message</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="livekit.agents.llm" href="index.html">livekit.agents.llm</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="livekit.agents.llm.tool_context.find_function_tools" href="#livekit.agents.llm.tool_context.find_function_tools">find_function_tools</a></code></li>
<li><code><a title="livekit.agents.llm.tool_context.function_tool" href="#livekit.agents.llm.tool_context.function_tool">function_tool</a></code></li>
<li><code><a title="livekit.agents.llm.tool_context.get_function_info" href="#livekit.agents.llm.tool_context.get_function_info">get_function_info</a></code></li>
<li><code><a title="livekit.agents.llm.tool_context.get_raw_function_info" href="#livekit.agents.llm.tool_context.get_raw_function_info">get_raw_function_info</a></code></li>
<li><code><a title="livekit.agents.llm.tool_context.is_function_tool" href="#livekit.agents.llm.tool_context.is_function_tool">is_function_tool</a></code></li>
<li><code><a title="livekit.agents.llm.tool_context.is_raw_function_tool" href="#livekit.agents.llm.tool_context.is_raw_function_tool">is_raw_function_tool</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="livekit.agents.llm.tool_context.Function" href="#livekit.agents.llm.tool_context.Function">Function</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.tool_context.Function.name" href="#livekit.agents.llm.tool_context.Function.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.tool_context.FunctionTool" href="#livekit.agents.llm.tool_context.FunctionTool">FunctionTool</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.llm.tool_context.NamedToolChoice" href="#livekit.agents.llm.tool_context.NamedToolChoice">NamedToolChoice</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.tool_context.NamedToolChoice.function" href="#livekit.agents.llm.tool_context.NamedToolChoice.function">function</a></code></li>
<li><code><a title="livekit.agents.llm.tool_context.NamedToolChoice.type" href="#livekit.agents.llm.tool_context.NamedToolChoice.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.tool_context.RawFunctionDescription" href="#livekit.agents.llm.tool_context.RawFunctionDescription">RawFunctionDescription</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.tool_context.RawFunctionDescription.description" href="#livekit.agents.llm.tool_context.RawFunctionDescription.description">description</a></code></li>
<li><code><a title="livekit.agents.llm.tool_context.RawFunctionDescription.name" href="#livekit.agents.llm.tool_context.RawFunctionDescription.name">name</a></code></li>
<li><code><a title="livekit.agents.llm.tool_context.RawFunctionDescription.parameters" href="#livekit.agents.llm.tool_context.RawFunctionDescription.parameters">parameters</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.tool_context.RawFunctionTool" href="#livekit.agents.llm.tool_context.RawFunctionTool">RawFunctionTool</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.llm.tool_context.StopResponse" href="#livekit.agents.llm.tool_context.StopResponse">StopResponse</a></code></h4>
</li>
<li>
<h4><code><a title="livekit.agents.llm.tool_context.ToolContext" href="#livekit.agents.llm.tool_context.ToolContext">ToolContext</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.tool_context.ToolContext.copy" href="#livekit.agents.llm.tool_context.ToolContext.copy">copy</a></code></li>
<li><code><a title="livekit.agents.llm.tool_context.ToolContext.empty" href="#livekit.agents.llm.tool_context.ToolContext.empty">empty</a></code></li>
<li><code><a title="livekit.agents.llm.tool_context.ToolContext.function_tools" href="#livekit.agents.llm.tool_context.ToolContext.function_tools">function_tools</a></code></li>
<li><code><a title="livekit.agents.llm.tool_context.ToolContext.update_tools" href="#livekit.agents.llm.tool_context.ToolContext.update_tools">update_tools</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livekit.agents.llm.tool_context.ToolError" href="#livekit.agents.llm.tool_context.ToolError">ToolError</a></code></h4>
<ul class="">
<li><code><a title="livekit.agents.llm.tool_context.ToolError.message" href="#livekit.agents.llm.tool_context.ToolError.message">message</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
